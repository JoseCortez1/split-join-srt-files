10152
06:18:34,600 --> 06:18:39,798
is the fourth bite and even though the

10153
06:18:36,638 --> 06:18:42,280
string itself is hi I think we can

10154
06:18:39,798 --> 06:18:46,280
corroborate this whole null thing make

10155
06:18:42,280 --> 06:18:47,798
high SL High enter and there it is you

10156
06:18:46,280 --> 06:18:49,557
could have done this last week if you

10157
06:18:47,798 --> 06:18:51,478
really wanted to geek out on strings but

10158
06:18:49,558 --> 06:18:53,600
like for now it's just revealing what's

10159
06:18:51,478 --> 06:18:57,840
going on underneath the hood questions

10160
06:18:53,600 --> 06:18:57,840
then on what these strings are

10161
06:19:00,320 --> 06:19:04,239
yeah why do we need the

10162
06:19:04,520 --> 06:19:08,600
bracket uh uh why do you not need

10163
06:19:06,600 --> 06:19:12,399
brackets good question why do I not need

10164
06:19:08,600 --> 06:19:14,478
brackets on line six uh to because uh s

10165
06:19:12,400 --> 06:19:17,280
is a string we'll see in a couple of

10166
06:19:14,478 --> 06:19:20,160
weeks that s is essentially implemented

10167
06:19:17,280 --> 06:19:22,079
underneath the hood indeed as an array

10168
06:19:20,160 --> 06:19:25,400
but that happens automatically for you

10169
06:19:22,080 --> 06:19:27,200
you can treat S as just a variable name

10170
06:19:25,400 --> 06:19:28,760
without square brackets you will use

10171
06:19:27,200 --> 06:19:31,080
square brackets when you have arrays of

10172
06:19:28,760 --> 06:19:33,280
ins or you manually create arrays of

10173
06:19:31,080 --> 06:19:35,638
chars or doubles or Floats or anything

10174
06:19:33,280 --> 06:19:37,360
else but strings are special why I mean

10175
06:19:35,638 --> 06:19:39,478
every program you write seems to use

10176
06:19:37,360 --> 06:19:41,400
strings text in some form we're humans

10177
06:19:39,478 --> 06:19:43,320
we like text not just numbers and and

10178
06:19:41,400 --> 06:19:45,840
such so this is just treated a little

10179
06:19:43,320 --> 06:19:47,478
specially in C and many other languages

10180
06:19:45,840 --> 06:19:51,478
as

10181
06:19:47,478 --> 06:19:53,079
well other questions on this here no

10182
06:19:51,478 --> 06:19:55,200
let's add then one other string to the

10183
06:19:53,080 --> 06:19:56,478
mix so instead of just saying hi why

10184
06:19:55,200 --> 06:19:59,440
don't we consider version of the program

10185
06:19:56,478 --> 06:20:01,798
that says both high and by and I claim

10186
06:19:59,440 --> 06:20:03,120
now that that back sl0 that null

10187
06:20:01,798 --> 06:20:05,199
character is going to be ever more

10188
06:20:03,120 --> 06:20:06,840
important now if we've got two strings

10189
06:20:05,200 --> 06:20:08,638
in memory so that c knows how to

10190
06:20:06,840 --> 06:20:09,798
distinguish one from the other so let me

10191
06:20:08,638 --> 06:20:11,760
go ahead and just get rid of these two

10192
06:20:09,798 --> 06:20:14,199
lines for the moment let me recreate

10193
06:20:11,760 --> 06:20:16,280
string s equals quote unquote double

10194
06:20:14,200 --> 06:20:17,840
quotes High Let me give myself another

10195
06:20:16,280 --> 06:20:19,520
one and because I'm just playing around

10196
06:20:17,840 --> 06:20:22,958
I'll choose very short variable names

10197
06:20:19,520 --> 06:20:24,840
string T equals quote unquote by

10198
06:20:22,958 --> 06:20:26,840
exclamation point and then let me just

10199
06:20:24,840 --> 06:20:31,240
print them both out uh let me go ahead

10200
06:20:26,840 --> 06:20:35,840
and print out percent s back sln comma s

10201
06:20:31,240 --> 06:20:38,360
and then print F percent s uh back sln

10202
06:20:35,840 --> 06:20:41,878
and then T so very simple demonstration

10203
06:20:38,360 --> 06:20:43,798
of just these two variables make high do

10204
06:20:41,878 --> 06:20:46,360
SL high and of course it prints out two

10205
06:20:43,798 --> 06:20:47,760
lines one after the other what's

10206
06:20:46,360 --> 06:20:48,878
actually going on underneath the hood

10207
06:20:47,760 --> 06:20:50,679
well let's go back to the computer's

10208
06:20:48,878 --> 06:20:52,680
memory High I think it's going to be I

10209
06:20:50,680 --> 06:20:55,000
claim pretty much the same so s I'll

10210
06:20:52,680 --> 06:20:57,040
claim is in the top left followed by the

10211
06:20:55,000 --> 06:20:59,600
back sl0 and that's important now

10212
06:20:57,040 --> 06:21:01,320
because by probably is going to end up

10213
06:20:59,600 --> 06:21:02,638
there and Visually it wraps just by

10214
06:21:01,320 --> 06:21:05,160
nature of how I've drawn this grid of

10215
06:21:02,638 --> 06:21:09,478
bytes but it's continuous B ye

10216
06:21:05,160 --> 06:21:11,798
exclamation point null AKA back0 this is

10217
06:21:09,478 --> 06:21:15,520
Now helpful to print F because now

10218
06:21:11,798 --> 06:21:18,478
printf knows where one begins and ends

10219
06:21:15,520 --> 06:21:20,520
by way of that special null character

10220
06:21:18,478 --> 06:21:23,520
but we can poke around now too what else

10221
06:21:20,520 --> 06:21:27,478
can I do here how about this how about I

10222
06:21:23,520 --> 06:21:31,000
go into my code here back to BS code and

10223
06:21:27,478 --> 06:21:33,680
let me go ahead and say something like

10224
06:21:31,000 --> 06:21:35,280
well if I've got two of these uh strings

10225
06:21:33,680 --> 06:21:38,080
you know let's put them in an array

10226
06:21:35,280 --> 06:21:40,440
let's kind of do this sort of arrays in

10227
06:21:38,080 --> 06:21:43,760
arrays sort of inception style here so

10228
06:21:40,440 --> 06:21:45,798
string words bracket two so give me an

10229
06:21:43,760 --> 06:21:47,160
array of two strings is what I'm saying

10230
06:21:45,798 --> 06:21:48,520
here in code even though we've not done

10231
06:21:47,160 --> 06:21:51,320
it with strings yet we only did it with

10232
06:21:48,520 --> 06:21:54,160
ins and now let me do this the first

10233
06:21:51,320 --> 06:21:57,360
word AKA words bracket zero will equal

10234
06:21:54,160 --> 06:22:00,920
as before high and now words bracket one

10235
06:21:57,360 --> 06:22:02,958
will equal quote unquote by bite so by

10236
06:22:00,920 --> 06:22:05,280
and now I've done the exact same thing

10237
06:22:02,958 --> 06:22:07,039
but again I'm just avoiding having s t

10238
06:22:05,280 --> 06:22:09,280
QR and like all these different

10239
06:22:07,040 --> 06:22:11,878
variables in my code I just now I'm

10240
06:22:09,280 --> 06:22:14,120
treating them as one single array of

10241
06:22:11,878 --> 06:22:15,440
strings how do I change my code down

10242
06:22:14,120 --> 06:22:17,520
here well if I want to print the first

10243
06:22:15,440 --> 06:22:18,958
word I do words bracket zero and if I

10244
06:22:17,520 --> 06:22:21,080
want to print the second word I do words

10245
06:22:18,958 --> 06:22:22,557
bracket one this is not a useful

10246
06:22:21,080 --> 06:22:24,200
exercise at the moment because I'm just

10247
06:22:22,558 --> 06:22:26,080
making my code more complicated but

10248
06:22:24,200 --> 06:22:27,840
again it allows us to post poke around

10249
06:22:26,080 --> 06:22:31,120
and see what's going on because there is

10250
06:22:27,840 --> 06:22:34,478
that high and by but watch this if I

10251
06:22:31,120 --> 06:22:37,160
really want to be cool I can do this

10252
06:22:34,478 --> 06:22:41,320
let's print out percent C percent C

10253
06:22:37,160 --> 06:22:44,680
percent C back sln and then here percent

10254
06:22:41,320 --> 06:22:47,400
C percent C percent C percent C so four

10255
06:22:44,680 --> 06:22:50,280
of those and now here's where things get

10256
06:22:47,400 --> 06:22:52,200
interesting words is an array of strings

10257
06:22:50,280 --> 06:22:55,239
but again if I may what's a

10258
06:22:52,200 --> 06:22:57,840
string an array of characters so just

10259
06:22:55,240 --> 06:22:59,718
use the same logic if words is an array

10260
06:22:57,840 --> 06:23:01,558
of strings you get at the first string

10261
06:22:59,718 --> 06:23:03,520
with words bracket zero how do you get

10262
06:23:01,558 --> 06:23:07,440
at the first character in the first

10263
06:23:03,520 --> 06:23:10,638
string bracket Zer words bracket Z

10264
06:23:07,440 --> 06:23:14,160
bracket one and lastly words bracket Z

10265
06:23:10,638 --> 06:23:16,798
bracket two and now down here words

10266
06:23:14,160 --> 06:23:19,040
bracket one but the first character is

10267
06:23:16,798 --> 06:23:21,557
there words bracket one the second

10268
06:23:19,040 --> 06:23:23,798
character is here words bracket one the

10269
06:23:21,558 --> 06:23:25,478
third character is here whoops third

10270
06:23:23,798 --> 06:23:27,798
character is here and words bracket one

10271
06:23:25,478 --> 06:23:29,280
one the fourth character is here like

10272
06:23:27,798 --> 06:23:31,199
this is not how people program this is

10273
06:23:29,280 --> 06:23:33,840
only for demonstration sake my God it's

10274
06:23:31,200 --> 06:23:37,920
so tedious and verbose already but if I

10275
06:23:33,840 --> 06:23:40,440
make high now do SL high now I'm like

10276
06:23:37,920 --> 06:23:42,958
manually Reinventing percent s if I

10277
06:23:40,440 --> 06:23:45,120
forgot it existed using percent C alone

10278
06:23:42,958 --> 06:23:47,440
but you can indeed manipulate arrays in

10279
06:23:45,120 --> 06:23:50,280
this way but because strings are arrays

10280
06:23:47,440 --> 06:23:53,798
of characters you can manipulate strings

10281
06:23:50,280 --> 06:23:57,039
uh in this way too any question now on

10282
06:23:53,798 --> 06:24:00,280
this syntax

10283
06:23:57,040 --> 06:24:02,760
any questions here no no all right well

10284
06:24:00,280 --> 06:24:04,440
let's go ahead and propose that we solve

10285
06:24:02,760 --> 06:24:06,920
a couple of other problems we might not

10286
06:24:04,440 --> 06:24:08,239
have as before but first a quick visual

10287
06:24:06,920 --> 06:24:10,160
of what's been going on underneath the

10288
06:24:08,240 --> 06:24:12,760
hood here if here again is where we left

10289
06:24:10,160 --> 06:24:15,400
off on the screen high and by uh back to

10290
06:24:12,760 --> 06:24:19,519
back here is really how I just treated

10291
06:24:15,400 --> 06:24:22,320
these things s bracket 0123 and then t0

10292
06:24:19,520 --> 06:24:25,878
1 2 3 4 but really once I put them in an

10293
06:24:22,320 --> 06:24:27,760
array the picture becomes this words Z

10294
06:24:25,878 --> 06:24:29,600
is the whole High words bracket one is

10295
06:24:27,760 --> 06:24:31,600
the whole by but if I really get into

10296
06:24:29,600 --> 06:24:33,798
the weeds and start indexing into

10297
06:24:31,600 --> 06:24:37,199
individual characters in those strings

10298
06:24:33,798 --> 06:24:40,638
all I'm using is new syntax in order to

10299
06:24:37,200 --> 06:24:43,558
represent these same values here

10300
06:24:40,638 --> 06:24:47,680
questions then on these

10301
06:24:43,558 --> 06:24:51,520
representations before we Forge

10302
06:24:47,680 --> 06:24:51,520
ahead no

10303
06:24:52,280 --> 06:24:57,280
yeah does the new line character say

10304
06:24:55,040 --> 06:24:57,280
that one

10305
06:24:58,160 --> 06:25:02,638
more ah really good question does the

10306
06:25:00,200 --> 06:25:04,760
new line character take up any space uh

10307
06:25:02,638 --> 06:25:06,638
it does when so far as printf is

10308
06:25:04,760 --> 06:25:09,600
concerned but I'm not storing the back

10309
06:25:06,638 --> 06:25:12,239
slash n in my strings printf is being

10310
06:25:09,600 --> 06:25:14,680
manually handed that thing

10311
06:25:12,240 --> 06:25:16,558
instead all right so let's go ahead then

10312
06:25:14,680 --> 06:25:18,120
and consider how we might solve some

10313
06:25:16,558 --> 06:25:22,080
problems that have Arisen now with these

10314
06:25:18,120 --> 06:25:24,360
strings as follows here suppose I let's

10315
06:25:22,080 --> 06:25:26,000
do this let me go back to VSS code here

10316
06:25:24,360 --> 06:25:29,958
and let me go ahead and open up a new

10317
06:25:26,000 --> 06:25:31,360
file called how about uh length uh. C

10318
06:25:29,958 --> 06:25:32,680
and let's consider for a moment how I

10319
06:25:31,360 --> 06:25:34,920
might actually figure out what the

10320
06:25:32,680 --> 06:25:36,400
length of a string is which is distinct

10321
06:25:34,920 --> 06:25:37,760
from the length of an array I claimed

10322
06:25:36,400 --> 06:25:39,718
earlier you cannot figure out

10323
06:25:37,760 --> 06:25:41,958
dynamically what the length of an array

10324
06:25:39,718 --> 06:25:44,040
is but I can figure out the length of a

10325
06:25:41,958 --> 06:25:46,280
string specifically because of this

10326
06:25:44,040 --> 06:25:48,280
implementation detail of that null

10327
06:25:46,280 --> 06:25:50,798
character so let me go ahead and do this

10328
06:25:48,280 --> 06:25:54,079
let me include cs50.h in this second

10329
06:25:50,798 --> 06:25:57,160
program here let me include standard i.h

10330
06:25:54,080 --> 06:25:59,478
as before and let me do this int main

10331
06:25:57,160 --> 06:26:01,160
void and in the first thing I'll do is

10332
06:25:59,478 --> 06:26:03,239
just get a string from the user I'll ask

10333
06:26:01,160 --> 06:26:05,878
the user as always for their name so

10334
06:26:03,240 --> 06:26:08,558
I'll call get string and say what's your

10335
06:26:05,878 --> 06:26:10,280
name question mark as always and then

10336
06:26:08,558 --> 06:26:12,798
down here if I want to figure out the

10337
06:26:10,280 --> 06:26:15,760
length of this string and print the name

10338
06:26:12,798 --> 06:26:17,360
the print the length out on the screen

10339
06:26:15,760 --> 06:26:18,638
well I can kind of do this similar in

10340
06:26:17,360 --> 06:26:20,120
spirit to the average where I'm

10341
06:26:18,638 --> 06:26:23,680
accumulating something let me go ahead

10342
06:26:20,120 --> 06:26:26,079
and initialize n to zero let me give

10343
06:26:23,680 --> 06:26:27,400
myself huh it's not not a for Loop

10344
06:26:26,080 --> 06:26:29,240
because I don't have a I don't know in

10345
06:26:27,400 --> 06:26:30,680
advance how long it is but what if I do

10346
06:26:29,240 --> 06:26:36,080
this

10347
06:26:30,680 --> 06:26:39,520
while the value at name bracket n does

10348
06:26:36,080 --> 06:26:42,120
not equal single quote back

10349
06:26:39,520 --> 06:26:43,958
sl0 crazy syntax at the moment but it's

10350
06:26:42,120 --> 06:26:46,200
just the culmination of these various

10351
06:26:43,958 --> 06:26:47,958
building blocks let me just finish the

10352
06:26:46,200 --> 06:26:50,718
thought here

10353
06:26:47,958 --> 06:26:53,920
n++ and then down here let's just print

10354
06:26:50,718 --> 06:26:55,638
out with print F and percent I that

10355
06:26:53,920 --> 06:26:57,600
value of n

10356
06:26:55,638 --> 06:27:00,280
so I claim this is going to show me the

10357
06:26:57,600 --> 06:27:02,600
length of any string I type in whether

10358
06:27:00,280 --> 06:27:04,920
it's high or by or David or anything

10359
06:27:02,600 --> 06:27:05,717
else I initialize a variable to zero and

10360
06:27:04,920 --> 06:27:08,239
that's good because that's where you

10361
06:27:05,718 --> 06:27:11,000
start counting in general while name

10362
06:27:08,240 --> 06:27:12,878
bracket 0 does not equal back0 what is

10363
06:27:11,000 --> 06:27:14,958
this saying well if name is the string

10364
06:27:12,878 --> 06:27:17,320
the user typed in and name is just an

10365
06:27:14,958 --> 06:27:19,320
array as you noted then name bracket

10366
06:27:17,320 --> 06:27:20,878
zero is going to be the first character

10367
06:27:19,320 --> 06:27:23,600
and I'm asking the question well does

10368
06:27:20,878 --> 06:27:26,680
the first character not equal back0 and

10369
06:27:23,600 --> 06:27:28,920
if I type in David D is it's not so I

10370
06:27:26,680 --> 06:27:31,120
keep going and I add one to n then I'm

10371
06:27:28,920 --> 06:27:32,798
going to check name bracket one well if

10372
06:27:31,120 --> 06:27:35,920
I typed in David name bracket one is

10373
06:27:32,798 --> 06:27:38,120
going to be a a does not equal back0 and

10374
06:27:35,920 --> 06:27:40,877
so it's going to go again and again and

10375
06:27:38,120 --> 06:27:43,840
again but five steps in total later it's

10376
06:27:40,878 --> 06:27:45,558
going to get to the bite after David

10377
06:27:43,840 --> 06:27:48,240
realize wait a minute that is a back

10378
06:27:45,558 --> 06:27:50,680
slash n the Loop finishes and I print

10379
06:27:48,240 --> 06:27:53,760
out the total length arrays in general

10380
06:27:50,680 --> 06:27:56,280
do not have this null character however

10381
06:27:53,760 --> 06:27:58,120
strings do again strings are special

10382
06:27:56,280 --> 06:28:00,399
versus all of the other data types we've

10383
06:27:58,120 --> 06:28:03,320
talked about thus far but how could I

10384
06:28:00,400 --> 06:28:04,958
for instance uh do this differently well

10385
06:28:03,320 --> 06:28:07,280
let's actually Factor this out as a

10386
06:28:04,958 --> 06:28:10,120
function as I've I've commonly done but

10387
06:28:07,280 --> 06:28:12,079
rather than implement it myself you know

10388
06:28:10,120 --> 06:28:14,798
what it turns out what's nice about

10389
06:28:12,080 --> 06:28:16,200
strings being so common there are many

10390
06:28:14,798 --> 06:28:17,798
other people who have solved these

10391
06:28:16,200 --> 06:28:21,400
problems before and in fact there's a

10392
06:28:17,798 --> 06:28:24,280
whole string library in C it is used by

10393
06:28:21,400 --> 06:28:27,280
way of a header file called string.h and

10394
06:28:24,280 --> 06:28:29,000
what string H is is a library of string

10395
06:28:27,280 --> 06:28:32,440
related functions in fact you can see in

10396
06:28:29,000 --> 06:28:34,638
cs50's manual pages for C uh the

10397
06:28:32,440 --> 06:28:36,600
string.h functions at least those that

10398
06:28:34,638 --> 06:28:37,798
we recommend as most useful and in

10399
06:28:36,600 --> 06:28:38,958
particular if you poke around there

10400
06:28:37,798 --> 06:28:42,039
you'll see that there's a function

10401
06:28:38,958 --> 06:28:43,760
called Sterling means string length it

10402
06:28:42,040 --> 06:28:45,320
was named very succinctly just because

10403
06:28:43,760 --> 06:28:47,717
it's a little easier to type than string

10404
06:28:45,320 --> 06:28:49,680
length but Sterling tells you the length

10405
06:28:47,718 --> 06:28:51,840
of a string so how might I use this in

10406
06:28:49,680 --> 06:28:54,320
my code here well it turns out I can

10407
06:28:51,840 --> 06:28:57,520
simplify this quite a bit let me get rid

10408
06:28:54,320 --> 06:29:00,160
of my Loop get rid of my uh my counting

10409
06:28:57,520 --> 06:29:04,798
manually and do something like this int

10410
06:29:00,160 --> 06:29:07,079
n equals Sterling of the human's name

10411
06:29:04,798 --> 06:29:09,600
name and now I'll just use print f as

10412
06:29:07,080 --> 06:29:12,600
before with percent I back sln and

10413
06:29:09,600 --> 06:29:15,440
output the value of n but but there's a

10414
06:29:12,600 --> 06:29:17,399
bug at the moment what have I forgotten

10415
06:29:15,440 --> 06:29:19,840
to

10416
06:29:17,400 --> 06:29:22,080
do yeah I have to include the header

10417
06:29:19,840 --> 06:29:23,920
file at the top of the screen so let me

10418
06:29:22,080 --> 06:29:27,320
at the top of the code so let me also

10419
06:29:23,920 --> 06:29:29,958
include string.h at the top of my file

10420
06:29:27,320 --> 06:29:32,600
so that c knows that in fact sterl

10421
06:29:29,958 --> 06:29:33,877
exists let me go ahead and make length

10422
06:29:32,600 --> 06:29:36,840
as

10423
06:29:33,878 --> 06:29:39,400
before length uh or actually really for

10424
06:29:36,840 --> 06:29:41,760
the first time what's your name David

10425
06:29:39,400 --> 06:29:43,840
and hopefully I'm going to see in fact

10426
06:29:41,760 --> 06:29:46,359
five by contrast if I run it again and

10427
06:29:43,840 --> 06:29:48,558
type in high exclamation point now I see

10428
06:29:46,360 --> 06:29:50,120
three so Sterling is just one of the

10429
06:29:48,558 --> 06:29:52,200
functions in that library and there's so

10430
06:29:50,120 --> 06:29:53,718
many more in fact yet another library

10431
06:29:52,200 --> 06:29:55,718
that might be useful moving forward is

10432
06:29:53,718 --> 06:29:58,120
this one C

10433
06:29:55,718 --> 06:30:00,360
which relates to C data types and lots

10434
06:29:58,120 --> 06:30:01,920
of functions therein that can be useful

10435
06:30:00,360 --> 06:30:04,280
for instance if you review its

10436
06:30:01,920 --> 06:30:06,519
documentation in the manual pages online

10437
06:30:04,280 --> 06:30:09,239
you'll see that there are functions via

10438
06:30:06,520 --> 06:30:12,718
which we can solve problems like this

10439
06:30:09,240 --> 06:30:18,080
let me go ahead and propose here let me

10440
06:30:12,718 --> 06:30:20,920
see let's do um example here

10441
06:30:18,080 --> 06:30:23,478
involving how about uh checking if

10442
06:30:20,920 --> 06:30:26,638
something is uppercase or lowercase and

10443
06:30:23,478 --> 06:30:28,798
converting it uh to uppercase only let

10444
06:30:26,638 --> 06:30:31,680
me go back to vs code and code a program

10445
06:30:28,798 --> 06:30:33,320
called uppercase Doc in this file I'm

10446
06:30:31,680 --> 06:30:34,160
going to start by including now as

10447
06:30:33,320 --> 06:30:37,680
always

10448
06:30:34,160 --> 06:30:40,558
cs50.h I'm going to include standard i.h

10449
06:30:37,680 --> 06:30:42,160
and I'm going to add one other to the

10450
06:30:40,558 --> 06:30:44,920
mix which is

10451
06:30:42,160 --> 06:30:47,760
string.h now2 so I can access the length

10452
06:30:44,920 --> 06:30:50,039
of things as needed int main void comes

10453
06:30:47,760 --> 06:30:50,958
next and then within my main function

10454
06:30:50,040 --> 06:30:52,840
I'm going to go ahead and declare a

10455
06:30:50,958 --> 06:30:54,920
string called s I'm going to call get

10456
06:30:52,840 --> 06:30:57,200
string as before and I'm going to go

10457
06:30:54,920 --> 06:30:58,958
head and just ask the user for a string

10458
06:30:57,200 --> 06:31:00,638
called before I want to do it before and

10459
06:30:58,958 --> 06:31:02,958
after whatever the user types in is

10460
06:31:00,638 --> 06:31:06,200
before but I want to force everything to

10461
06:31:02,958 --> 06:31:09,760
uppercase thereafter let me now in this

10462
06:31:06,200 --> 06:31:12,440
Loop here do this let me print F quote

10463
06:31:09,760 --> 06:31:16,600
unquote after just so we can see this on

10464
06:31:12,440 --> 06:31:22,478
the screen and let me do four in I gets

10465
06:31:16,600 --> 06:31:23,958
zero I is less than stir Lang of s I ++

10466
06:31:22,478 --> 06:31:25,478
what am I about to do I'm about to

10467
06:31:23,958 --> 06:31:27,680
iterate over every every character in

10468
06:31:25,478 --> 06:31:30,397
the string from left to right from zero

10469
06:31:27,680 --> 06:31:32,920
on up two but not through the length of

10470
06:31:30,398 --> 06:31:35,280
s and how do I check if something is

10471
06:31:32,920 --> 06:31:38,079
lowercase so that I can actually force

10472
06:31:35,280 --> 06:31:41,717
it to uppercase well it turns out I

10473
06:31:38,080 --> 06:31:45,240
could do this literally if the character

10474
06:31:41,718 --> 06:31:48,718
in s at location I is greater than or

10475
06:31:45,240 --> 06:31:51,360
equal to Capital a Ampersand Ampersand

10476
06:31:48,718 --> 06:31:55,080
which means and instead of or which we

10477
06:31:51,360 --> 06:31:57,798
saw in the past s braet i is less than

10478
06:31:55,080 --> 06:32:00,240
or equal to little Z that means

10479
06:31:57,798 --> 06:32:03,120
logically in English that this is indeed

10480
06:32:00,240 --> 06:32:05,680
a lowercase how do I now convert it to

10481
06:32:03,120 --> 06:32:07,397
uppercase this character well I could

10482
06:32:05,680 --> 06:32:09,000
just literally print out the same

10483
06:32:07,398 --> 06:32:10,920
character but that would not be the

10484
06:32:09,000 --> 06:32:14,160
answer here because that's not changing

10485
06:32:10,920 --> 06:32:16,280
the value but what could I do instead

10486
06:32:14,160 --> 06:32:20,160
well let me actually pull up here real

10487
06:32:16,280 --> 06:32:23,397
fast the asky chart as before and let's

10488
06:32:20,160 --> 06:32:25,160
see if we can't glean some insight if I

10489
06:32:23,398 --> 06:32:26,600
pull up the same ask each chart and

10490
06:32:25,160 --> 06:32:29,000
suppose the human has typed in a

10491
06:32:26,600 --> 06:32:32,397
lowercase a that's

10492
06:32:29,000 --> 06:32:34,478
97 what letter I want to convert it to

10493
06:32:32,398 --> 06:32:39,478
uppercase a so what number do I want to

10494
06:32:34,478 --> 06:32:41,160
convert the 97 to per week zero so 65 we

10495
06:32:39,478 --> 06:32:43,079
keep coming back to that one what if the

10496
06:32:41,160 --> 06:32:47,200
user types in lowercase B I want to

10497
06:32:43,080 --> 06:32:49,958
change the 98 value to 66 and so forth

10498
06:32:47,200 --> 06:32:52,320
and any quick math how far part of those

10499
06:32:49,958 --> 06:32:54,160
so it's always 32 like uppercase to

10500
06:32:52,320 --> 06:32:58,120
lower case is always wonderfully good

10501
06:32:54,160 --> 06:32:59,520
design 32 away one from the other so

10502
06:32:58,120 --> 06:33:01,120
what does this mean well I think we saw

10503
06:32:59,520 --> 06:33:03,200
earlier that underneath the hood a Char

10504
06:33:01,120 --> 06:33:05,280
is just a number you can certainly do

10505
06:33:03,200 --> 06:33:06,920
arithmetic on it and here again if you

10506
06:33:05,280 --> 06:33:09,638
understand these lower level Primitives

10507
06:33:06,920 --> 06:33:12,079
what if I do this whatever s bracket I

10508
06:33:09,638 --> 06:33:14,600
is if I know on line 13 that it's up

10509
06:33:12,080 --> 06:33:16,520
that it's lowercase do I want to add or

10510
06:33:14,600 --> 06:33:18,958
subtract

10511
06:33:16,520 --> 06:33:24,040
32 so I want to subtract because I want

10512
06:33:18,958 --> 06:33:25,478
to go from like 97 to 65 or 98 to 66 so

10513
06:33:24,040 --> 06:33:27,920
indeed if you do some quick math that

10514
06:33:25,478 --> 06:33:30,760
gives you 32 so it suffices to just

10515
06:33:27,920 --> 06:33:33,120
treat chars as numbers subtract the 32

10516
06:33:30,760 --> 06:33:36,239
and printing it with percent C I think

10517
06:33:33,120 --> 06:33:37,638
will just convert lowercase to uppercase

10518
06:33:36,240 --> 06:33:39,878
if you now fast forward to like the real

10519
06:33:37,638 --> 06:33:41,280
world Microsoft Word or Google Docs if

10520
06:33:39,878 --> 06:33:43,080
you've ever chosen the menu option that

10521
06:33:41,280 --> 06:33:44,958
forces things to uppercase or lowercase

10522
06:33:43,080 --> 06:33:46,360
on occasion literally that's what

10523
06:33:44,958 --> 06:33:47,840
Microsoft and Google have done they

10524
06:33:46,360 --> 06:33:49,558
iterate over every character in the

10525
06:33:47,840 --> 06:33:52,520
document check if it's lowercase and if

10526
06:33:49,558 --> 06:33:55,520
so they subtract 32 from it and show you

10527
06:33:52,520 --> 06:33:57,600
the new value what if though it is not a

10528
06:33:55,520 --> 06:33:59,160
lowercase letter I think I can keep it

10529
06:33:57,600 --> 06:34:02,079
easy and just print out the current

10530
06:33:59,160 --> 06:34:04,280
letter unchanged if my goal is to Simply

10531
06:34:02,080 --> 06:34:06,920
Force things to all uppercase and that

10532
06:34:04,280 --> 06:34:09,320
letter then would be S bracket I so let

10533
06:34:06,920 --> 06:34:12,397
me go ahead now and make uppercase

10534
06:34:09,320 --> 06:34:14,680
hopefully no errors do/ uppercase and

10535
06:34:12,398 --> 06:34:16,478
I'll now now type in David with an

10536
06:34:14,680 --> 06:34:19,920
uppercase D but lowercase everything

10537
06:34:16,478 --> 06:34:22,280
else but now the after version is David

10538
06:34:19,920 --> 06:34:24,478
an aesthetic bug notice here I forgot to

10539
06:34:22,280 --> 06:34:26,920
include just for prettiness sake about

10540
06:34:24,478 --> 06:34:29,798
back sln at the end no problem I'll add

10541
06:34:26,920 --> 06:34:33,397
that let me fix my mistake make

10542
06:34:29,798 --> 06:34:35,239
uppercase SL uppercase enter daid enter

10543
06:34:33,398 --> 06:34:37,000
and voila and I I deliberately added

10544
06:34:35,240 --> 06:34:38,638
another space after the after just so

10545
06:34:37,000 --> 06:34:40,760
they would line up pretty even though

10546
06:34:38,638 --> 06:34:43,440
before and after have different numbers

10547
06:34:40,760 --> 06:34:45,760
of letters questions then on this

10548
06:34:43,440 --> 06:34:47,280
implementation of forcing something to

10549
06:34:45,760 --> 06:34:48,638
uppercase which in and of itself is not

10550
06:34:47,280 --> 06:34:50,638
all that enlightening but is

10551
06:34:48,638 --> 06:34:52,958
representative now of how you can

10552
06:34:50,638 --> 06:34:55,958
leverage these low-level

10553
06:34:52,958 --> 06:34:58,120
Primitives question

10554
06:34:55,958 --> 06:34:59,638
now all right well this honestly is

10555
06:34:58,120 --> 06:35:01,360
tedious my God like does Microsoft

10556
06:34:59,638 --> 06:35:02,878
Google everyone you have to literally

10557
06:35:01,360 --> 06:35:05,080
write out this code just to do something

10558
06:35:02,878 --> 06:35:07,000
simple well no that's again why we have

10559
06:35:05,080 --> 06:35:09,080
things like libraries and increasingly

10560
06:35:07,000 --> 06:35:11,160
now for problem sets projects and Beyond

10561
06:35:09,080 --> 06:35:12,958
well you just use libraries more often

10562
06:35:11,160 --> 06:35:15,320
off the shelf so as to solve problems

10563
06:35:12,958 --> 06:35:18,440
that surely other people have had before

10564
06:35:15,320 --> 06:35:21,200
you so how can I now use this uh Library

10565
06:35:18,440 --> 06:35:23,478
ctype.h well let me go back into my code

10566
06:35:21,200 --> 06:35:25,600
let me include this among my header

10567
06:35:23,478 --> 06:35:27,478
files here I tend just so I can skim

10568
06:35:25,600 --> 06:35:28,680
things easily I tend to alphabetize my

10569
06:35:27,478 --> 06:35:30,079
headers but that's not strictly

10570
06:35:28,680 --> 06:35:32,160
necessary but it allows me at a glance

10571
06:35:30,080 --> 06:35:34,478
to realize did I or did I not include

10572
06:35:32,160 --> 06:35:37,079
something I need now let me go ahead and

10573
06:35:34,478 --> 06:35:40,440
do this it turns out if you read the

10574
06:35:37,080 --> 06:35:42,718
documentation for the ctype library

10575
06:35:40,440 --> 06:35:46,000
there is a function wonderfully called

10576
06:35:42,718 --> 06:35:48,920
if is lower that takes in a character as

10577
06:35:46,000 --> 06:35:51,320
its argument essentially so s bracket I

10578
06:35:48,920 --> 06:35:52,958
and if that returns true a Boolean value

10579
06:35:51,320 --> 06:35:55,160
if you will well I'm going to force it

10580
06:35:52,958 --> 06:35:57,798
to lowercase but I don't have to do this

10581
06:35:55,160 --> 06:35:59,520
this math anymore turns out in the ctype

10582
06:35:57,798 --> 06:36:01,600
library there's also a function called

10583
06:35:59,520 --> 06:36:03,718
two upper that takes a character as

10584
06:36:01,600 --> 06:36:05,359
input like s bracket I and it just does

10585
06:36:03,718 --> 06:36:07,520
the math for you so that you can

10586
06:36:05,360 --> 06:36:09,160
abstract away the 32 thing and just know

10587
06:36:07,520 --> 06:36:11,280
that someone else has solved that

10588
06:36:09,160 --> 06:36:13,240
problem for you otherwise I can leave my

10589
06:36:11,280 --> 06:36:15,638
code unchanged down below because I'm

10590
06:36:13,240 --> 06:36:18,600
not changing anything else so if I do

10591
06:36:15,638 --> 06:36:21,798
make uppercase now and then do SL

10592
06:36:18,600 --> 06:36:24,079
uppercase daavid with just a capital D

10593
06:36:21,798 --> 06:36:26,000
and now it still works but if you read

10594
06:36:24,080 --> 06:36:28,200
the documentation further it turns out

10595
06:36:26,000 --> 06:36:30,040
that two upper is smart if you pass in a

10596
06:36:28,200 --> 06:36:31,878
character to two upper that's lowercase

10597
06:36:30,040 --> 06:36:33,958
it obviously converts its uppercase by

10598
06:36:31,878 --> 06:36:36,440
doing that math but if you pass in a

10599
06:36:33,958 --> 06:36:38,160
character to to Upper that's already

10600
06:36:36,440 --> 06:36:40,397
uppercase the documentation you would

10601
06:36:38,160 --> 06:36:43,200
see tells you that it leaves it

10602
06:36:40,398 --> 06:36:46,040
unchanged so I can tighten all of this

10603
06:36:43,200 --> 06:36:48,920
up I can get rid of the whole else I can

10604
06:36:46,040 --> 06:36:50,840
get rid of the whole if and arguably now

10605
06:36:48,920 --> 06:36:54,519
Implement a program that's just as

10606
06:36:50,840 --> 06:36:56,600
correct but better designed why fewer

10607
06:36:54,520 --> 06:36:58,398
lines of code easier to read Le lower

10608
06:36:56,600 --> 06:37:00,359
probability of mistakes assuming the

10609
06:36:58,398 --> 06:37:02,440
library is correct it just makes it

10610
06:37:00,360 --> 06:37:04,920
easier and faster for me now to write

10611
06:37:02,440 --> 06:37:08,320
code so if I now do one last time make

10612
06:37:04,920 --> 06:37:11,160
uppercase enter uppercase and type in my

10613
06:37:08,320 --> 06:37:13,320
name still working but now notice we've

10614
06:37:11,160 --> 06:37:16,680
whittel this down to far fewer lines of

10615
06:37:13,320 --> 06:37:21,558
code albeit using now this additional

10616
06:37:16,680 --> 06:37:24,798
Library questions then on how we did

10617
06:37:21,558 --> 06:37:26,398
this no well even even though this code

10618
06:37:24,798 --> 06:37:29,039
I dare say is correct it's not

10619
06:37:26,398 --> 06:37:31,798
necessarily welld designed just yet in

10620
06:37:29,040 --> 06:37:33,398
fact there's one line of code one

10621
06:37:31,798 --> 06:37:36,239
function call in this current

10622
06:37:33,398 --> 06:37:38,760
implementation that's more inefficient

10623
06:37:36,240 --> 06:37:41,920
than it needs to be and allow me to draw

10624
06:37:38,760 --> 06:37:44,557
our attention to this here line 10

10625
06:37:41,920 --> 06:37:46,638
wherein we're calling Sterling but we're

10626
06:37:44,558 --> 06:37:49,240
calling it inside of this for Loop

10627
06:37:46,638 --> 06:37:51,320
specifically inside of the condition and

10628
06:37:49,240 --> 06:37:52,680
why might that not necessarily be the

10629
06:37:51,320 --> 06:37:55,558
best

10630
06:37:52,680 --> 06:37:57,440
idea well is the length of the string s

10631
06:37:55,558 --> 06:37:59,200
changing ever I mean certainly not

10632
06:37:57,440 --> 06:38:01,557
within the span of this Loop and so here

10633
06:37:59,200 --> 06:38:04,398
we are within our for loop on line 10 11

10634
06:38:01,558 --> 06:38:06,080
12 and 13 asking on every iteration that

10635
06:38:04,398 --> 06:38:07,638
same question what's the length of s

10636
06:38:06,080 --> 06:38:10,040
what's the length of s what's the length

10637
06:38:07,638 --> 06:38:11,320
of s and in turn we're calling Sterling

10638
06:38:10,040 --> 06:38:13,558
every time even though we're getting

10639
06:38:11,320 --> 06:38:15,360
back the same answer so I dare say a

10640
06:38:13,558 --> 06:38:17,600
better solution here would be to maybe

10641
06:38:15,360 --> 06:38:19,600
figure out the length of s earlier on in

10642
06:38:17,600 --> 06:38:20,717
my code and maybe declare a variable or

10643
06:38:19,600 --> 06:38:22,478
perhaps do something that's

10644
06:38:20,718 --> 06:38:24,440
syntactically a little more elegant and

10645
06:38:22,478 --> 06:38:26,160
in fact a very common design in Loop

10646
06:38:24,440 --> 06:38:28,520
like this would be to declare not just

10647
06:38:26,160 --> 06:38:31,200
one variable like I but to actually

10648
06:38:28,520 --> 06:38:33,520
declare a second variable called n for

10649
06:38:31,200 --> 06:38:36,798
instance where n is just some number Set

10650
06:38:33,520 --> 06:38:38,798
n equal to the length of s but

10651
06:38:36,798 --> 06:38:41,478
thereafter inside of this condition

10652
06:38:38,798 --> 06:38:44,520
instead of calling Sterling of s again

10653
06:38:41,478 --> 06:38:47,478
and again and again what might I now do

10654
06:38:44,520 --> 06:38:49,120
I could instead just compare I against n

10655
06:38:47,478 --> 06:38:50,920
itself because n now will only be

10656
06:38:49,120 --> 06:38:52,718
calculated once when it's initialized

10657
06:38:50,920 --> 06:38:54,079
just as I is initialized to zero and

10658
06:38:52,718 --> 06:38:56,520
thereafter we're going to be compar

10659
06:38:54,080 --> 06:38:57,718
comparing I which is changing against n

10660
06:38:56,520 --> 06:39:00,520
which will not be so it's going to be

10661
06:38:57,718 --> 06:39:02,280
marginally more efficient by Design now

10662
06:39:00,520 --> 06:39:04,478
with that said a good compiler could

10663
06:39:02,280 --> 06:39:06,440
also recognize that there was this

10664
06:39:04,478 --> 06:39:08,320
optimization possibility and maybe do it

10665
06:39:06,440 --> 06:39:10,000
for us but for now best to get into the

10666
06:39:08,320 --> 06:39:12,958
Habit best to develop the muscle memory

10667
06:39:10,000 --> 06:39:17,840
for making those better design decisions

10668
06:39:12,958 --> 06:39:21,600
yourselves questions then on how we did

10669
06:39:17,840 --> 06:39:24,280
this no all right a few final building

10670
06:39:21,600 --> 06:39:25,717
blocks for the day so we started by

10671
06:39:24,280 --> 06:39:28,638
talking about those command line

10672
06:39:25,718 --> 06:39:30,878
arguments that clang uses whereby

10673
06:39:28,638 --> 06:39:34,360
anything after the command that you type

10674
06:39:30,878 --> 06:39:37,600
at a prompt be it make or clang or even

10675
06:39:34,360 --> 06:39:39,680
CD in Linux any word thereafter or

10676
06:39:37,600 --> 06:39:42,000
something cryptic like- O is a

10677
06:39:39,680 --> 06:39:43,440
commandline argument it's an input to

10678
06:39:42,000 --> 06:39:44,798
the command it's different from a

10679
06:39:43,440 --> 06:39:46,557
function argument because a function

10680
06:39:44,798 --> 06:39:48,280
argument of course is an input to a

10681
06:39:46,558 --> 06:39:49,760
function but it's the same idea it's

10682
06:39:48,280 --> 06:39:52,397
just different syntax after the dollar

10683
06:39:49,760 --> 06:39:53,717
sign at the prompt well it turns out

10684
06:39:52,398 --> 06:39:56,680
that command line arguments are

10685
06:39:53,718 --> 06:39:58,638
something you can now use in your own

10686
06:39:56,680 --> 06:40:01,798
programs by

10687
06:39:58,638 --> 06:40:04,079
accessing uh words after the prompt and

10688
06:40:01,798 --> 06:40:06,958
let me propose that we invent we invent

10689
06:40:04,080 --> 06:40:09,840
this as follows let me propose that we

10690
06:40:06,958 --> 06:40:13,557
switch back to vs code here and I'll

10691
06:40:09,840 --> 06:40:15,200
open a new file here called greet doc so

10692
06:40:13,558 --> 06:40:17,200
in greet Doc is going to be a program

10693
06:40:15,200 --> 06:40:18,680
that very simply greets the user had we

10694
06:40:17,200 --> 06:40:21,160
written this last week we would have

10695
06:40:18,680 --> 06:40:25,160
done this include

10696
06:40:21,160 --> 06:40:28,478
cs50.h and then include uh standard

10697
06:40:25,160 --> 06:40:30,680
i.h and then int main void and then we

10698
06:40:28,478 --> 06:40:33,718
might do something simple like string

10699
06:40:30,680 --> 06:40:36,160
name equals get string quote unquote

10700
06:40:33,718 --> 06:40:38,240
what's your name question mark and then

10701
06:40:36,160 --> 06:40:40,638
we would have printed out as always

10702
06:40:38,240 --> 06:40:43,000
hello comma percent s and then plugging

10703
06:40:40,638 --> 06:40:45,160
in that name so this is the same program

10704
06:40:43,000 --> 06:40:47,200
we've implemented many times just to

10705
06:40:45,160 --> 06:40:49,600
make sure it works although nope that's

10706
06:40:47,200 --> 06:40:52,200
not quite the same program semicolon in

10707
06:40:49,600 --> 06:40:55,397
the wrong place this now is the same

10708
06:40:52,200 --> 06:40:57,718
program so make greet /g greet and I'll

10709
06:40:55,398 --> 06:41:00,200
type in my own name hello David so we're

10710
06:40:57,718 --> 06:41:02,440
back there now what's arguably a little

10711
06:41:00,200 --> 06:41:04,760
Annoying about this program if I type in

10712
06:41:02,440 --> 06:41:06,440
something else like Carter enter you

10713
06:41:04,760 --> 06:41:09,079
know I have to run the program wait for

10714
06:41:06,440 --> 06:41:11,359
the prompt type in my name hit enter and

10715
06:41:09,080 --> 06:41:13,240
that's fine but imagine if every program

10716
06:41:11,360 --> 06:41:15,120
worked like this like make suppose you

10717
06:41:13,240 --> 06:41:16,520
could only type make then you wait for a

10718
06:41:15,120 --> 06:41:17,798
prompt then you type the name of the

10719
06:41:16,520 --> 06:41:20,600
program you want to make then you hit

10720
06:41:17,798 --> 06:41:22,239
enter or worse in Linux when you have to

10721
06:41:20,600 --> 06:41:24,199
change directories as you might have for

10722
06:41:22,240 --> 06:41:26,360
problem set one what if you had to type

10723
06:41:24,200 --> 06:41:28,000
CD enter now type the name of the folder

10724
06:41:26,360 --> 06:41:30,280
you want to change into enter I mean it

10725
06:41:28,000 --> 06:41:32,160
just slows life down and so it just gets

10726
06:41:30,280 --> 06:41:33,717
annoying quickly so commandline

10727
06:41:32,160 --> 06:41:36,920
arguments just let you express your

10728
06:41:33,718 --> 06:41:39,440
whole thought all at once so how can I

10729
06:41:36,920 --> 06:41:41,557
do this well if I want to express the

10730
06:41:39,440 --> 06:41:45,557
notion of command line arguments in my

10731
06:41:41,558 --> 06:41:48,398
code I could do something like this I

10732
06:41:45,558 --> 06:41:51,040
could for the very first time go up and

10733
06:41:48,398 --> 06:41:53,878
get rid of this void which as of today

10734
06:41:51,040 --> 06:41:56,680
means this program takes no command line

10735
06:41:53,878 --> 06:42:03,320
arguments and I can change it to exactly

10736
06:41:56,680 --> 06:42:05,160
this int ARG C string argv with brackets

10737
06:42:03,320 --> 06:42:07,760
now it's cryptic admittedly and let me

10738
06:42:05,160 --> 06:42:11,160
zoom in but I think we can perhaps infer

10739
06:42:07,760 --> 06:42:12,798
now what's going on if main Now does not

10740
06:42:11,160 --> 06:42:15,398
have void as its input which means it

10741
06:42:12,798 --> 06:42:17,320
takes no arguments surely the spoiler

10742
06:42:15,398 --> 06:42:20,120
here is that now main will take command

10743
06:42:17,320 --> 06:42:25,120
line argument somehow any guesses as to

10744
06:42:20,120 --> 06:42:27,200
what argv is or will be

10745
06:42:25,120 --> 06:42:30,079
what might this

10746
06:42:27,200 --> 06:42:33,360
represent it's an array of strings right

10747
06:42:30,080 --> 06:42:33,360
by way of the syntax

10748
06:42:34,398 --> 06:42:38,080
yeah exactly it will be all of the

10749
06:42:36,478 --> 06:42:40,798
characters or really all of the words

10750
06:42:38,080 --> 06:42:43,240
that you type at the prompt argc as an

10751
06:42:40,798 --> 06:42:45,280
INT any

10752
06:42:43,240 --> 06:42:47,398
guess

10753
06:42:45,280 --> 06:42:48,680
argument count is what it generally

10754
06:42:47,398 --> 06:42:50,398
stands for though technically you could

10755
06:42:48,680 --> 06:42:52,280
call these things any anything but this

10756
06:42:50,398 --> 06:42:54,600
is the convention because I claimed

10757
06:42:52,280 --> 06:42:56,840
earlier that arrays don't keep track of

10758
06:42:54,600 --> 06:42:58,798
their own length if you want to know how

10759
06:42:56,840 --> 06:43:00,840
many words the human typed at the prompt

10760
06:42:58,798 --> 06:43:03,280
after your program's name you have to be

10761
06:43:00,840 --> 06:43:06,398
told not just the array of the words but

10762
06:43:03,280 --> 06:43:07,717
the length of that array the strings you

10763
06:43:06,398 --> 06:43:09,920
can figure out the length of using

10764
06:43:07,718 --> 06:43:12,680
Sterling but you can't figure out the

10765
06:43:09,920 --> 06:43:14,440
length of the array of strings the

10766
06:43:12,680 --> 06:43:17,080
collection of words that the human typed

10767
06:43:14,440 --> 06:43:19,638
in so how can I now use this well let me

10768
06:43:17,080 --> 06:43:22,398
go ahead and do this let me go ahead and

10769
06:43:19,638 --> 06:43:24,239
change this program now just to be print

10770
06:43:22,398 --> 06:43:29,558
F quote unquote

10771
06:43:24,240 --> 06:43:32,520
hello comma uh percent s back sln then

10772
06:43:29,558 --> 06:43:34,760
Arvy bracket 1 so this is not the best

10773
06:43:32,520 --> 06:43:39,000
version of my code yet but it's my first

10774
06:43:34,760 --> 06:43:43,359
make greet and now let me dog greet

10775
06:43:39,000 --> 06:43:46,440
David all at once enter hello David now

10776
06:43:43,360 --> 06:43:48,440
let me run it again dogre Carter enter

10777
06:43:46,440 --> 06:43:50,239
hello Carter you know it's a marginal

10778
06:43:48,440 --> 06:43:52,160
Improvement but I don't have to wait for

10779
06:43:50,240 --> 06:43:53,958
get string to prompt me to hit enter

10780
06:43:52,160 --> 06:43:57,398
it's just speeding things up you know is

10781
06:43:53,958 --> 06:43:59,600
fast one less command to type in but I

10782
06:43:57,398 --> 06:44:02,718
deliberately did bracket one but where

10783
06:43:59,600 --> 06:44:06,440
what's the beginning of arv it would be

10784
06:44:02,718 --> 06:44:08,760
bracket zero well what's that this is

10785
06:44:06,440 --> 06:44:11,717
sometimes useful though for now it's not

10786
06:44:08,760 --> 06:44:14,717
suppose I recompile my code and run this

10787
06:44:11,718 --> 06:44:18,280
program now greet David anyone want to

10788
06:44:14,718 --> 06:44:18,280
guess what's in argv

10789
06:44:18,398 --> 06:44:25,000
Z say

10790
06:44:20,160 --> 06:44:26,840
again greet enter hello. SLG greet so if

10791
06:44:25,000 --> 06:44:28,798
you want sort of inception style your

10792
06:44:26,840 --> 06:44:30,760
program to figure out what its own name

10793
06:44:28,798 --> 06:44:33,000
is or at least how it was executed at

10794
06:44:30,760 --> 06:44:35,440
the command line at the terminal you can

10795
06:44:33,000 --> 06:44:37,360
look at ARG v0 in general probably not

10796
06:44:35,440 --> 06:44:39,600
that useful probably better to start

10797
06:44:37,360 --> 06:44:41,878
looking at bracket one which was the

10798
06:44:39,600 --> 06:44:43,440
first word after the program name and if

10799
06:44:41,878 --> 06:44:46,000
there were more I could do this how

10800
06:44:43,440 --> 06:44:49,397
about RV bracket 2 let me add in a

10801
06:44:46,000 --> 06:44:53,760
second percent s let me recompile greet

10802
06:44:49,398 --> 06:44:56,280
let me do greet David maen enter and

10803
06:44:53,760 --> 06:44:57,877
that two now works taking in two words

10804
06:44:56,280 --> 06:44:59,320
at the prompt if I really want to be

10805
06:44:57,878 --> 06:45:02,398
smart at this now I could do something

10806
06:44:59,320 --> 06:45:06,558
like this though how about if the count

10807
06:45:02,398 --> 06:45:08,760
of arguments AKA AR C equals equals 2

10808
06:45:06,558 --> 06:45:12,160
then assume that the human typed in only

10809
06:45:08,760 --> 06:45:16,320
their first name and do print F uh hello

10810
06:45:12,160 --> 06:45:20,000
comma percent s back sln and then uh

10811
06:45:16,320 --> 06:45:22,160
argv bracket 1 else if the human did not

10812
06:45:20,000 --> 06:45:24,958
provide exactly two arguments the name

10813
06:45:22,160 --> 06:45:26,798
of the program and their own name let's

10814
06:45:24,958 --> 06:45:28,638
just print out a default value L they

10815
06:45:26,798 --> 06:45:31,079
forgot their name or they typed in two

10816
06:45:28,638 --> 06:45:33,160
names or three names let's just do uh

10817
06:45:31,080 --> 06:45:35,440
hello comma world as a default and we'll

10818
06:45:33,160 --> 06:45:38,558
just ignore what the human typed in if I

10819
06:45:35,440 --> 06:45:42,760
recompile this make greet I can dog

10820
06:45:38,558 --> 06:45:46,000
greet and David again enter oops uh

10821
06:45:42,760 --> 06:45:50,039
sorry what am I missing yeah so newbie

10822
06:45:46,000 --> 06:45:53,160
mistake else all right make greet again

10823
06:45:50,040 --> 06:45:54,040
dog greet David enter there's my hello

10824
06:45:53,160 --> 06:45:56,200
David

10825
06:45:54,040 --> 06:45:58,000
but if I omit my name I just get the

10826
06:45:56,200 --> 06:46:00,200
generic like a default value and if I

10827
06:45:58,000 --> 06:46:02,000
get a little curious and I type in both

10828
06:46:00,200 --> 06:46:03,798
names then I get ignored two why because

10829
06:46:02,000 --> 06:46:06,160
I just haven't built in support for arxy

10830
06:46:03,798 --> 06:46:08,920
of three I could do anything I want but

10831
06:46:06,160 --> 06:46:11,360
now we have access to these kinds of

10832
06:46:08,920 --> 06:46:13,717
building blocks all right what else

10833
06:46:11,360 --> 06:46:16,000
might I do here well it turns out there

10834
06:46:13,718 --> 06:46:19,320
might be some final features for us to

10835
06:46:16,000 --> 06:46:20,760
now execute um notice though that in C

10836
06:46:19,320 --> 06:46:23,558
despite what you might see in books or

10837
06:46:20,760 --> 06:46:25,557
online tutorials nowadays the two

10838
06:46:23,558 --> 06:46:27,000
official formats for defining a main

10839
06:46:25,558 --> 06:46:30,440
function are either this which we've

10840
06:46:27,000 --> 06:46:33,280
been using now for Two Plus weeks or now

10841
06:46:30,440 --> 06:46:36,600
this whereby you change the void to int

10842
06:46:33,280 --> 06:46:38,360
argc and then for now string argv and

10843
06:46:36,600 --> 06:46:40,120
then empty brackets and we'll see that

10844
06:46:38,360 --> 06:46:42,040
this two is an a simplification some

10845
06:46:40,120 --> 06:46:43,557
training wheels if you will but for now

10846
06:46:42,040 --> 06:46:45,080
those are the two forms even though you

10847
06:46:43,558 --> 06:46:47,360
will see in online tutorials and even

10848
06:46:45,080 --> 06:46:49,520
books some people use Maine in different

10849
06:46:47,360 --> 06:46:51,320
ways these are the two now to keep in

10850
06:46:49,520 --> 06:46:52,840
mind and I'll note that these command

10851
06:46:51,320 --> 06:46:54,360
line arguments are kind of all over the

10852
06:46:52,840 --> 06:46:55,760
place didn't probably expect to see this

10853
06:46:54,360 --> 06:46:57,520
word on the screen here and what does it

10854
06:46:55,760 --> 06:46:58,920
mean well it turns out that for decades

10855
06:46:57,520 --> 06:47:01,080
there's actually this program that comes

10856
06:46:58,920 --> 06:47:03,600
with Linux systems in particular called

10857
06:47:01,080 --> 06:47:05,200
coway why probably because someone had

10858
06:47:03,600 --> 06:47:07,840
too much free time once and decided to

10859
06:47:05,200 --> 06:47:10,478
write a program that creates asy art out

10860
06:47:07,840 --> 06:47:13,200
of a cow saying something textually on

10861
06:47:10,478 --> 06:47:15,760
the screen but you use coway Just For

10862
06:47:13,200 --> 06:47:18,840
Fun by way of command line arguments so

10863
06:47:15,760 --> 06:47:22,000
for instance let me propose that uh I go

10864
06:47:18,840 --> 06:47:23,718
back to vs code here not because I want

10865
06:47:22,000 --> 06:47:25,440
to write any code but I just want to use

10866
06:47:23,718 --> 06:47:27,478
my terminal window and let me uh

10867
06:47:25,440 --> 06:47:30,000
maximize my terminal window here and let

10868
06:47:27,478 --> 06:47:34,079
me go ahead and type in something like

10869
06:47:30,000 --> 06:47:35,398
how about c space moo so cow is not a

10870
06:47:34,080 --> 06:47:37,600
program I wrote It's been around for

10871
06:47:35,398 --> 06:47:39,878
decades but we installed it in vs code

10872
06:47:37,600 --> 06:47:41,600
for you in the cloud it takes at least

10873
06:47:39,878 --> 06:47:43,920
one command line argument what do you

10874
06:47:41,600 --> 06:47:46,239
want the cow to say I can say cow say

10875
06:47:43,920 --> 06:47:48,717
moo and hit enter and voila there's my

10876
06:47:46,240 --> 06:47:51,160
asky art of a cow saying moo on the

10877
06:47:48,718 --> 06:47:54,398
screen it can say multiple words so I

10878
06:47:51,160 --> 06:47:56,240
can say hello world and enter and now it

10879
06:47:54,398 --> 06:47:57,958
says hello world so this is just an

10880
06:47:56,240 --> 06:47:59,398
example of a silly program that uses

10881
06:47:57,958 --> 06:48:02,079
command line arguments but it takes

10882
06:47:59,398 --> 06:48:04,320
others too just like clang use this

10883
06:48:02,080 --> 06:48:06,680
convention of hyphens to change the

10884
06:48:04,320 --> 06:48:08,120
output of the program Dash something is

10885
06:48:06,680 --> 06:48:09,558
just a super common convention with

10886
06:48:08,120 --> 06:48:12,280
commandline arguments when you want a

10887
06:48:09,558 --> 06:48:15,520
very tur notation for some option like

10888
06:48:12,280 --> 06:48:18,000
output um in C I read the documentation

10889
06:48:15,520 --> 06:48:19,840
and it turns out there's a-f command

10890
06:48:18,000 --> 06:48:22,760
line argument that allows you to change

10891
06:48:19,840 --> 06:48:28,000
the uh the appearance of the cow if you

10892
06:48:22,760 --> 06:48:30,440
will so if I do coway dasf duck and then

10893
06:48:28,000 --> 06:48:32,600
some other word like quack it's no

10894
06:48:30,440 --> 06:48:35,000
longer a cow that command line argument

10895
06:48:32,600 --> 06:48:37,638
turns it into a tiny adorable duck

10896
06:48:35,000 --> 06:48:38,760
instead and then lastly just for fun

10897
06:48:37,638 --> 06:48:40,760
because I spent way too much time

10898
06:48:38,760 --> 06:48:44,440
playing with command line arguments uh

10899
06:48:40,760 --> 06:48:46,679
c-f dragon and then how about like raar

10900
06:48:44,440 --> 06:48:49,199
enter you can even get this on the

10901
06:48:46,680 --> 06:48:50,760
screen here so this too is just an

10902
06:48:49,200 --> 06:48:52,920
example of what you can do with these

10903
06:48:50,760 --> 06:48:54,798
command line arguments now that we have

10904
06:48:52,920 --> 06:48:56,839
this building block and there's one

10905
06:48:54,798 --> 06:48:58,760
final thing we can now do with code

10906
06:48:56,840 --> 06:49:00,440
there's one last feature today that

10907
06:48:58,760 --> 06:49:03,440
we'll introduce before we now connect

10908
06:49:00,440 --> 06:49:06,680
all of these dots to readability and and

10909
06:49:03,440 --> 06:49:08,840
encryption by talking lastly about

10910
06:49:06,680 --> 06:49:11,520
something called exit status it turns

10911
06:49:08,840 --> 06:49:14,558
out that whenever your main function

10912
06:49:11,520 --> 06:49:16,360
exits it returns a secret integer that

10913
06:49:14,558 --> 06:49:18,638
you can figure out as the programmer or

10914
06:49:16,360 --> 06:49:21,000
an advanced user what it was and these

10915
06:49:18,638 --> 06:49:22,920
exit codes exit statuses are typically

10916
06:49:21,000 --> 06:49:24,080
used to indicate errors so for instance

10917
06:49:22,920 --> 06:49:26,000
over over the past couple of years if

10918
06:49:24,080 --> 06:49:27,760
you us zoom and you ever got some kind

10919
06:49:26,000 --> 06:49:29,638
of error you might have seen a screen

10920
06:49:27,760 --> 06:49:31,679
like this it's usually not that helpful

10921
06:49:29,638 --> 06:49:34,478
maybe tells you to click report problem

10922
06:49:31,680 --> 06:49:37,000
or contact support but very often in our

10923
06:49:34,478 --> 06:49:39,280
human world on Macs PCS and phones you

10924
06:49:37,000 --> 06:49:41,478
see cryptic error codes like literally

10925
06:49:39,280 --> 06:49:43,320
numbers that probably only Zoom knows or

10926
06:49:41,478 --> 06:49:45,478
Microsoft or Google or whatever company

10927
06:49:43,320 --> 06:49:48,200
wrote the software you're using but that

10928
06:49:45,478 --> 06:49:50,680
number corresponds to a specific error

10929
06:49:48,200 --> 06:49:53,280
that some human somewhere knows might

10930
06:49:50,680 --> 06:49:54,840
very well happen these are used similar

10931
06:49:53,280 --> 06:49:57,000
L although under a different name that

10932
06:49:54,840 --> 06:49:59,200
we'll talk about later in the term uh on

10933
06:49:57,000 --> 06:50:02,000
the web as well have you ever seen this

10934
06:49:59,200 --> 06:50:03,600
maybe not character but number so 404

10935
06:50:02,000 --> 06:50:07,558
means

10936
06:50:03,600 --> 06:50:09,320
what so error yes but really not found

10937
06:50:07,558 --> 06:50:10,680
so why I mean this is the most Arcane

10938
06:50:09,320 --> 06:50:12,520
thing and we'll talk in a few weeks

10939
06:50:10,680 --> 06:50:14,360
about like what this and other numbers

10940
06:50:12,520 --> 06:50:15,920
mean but numbers are all around us in

10941
06:50:14,360 --> 06:50:17,280
technology and they very often mean

10942
06:50:15,920 --> 06:50:19,199
something to the technical people who

10943
06:50:17,280 --> 06:50:21,039
wrote the software less so to humans

10944
06:50:19,200 --> 06:50:23,638
like you and me why so many of us

10945
06:50:21,040 --> 06:50:25,120
recognize 404 is kind of weird that like

10946
06:50:23,638 --> 06:50:27,000
that's been around long enough that we

10947
06:50:25,120 --> 06:50:29,079
all know it but it really is just a

10948
06:50:27,000 --> 06:50:31,558
special number that represents an error

10949
06:50:29,080 --> 06:50:33,360
of some sort so it turns out the last

10950
06:50:31,558 --> 06:50:34,840
thing we'll reveal today about what

10951
06:50:33,360 --> 06:50:38,360
we've been taking for granted for two

10952
06:50:34,840 --> 06:50:40,160
weeks is what the int is in Maine we've

10953
06:50:38,360 --> 06:50:42,160
seen just a moment ago that the thing in

10954
06:50:40,160 --> 06:50:43,840
the parentheses which up until now has

10955
06:50:42,160 --> 06:50:47,600
been void which means no command line

10956
06:50:43,840 --> 06:50:49,478
arguments now in Arc string arv brackets

10957
06:50:47,600 --> 06:50:51,680
just means yes command line arguments

10958
06:50:49,478 --> 06:50:53,798
and we've seen how to access them so the

10959
06:50:51,680 --> 06:50:56,200
last piece of the puzzle honestly of all

10960
06:50:53,798 --> 06:50:58,958
the cryptic syntax the past two weeks is

10961
06:50:56,200 --> 06:51:01,080
just what int means int is always there

10962
06:50:58,958 --> 06:51:03,039
for Maine and it indicates that Maine

10963
06:51:01,080 --> 06:51:05,120
will always return an integer even

10964
06:51:03,040 --> 06:51:09,120
though you and I have never done so

10965
06:51:05,120 --> 06:51:11,120
explicitly usually Maine returns Zero by

10966
06:51:09,120 --> 06:51:13,280
default but it would be weird if you saw

10967
06:51:11,120 --> 06:51:14,718
an error message saying zero so zero is

10968
06:51:13,280 --> 06:51:15,798
just hidden you would never see it on

10969
06:51:14,718 --> 06:51:17,878
the screen but it's happening

10970
06:51:15,798 --> 06:51:20,199
automatically by way of how C is

10971
06:51:17,878 --> 06:51:22,478
designed so let me write one final

10972
06:51:20,200 --> 06:51:24,760
program here I'll call it for instance

10973
06:51:22,478 --> 06:51:28,239
status . C to show you these exit

10974
06:51:24,760 --> 06:51:29,920
statuses code of status. c and then up

10975
06:51:28,240 --> 06:51:31,320
here let me do something simple like

10976
06:51:29,920 --> 06:51:34,877
include

10977
06:51:31,320 --> 06:51:38,200
cs50.h then include standard i.h and

10978
06:51:34,878 --> 06:51:40,200
then int main uh let's do actually let's

10979
06:51:38,200 --> 06:51:43,718
use a command line argument in argc

10980
06:51:40,200 --> 06:51:49,320
string argv so that's copy paste but now

10981
06:51:43,718 --> 06:51:50,558
let's do this if argc does not equal to

10982
06:51:49,320 --> 06:51:53,040
why don't we do something like this

10983
06:51:50,558 --> 06:51:54,600
let's not just um default to hello world

10984
06:51:53,040 --> 06:51:56,920
like last time let's yell at the user so

10985
06:51:54,600 --> 06:51:59,478
let's say something like printf missing

10986
06:51:56,920 --> 06:52:01,039
command line argument so that they know

10987
06:51:59,478 --> 06:52:04,320
they screwed up and they need to run the

10988
06:52:01,040 --> 06:52:08,840
program again correctly else let's go

10989
06:52:04,320 --> 06:52:12,520
ahead and say print out uh as before

10990
06:52:08,840 --> 06:52:15,398
hello comma percent s and then plug in

10991
06:52:12,520 --> 06:52:18,000
argv bracket one so the human's name

10992
06:52:15,398 --> 06:52:20,398
from The Prompt now at this point let me

10993
06:52:18,000 --> 06:52:22,600
go ahead and run

10994
06:52:20,398 --> 06:52:25,040
statusstatus and I'll will type nothing

10995
06:52:22,600 --> 06:52:28,199
first first I get yelled at this time

10996
06:52:25,040 --> 06:52:31,120
I'll type it again/ status David and it

10997
06:52:28,200 --> 06:52:34,440
works properly but now let me show you a

10998
06:52:31,120 --> 06:52:36,600
somewhat secret cryptic command you can

10999
06:52:34,440 --> 06:52:38,000
type this at your prompt and it's just a

11000
06:52:36,600 --> 06:52:40,120
coincidence that there's another dollar

11001
06:52:38,000 --> 06:52:42,760
sign Echo dollar sign question mark

11002
06:52:40,120 --> 06:52:44,958
totally Arcane but it allows you to see

11003
06:52:42,760 --> 06:52:47,120
what exit status your program has ended

11004
06:52:44,958 --> 06:52:51,079
with so let me run this again the wrong

11005
06:52:47,120 --> 06:52:53,000
way/ status okay I get the error message

11006
06:52:51,080 --> 06:52:54,760
what was secretly returned I can't can't

11007
06:52:53,000 --> 06:52:56,798
see it there's obviously no error screen

11008
06:52:54,760 --> 06:52:59,280
but by typing Echo dollar sign question

11009
06:52:56,798 --> 06:53:02,440
mark I can see that oh my program

11010
06:52:59,280 --> 06:53:04,798
automatically by default return zero

11011
06:53:02,440 --> 06:53:07,680
however if I run it again correctly

11012
06:53:04,798 --> 06:53:10,478
status David enter this is the correct

11013
06:53:07,680 --> 06:53:12,200
version but if I run Echo question mark

11014
06:53:10,478 --> 06:53:14,760
status again it's still entered with

11015
06:53:12,200 --> 06:53:16,398
zero and long story short this is just a

11016
06:53:14,760 --> 06:53:18,638
missed opportunity when something goes

11017
06:53:16,398 --> 06:53:20,878
wrong why don't I return a value other

11018
06:53:18,638 --> 06:53:22,760
than zero zero by default means success

11019
06:53:20,878 --> 06:53:26,040
and it's always there automatically but

11020
06:53:22,760 --> 06:53:29,397
but you can control this I can go into

11021
06:53:26,040 --> 06:53:32,080
my code here and return one else if

11022
06:53:29,398 --> 06:53:33,878
something works fine I can return zero

11023
06:53:32,080 --> 06:53:36,360
by default and honestly if I omit the

11024
06:53:33,878 --> 06:53:38,040
return zero again zero automatically is

11025
06:53:36,360 --> 06:53:40,000
returned so let me go ahead and though

11026
06:53:38,040 --> 06:53:42,280
be explicit just so I know what's going

11027
06:53:40,000 --> 06:53:44,920
on make status

11028
06:53:42,280 --> 06:53:48,360
again/ status and let's do this

11029
06:53:44,920 --> 06:53:50,760
correctly with David enter hello David

11030
06:53:48,360 --> 06:53:53,200
Echo question mark uh Echo dollar sign

11031
06:53:50,760 --> 06:53:56,079
question mark zero so all is well

11032
06:53:53,200 --> 06:53:59,080
but now if I do/ status and nothing or

11033
06:53:56,080 --> 06:54:01,040
multiple things but not just David enter

11034
06:53:59,080 --> 06:54:03,600
I get the error message but now if I do

11035
06:54:01,040 --> 06:54:06,680
Echo dollar sign question mark waa there

11036
06:54:03,600 --> 06:54:08,958
now is the one so what does this now

11037
06:54:06,680 --> 06:54:10,160
mean this is in the graphical world we

11038
06:54:08,958 --> 06:54:11,320
would just show something like this on

11039
06:54:10,160 --> 06:54:12,798
the screen which is a little more

11040
06:54:11,320 --> 06:54:14,360
informative to the user but even in the

11041
06:54:12,798 --> 06:54:16,079
Linux world we don't have a guey

11042
06:54:14,360 --> 06:54:17,798
necessarily even for the programs we've

11043
06:54:16,080 --> 06:54:19,760
written you can check these exit

11044
06:54:17,798 --> 06:54:21,320
statuses and in fact more comfortable

11045
06:54:19,760 --> 06:54:24,000
more advanced programmers when they

11046
06:54:21,320 --> 06:54:27,320
write code that calls programs be it

11047
06:54:24,000 --> 06:54:29,520
coway or anything else you can encode

11048
06:54:27,320 --> 06:54:31,638
check what the exit status is of a

11049
06:54:29,520 --> 06:54:34,000
program and then decide did my program

11050
06:54:31,638 --> 06:54:36,878
work or did it not and now let's connect

11051
06:54:34,000 --> 06:54:40,240
the final dots uh before we adjourn for

11052
06:54:36,878 --> 06:54:42,200
some fruit snacks uh cryptography namely

11053
06:54:40,240 --> 06:54:44,558
one of the applications this week via

11054
06:54:42,200 --> 06:54:46,440
which you'll be able to send if you will

11055
06:54:44,558 --> 06:54:48,478
secret messages and better yet decre

11056
06:54:46,440 --> 06:54:50,359
secret messages this will be in addition

11057
06:54:48,478 --> 06:54:52,680
to perhaps analyzing the readability of

11058
06:54:50,360 --> 06:54:54,478
text using puristic like we identified

11059
06:54:52,680 --> 06:54:56,398
at the start of class 2 so a

11060
06:54:54,478 --> 06:54:58,920
cryptography is just the art the science

11061
06:54:56,398 --> 06:55:00,760
of encrypting information scrambling

11062
06:54:58,920 --> 06:55:03,760
information so that if you have a secret

11063
06:55:00,760 --> 06:55:05,760
message to send in so-called plain text

11064
06:55:03,760 --> 06:55:07,519
you can run it through some algorithm

11065
06:55:05,760 --> 06:55:10,557
and turn it into what's called Cipher

11066
06:55:07,520 --> 06:55:12,440
text thereby encrypting it and only

11067
06:55:10,558 --> 06:55:14,600
someone who knows what algorithm you've

11068
06:55:12,440 --> 06:55:17,120
used and what input you've used to the

11069
06:55:14,600 --> 06:55:18,717
algorithm theoretically can decrypt that

11070
06:55:17,120 --> 06:55:20,638
process and convert it back to the

11071
06:55:18,718 --> 06:55:22,958
original message so if we use our mental

11072
06:55:20,638 --> 06:55:25,397
model from last week here is a problem

11073
06:55:22,958 --> 06:55:27,199
here is an input and output the goal I

11074
06:55:25,398 --> 06:55:29,200
claim here is to take some plain text

11075
06:55:27,200 --> 06:55:30,638
like the message you want to send think

11076
06:55:29,200 --> 06:55:32,360
back to grade school if you ever passed

11077
06:55:30,638 --> 06:55:34,478
a note to a friend or to your crush

11078
06:55:32,360 --> 06:55:35,680
saying I love you it's a little awkward

11079
06:55:34,478 --> 06:55:37,360
if the teacher or someone else

11080
06:55:35,680 --> 06:55:39,360
intercepts the paper and in English it

11081
06:55:37,360 --> 06:55:40,558
just says I love you or whatever it is

11082
06:55:39,360 --> 06:55:42,920
it'd be nice if you had at least

11083
06:55:40,558 --> 06:55:44,680
encrypted it in some way but the other

11084
06:55:42,920 --> 06:55:46,359
person needs to know what algorithm you

11085
06:55:44,680 --> 06:55:48,798
used and what inputs you used to that

11086
06:55:46,360 --> 06:55:50,840
algorithm so that ultimately they can

11087
06:55:48,798 --> 06:55:53,280
decode the so-called Cipher text which

11088
06:55:50,840 --> 06:55:55,320
is the output so what go inside of the

11089
06:55:53,280 --> 06:55:57,199
box today well an algorithm as it

11090
06:55:55,320 --> 06:55:59,239
relates to cryptography is called a

11091
06:55:57,200 --> 06:56:01,398
cipher and a cipher is a fancy name for

11092
06:55:59,240 --> 06:56:04,718
an algorithm that encrypts text from

11093
06:56:01,398 --> 06:56:06,638
plain text to Cipher text the catch is

11094
06:56:04,718 --> 06:56:09,080
there needs to be not just the algorithm

11095
06:56:06,638 --> 06:56:11,200
there needs to be an input to it and so

11096
06:56:09,080 --> 06:56:12,958
for instance you might draw the picture

11097
06:56:11,200 --> 06:56:14,520
like this for the first time today and

11098
06:56:12,958 --> 06:56:16,199
we've seen this in code you can give

11099
06:56:14,520 --> 06:56:18,440
multiple inputs or arguments to

11100
06:56:16,200 --> 06:56:19,920
functions so in this black box can you

11101
06:56:18,440 --> 06:56:23,039
imagine passing in the message you want

11102
06:56:19,920 --> 06:56:25,199
to send and then some Secret so for

11103
06:56:23,040 --> 06:56:27,320
instance suppose that the simplest thing

11104
06:56:25,200 --> 06:56:29,200
I could think of as a kid was instead of

11105
06:56:27,320 --> 06:56:31,360
sending the letter A why don't I write

11106
06:56:29,200 --> 06:56:33,440
the letter b instead of the letter B why

11107
06:56:31,360 --> 06:56:35,558
don't I write the letter c so I can kind

11108
06:56:33,440 --> 06:56:38,320
of shift the English alphabet by one

11109
06:56:35,558 --> 06:56:41,040
space so a becomes b b becomes C dot dot

11110
06:56:38,320 --> 06:56:42,600
dot Z becomes a you can wrap around at

11111
06:56:41,040 --> 06:56:44,760
the end and let's assume no punctuation

11112
06:56:42,600 --> 06:56:48,280
in this part of the story so that's a

11113
06:56:44,760 --> 06:56:51,120
very simple algorithm add a value to

11114
06:56:48,280 --> 06:56:53,440
each letter and send the value as the

11115
06:56:51,120 --> 06:56:55,320
cipher text and now the teacher the

11116
06:56:53,440 --> 06:56:57,717
classmate they have to know that you use

11117
06:56:55,320 --> 06:56:59,840
not only this rotational algorithm also

11118
06:56:57,718 --> 06:57:01,520
known as a Caesar Cipher they also need

11119
06:56:59,840 --> 06:57:03,520
to know what number you use did you add

11120
06:57:01,520 --> 06:57:06,120
one to every letter two to every letter

11121
06:57:03,520 --> 06:57:08,240
25 to every letter now if they're super

11122
06:57:06,120 --> 06:57:10,280
smart and probably not the the young age

11123
06:57:08,240 --> 06:57:11,798
in this story they could also just try

11124
06:57:10,280 --> 06:57:13,360
all possibilities and that would be an

11125
06:57:11,798 --> 06:57:15,239
attack on the algorithm this is not a

11126
06:57:13,360 --> 06:57:17,398
sophisticated algorithm but it's enough

11127
06:57:15,240 --> 06:57:19,600
to send a message in class so if the two

11128
06:57:17,398 --> 06:57:23,398
inputs now are high as the plain text

11129
06:57:19,600 --> 06:57:25,039
message and one as the so-called key the

11130
06:57:23,398 --> 06:57:28,000
secret number that only you and the

11131
06:57:25,040 --> 06:57:30,478
other person know you might uh be able

11132
06:57:28,000 --> 06:57:32,600
to encrypt a message from one way to the

11133
06:57:30,478 --> 06:57:36,360
other and so in this case for instance

11134
06:57:32,600 --> 06:57:37,680
high would become i j exclamation point

11135
06:57:36,360 --> 06:57:39,040
in this version of the algorithm we're

11136
06:57:37,680 --> 06:57:40,878
not going to bother with numbers or

11137
06:57:39,040 --> 06:57:43,080
punctuation will only operate on a

11138
06:57:40,878 --> 06:57:45,320
through z be it uppercase or lowercase

11139
06:57:43,080 --> 06:57:48,320
so now if you were to receive a a slip

11140
06:57:45,320 --> 06:57:50,520
of paper in class with i j on it you

11141
06:57:48,320 --> 06:57:51,958
know you the recipient would know what

11142
06:57:50,520 --> 06:57:54,160
it is so long as you know that the

11143
06:57:51,958 --> 06:57:55,717
sender used one because you just reverse

11144
06:57:54,160 --> 06:57:57,638
the algorithm and you subtract one

11145
06:57:55,718 --> 06:57:58,958
instead the teacher you know they

11146
06:57:57,638 --> 06:58:00,160
probably don't know what this means and

11147
06:57:58,958 --> 06:58:02,359
they're not going to spend time hacking

11148
06:58:00,160 --> 06:58:03,718
the message so it just looks scrambled

11149
06:58:02,360 --> 06:58:05,760
to them and that's what we get from

11150
06:58:03,718 --> 06:58:07,398
encryption someone who intercepts it be

11151
06:58:05,760 --> 06:58:09,638
it in class or in the real world on the

11152
06:58:07,398 --> 06:58:11,840
Internet or anywhere else can't actually

11153
06:58:09,638 --> 06:58:14,039
figure out ideally what it is you have

11154
06:58:11,840 --> 06:58:15,798
sent the opposite of course is indeed

11155
06:58:14,040 --> 06:58:18,920
called decryption but the process is the

11156
06:58:15,798 --> 06:58:21,120
same we now pass in negative one and so

11157
06:58:18,920 --> 06:58:22,920
how about this why don't we end with a

11158
06:58:21,120 --> 06:58:25,878
demonstration here

11159
06:58:22,920 --> 06:58:28,478
u y JT xbt

11160
06:58:25,878 --> 06:58:31,160
dt50 there's a bit of a tell there if we

11161
06:58:28,478 --> 06:58:34,120
pass that in and do Nega -1 well how do

11162
06:58:31,160 --> 06:58:35,920
we get out the plain text originally

11163
06:58:34,120 --> 06:58:39,320
well if this is the cipher text and we

11164
06:58:35,920 --> 06:58:44,478
subtract one from each letter I think U

11165
06:58:39,320 --> 06:58:49,840
becomes t i becomes h j becomes i t

11166
06:58:44,478 --> 06:58:55,397
becomes s x becomes w b becomes a t

11167
06:58:49,840 --> 06:58:58,160
becomes s d becomes c t becomes s and

11168
06:58:55,398 --> 06:59:00,070
this was indeed cs50 have a duck on your

11169
06:58:58,160 --> 06:59:03,150
way out and some snacks in the

11170
06:59:00,070 --> 06:59:11,269
[Applause]

11171
06:59:03,150 --> 06:59:11,269
[Music]

11172
06:59:21,240 --> 06:59:25,570
lobby

11173
06:59:22,350 --> 06:59:25,570
[Music]

11174
06:59:41,860 --> 06:59:54,840
[Music]

11175
07:00:05,020 --> 07:00:08,080
[Music]

11176
07:00:14,360 --> 07:00:17,470
[Music]

11177
07:00:21,478 --> 07:00:24,120
oh

11178
07:00:24,290 --> 07:00:37,650
[Music]

11179
07:00:51,600 --> 07:00:57,039
all right all right this is cs50 and

11180
07:00:54,398 --> 07:00:58,840
this is week three already wherein we'll

11181
07:00:57,040 --> 07:01:00,958
take a look back actually at week zero

11182
07:00:58,840 --> 07:01:02,320
where we first began and in week zero

11183
07:01:00,958 --> 07:01:04,397
recall that everything was very

11184
07:01:02,320 --> 07:01:06,040
intuitive in a sense we talked not just

11185
07:01:04,398 --> 07:01:08,080
about representation of information but

11186
07:01:06,040 --> 07:01:09,520
algorithms and we talked about tearing a

11187
07:01:08,080 --> 07:01:11,718
phone book again and again and that

11188
07:01:09,520 --> 07:01:13,878
somehow got us to a better solution but

11189
07:01:11,718 --> 07:01:15,398
today we'll try to start formalizing

11190
07:01:13,878 --> 07:01:17,080
some of those ideas and capturing some

11191
07:01:15,398 --> 07:01:20,520
of those same ideas not in pseudo code

11192
07:01:17,080 --> 07:01:22,240
just yet but in uh actual code as well

11193
07:01:20,520 --> 07:01:24,398
but we'll also consider the the

11194
07:01:22,240 --> 07:01:26,280
efficiency of those algorithms like just

11195
07:01:24,398 --> 07:01:27,478
how good how welld designed our

11196
07:01:26,280 --> 07:01:28,840
algorithms actually are and if you

11197
07:01:27,478 --> 07:01:30,878
recall when we did the phone book

11198
07:01:28,840 --> 07:01:32,760
example where in I first had an

11199
07:01:30,878 --> 07:01:34,680
algorithm searching one page at a time

11200
07:01:32,760 --> 07:01:36,239
and then second when two pages at a time

11201
07:01:34,680 --> 07:01:38,600
and then third started tearing the thing

11202
07:01:36,240 --> 07:01:40,718
in half recall that we with a wave of

11203
07:01:38,600 --> 07:01:42,958
the hand kind of analyzed it as follows

11204
07:01:40,718 --> 07:01:44,638
we proposed that if the x-axis here is

11205
07:01:42,958 --> 07:01:47,000
the size of the problem like number of

11206
07:01:44,638 --> 07:01:49,039
pages in a phone book and the y- axis is

11207
07:01:47,000 --> 07:01:51,120
the time required to solve the problem

11208
07:01:49,040 --> 07:01:52,840
in seconds minutes page tears whatever

11209
07:01:51,120 --> 07:01:54,320
your unit of measuring is recall that

11210
07:01:52,840 --> 07:01:56,478
the first algorithm was this straight

11211
07:01:54,320 --> 07:01:58,558
line such that if you had n pages in the

11212
07:01:56,478 --> 07:02:00,280
phone book it might have this slope of N

11213
07:01:58,558 --> 07:02:03,398
and there's this one toone relationship

11214
07:02:00,280 --> 07:02:05,280
between pages and tears two pages at a

11215
07:02:03,398 --> 07:02:07,360
time of course was twice as fast but

11216
07:02:05,280 --> 07:02:09,397
still really the same shape the yellow

11217
07:02:07,360 --> 07:02:11,520
line here indicating that yeah it's n /

11218
07:02:09,398 --> 07:02:12,878
two maybe plus one if you have to double

11219
07:02:11,520 --> 07:02:15,360
back as we discussed but it's really

11220
07:02:12,878 --> 07:02:17,840
still fundamentally the same algorithm

11221
07:02:15,360 --> 07:02:20,200
one or two pages at a time but the third

11222
07:02:17,840 --> 07:02:22,398
algorithm recall was this one here in

11223
07:02:20,200 --> 07:02:24,680
green where we called it logarithmic in

11224
07:02:22,398 --> 07:02:27,320
terms of how fast or how slow it was and

11225
07:02:24,680 --> 07:02:28,600
indeed the implication of this algorithm

11226
07:02:27,320 --> 07:02:31,040
was that we could even double the size

11227
07:02:28,600 --> 07:02:32,680
of the phone book and no big deal one

11228
07:02:31,040 --> 07:02:34,280
additional page tear and we take yet

11229
07:02:32,680 --> 07:02:36,160
another thousand page bite out of the

11230
07:02:34,280 --> 07:02:37,920
phone book so today we'll revisit some

11231
07:02:36,160 --> 07:02:39,558
of these ideas formalize them a bit but

11232
07:02:37,920 --> 07:02:42,160
also translate some of them ultimately

11233
07:02:39,558 --> 07:02:43,958
to code and all of that now is possible

11234
07:02:42,160 --> 07:02:44,958
because we have this lower level

11235
07:02:43,958 --> 07:02:46,717
understanding perhaps of like what's

11236
07:02:44,958 --> 07:02:49,160
actually inside of your computer this of

11237
07:02:46,718 --> 07:02:50,680
course is your computer's Ram or memory

11238
07:02:49,160 --> 07:02:51,920
and recall that if we kind of start to

11239
07:02:50,680 --> 07:02:53,718
abstract this away your compter

11240
07:02:51,920 --> 07:02:55,079
computer's memory is really just a grid

11241
07:02:53,718 --> 07:02:57,280
of bites in fact we don't have to look

11242
07:02:55,080 --> 07:02:59,398
at the hardware anymore and we looked at

11243
07:02:57,280 --> 07:03:01,717
a grid of bites like this whereby each

11244
07:02:59,398 --> 07:03:04,958
of these bites could be used to store a

11245
07:03:01,718 --> 07:03:07,520
Char an INT a long or even an entire

11246
07:03:04,958 --> 07:03:09,638
string at that but let's focus perhaps

11247
07:03:07,520 --> 07:03:11,160
just on a subset of this because last

11248
07:03:09,638 --> 07:03:13,958
week of course we emphasized really

11249
07:03:11,160 --> 07:03:16,120
arrays storing things in arrays and that

11250
07:03:13,958 --> 07:03:18,239
allowed us to start storing entire

11251
07:03:16,120 --> 07:03:20,000
strings sequences of characters and even

11252
07:03:18,240 --> 07:03:22,478
arrays of integers if we want to have

11253
07:03:20,000 --> 07:03:24,638
multiple ones and not just multiple

11254
07:03:22,478 --> 07:03:26,760
variables as well but the catch is that

11255
07:03:24,638 --> 07:03:28,200
if you look inside of an array in the

11256
07:03:26,760 --> 07:03:30,397
computer's memory and for instance

11257
07:03:28,200 --> 07:03:32,360
suppose these integers here are stored

11258
07:03:30,398 --> 07:03:34,320
it's pretty easy for us humans to glance

11259
07:03:32,360 --> 07:03:36,320
at this and immediately find the number

11260
07:03:34,320 --> 07:03:37,958
50 you sort of have this bird's eye view

11261
07:03:36,320 --> 07:03:39,558
from where you're seated of everything

11262
07:03:37,958 --> 07:03:41,840
on the screen and so it's pretty obvious

11263
07:03:39,558 --> 07:03:44,000
how you get to the number 50 but in the

11264
07:03:41,840 --> 07:03:46,120
world of computers of course it turns

11265
07:03:44,000 --> 07:03:48,320
out that this is hardware and computers

11266
07:03:46,120 --> 07:03:50,320
for today's purposes can only do one

11267
07:03:48,320 --> 07:03:52,920
thing at a time they can't just take it

11268
07:03:50,320 --> 07:03:55,280
all in and find instantly some number

11269
07:03:52,920 --> 07:03:57,958
like 50 so perhaps a decent metaphor is

11270
07:03:55,280 --> 07:04:00,039
to consider the array of memory inside

11271
07:03:57,958 --> 07:04:02,359
of your computer really is a sequence of

11272
07:04:00,040 --> 07:04:05,000
of closed doors and if the computer

11273
07:04:02,360 --> 07:04:06,638
wants to find some value in an array it

11274
07:04:05,000 --> 07:04:09,080
has to do the digital equivalent of

11275
07:04:06,638 --> 07:04:11,520
opening each of these doors one at a

11276
07:04:09,080 --> 07:04:13,840
time now how can code do that well of

11277
07:04:11,520 --> 07:04:16,240
course we introduced indices or indexes

11278
07:04:13,840 --> 07:04:18,160
last week whereby we by convention call

11279
07:04:16,240 --> 07:04:20,680
the first element of an array location

11280
07:04:18,160 --> 07:04:23,320
zero the second location one the Third

11281
07:04:20,680 --> 07:04:25,280
location two and so forth so-called zero

11282
07:04:23,320 --> 07:04:26,958
indexed and this allowed us to now

11283
07:04:25,280 --> 07:04:28,397
bridge this conceptual world of like

11284
07:04:26,958 --> 07:04:30,000
what's going on in memory with actual

11285
07:04:28,398 --> 07:04:31,958
code because now we had this square

11286
07:04:30,000 --> 07:04:34,798
bracket syntax via which we could go

11287
07:04:31,958 --> 07:04:37,280
searching for something if we so choose

11288
07:04:34,798 --> 07:04:39,520
and it turns out if I now uh paint these

11289
07:04:37,280 --> 07:04:41,000
red instead of yellow it would seem that

11290
07:04:39,520 --> 07:04:43,160
we actually have a pretty good physical

11291
07:04:41,000 --> 07:04:46,120
metaphor here standing in place for what

11292
07:04:43,160 --> 07:04:47,600
would be a computer's uh array of memory

11293
07:04:46,120 --> 07:04:49,920
if for instance you're storing some

11294
07:04:47,600 --> 07:04:51,920
seven numbers like that and so today we

11295
07:04:49,920 --> 07:04:53,717
begin with a look of a specific type typ

11296
07:04:51,920 --> 07:04:55,239
of algorithm that is for searching like

11297
07:04:53,718 --> 07:04:57,398
searching is all over the place all of

11298
07:04:55,240 --> 07:04:59,080
us have probably gone to google.com or

11299
07:04:57,398 --> 07:05:01,160
some equivalent like already multiple

11300
07:04:59,080 --> 07:05:03,080
times per day and getting back answers

11301
07:05:01,160 --> 07:05:05,320
fast is what companies like Google are

11302
07:05:03,080 --> 07:05:07,160
really good at so how are they doing

11303
07:05:05,320 --> 07:05:09,680
that how are they storing information in

11304
07:05:07,160 --> 07:05:11,160
computers uh memory well let's consider

11305
07:05:09,680 --> 07:05:13,680
what this really is it's really just a

11306
07:05:11,160 --> 07:05:15,240
problem as it was back in week zero the

11307
07:05:13,680 --> 07:05:17,520
input though to the problem for now

11308
07:05:15,240 --> 07:05:18,920
might be this array of seven lockers so

11309
07:05:17,520 --> 07:05:20,398
that's the input to the problem inside

11310
07:05:18,920 --> 07:05:22,717
of which is a number and maybe for

11311
07:05:20,398 --> 07:05:25,798
Simplicity now we just want a yes no a

11312
07:05:22,718 --> 07:05:28,760
true false answer a bull that is to say

11313
07:05:25,798 --> 07:05:31,120
of whether or not some number like 50 is

11314
07:05:28,760 --> 07:05:33,440
in that array it's not quite as fancy as

11315
07:05:31,120 --> 07:05:35,000
Google that doesn't just tell you yes we

11316
07:05:33,440 --> 07:05:36,680
have search results it actually gives

11317
07:05:35,000 --> 07:05:38,600
you the search results but for now we'll

11318
07:05:36,680 --> 07:05:41,040
keep it simple and just output as part

11319
07:05:38,600 --> 07:05:42,600
of this problem yes or no true or false

11320
07:05:41,040 --> 07:05:45,200
we have found the number we're looking

11321
07:05:42,600 --> 07:05:47,519
for given an input like that array but

11322
07:05:45,200 --> 07:05:49,240
it turns out inside of this black box

11323
07:05:47,520 --> 07:05:51,798
that we keep coming back to there's all

11324
07:05:49,240 --> 07:05:53,160
sorts of possible algorithms and we talk

11325
07:05:51,798 --> 07:05:54,920
about this at a high level conceptually

11326
07:05:53,160 --> 07:05:57,200
in week zero with the phone book but

11327
07:05:54,920 --> 07:05:59,280
today let's consider it a little more

11328
07:05:57,200 --> 07:06:00,760
concretely uh by way of a game that some

11329
07:05:59,280 --> 07:06:02,798
of you might have grown up with namely

11330
07:06:00,760 --> 07:06:04,000
Monopoly and so behind these doors it

11331
07:06:02,798 --> 07:06:06,120
turns out we'll be hidden some

11332
07:06:04,000 --> 07:06:07,760
denominations of Monopoly money but for

11333
07:06:06,120 --> 07:06:12,000
this we now have two volunteers if you'd

11334
07:06:07,760 --> 07:06:16,000
like to greet the world hi I'm

11335
07:06:12,000 --> 07:06:16,958
Jackson yay hi my name is Stephanie

11336
07:06:16,000 --> 07:06:19,520
Steph and you want to say a little

11337
07:06:16,958 --> 07:06:22,280
something about yourselves years house

11338
07:06:19,520 --> 07:06:24,718
first year living in Matthews

11339
07:06:22,280 --> 07:06:26,798
nice and I'm a first year in Canada nice

11340
07:06:24,718 --> 07:06:29,680
well Welcome to our two

11341
07:06:26,798 --> 07:06:31,120
volunteers so why don't we do this would

11342
07:06:29,680 --> 07:06:32,440
one of you like to volunteer the other

11343
07:06:31,120 --> 07:06:36,079
to go

11344
07:06:32,440 --> 07:06:38,079
first all go first okay all right so

11345
07:06:36,080 --> 07:06:40,080
Stephanie's up first and behind one of

11346
07:06:38,080 --> 07:06:42,000
these doors here we've hidden the

11347
07:06:40,080 --> 07:06:44,200
Monopoly money 50 and so we'd like you

11348
07:06:42,000 --> 07:06:45,920
to find the 50 we'll tell you nothing

11349
07:06:44,200 --> 07:06:47,760
more about the lockers but we would like

11350
07:06:45,920 --> 07:06:48,679
you to execute a certain algorithm and

11351
07:06:47,760 --> 07:06:50,320
in fact I'm going to give you some

11352
07:06:48,680 --> 07:06:51,718
pseudo code for this and I'm going to

11353
07:06:50,320 --> 07:06:54,320
give you the name for it it's called

11354
07:06:51,718 --> 07:06:55,478
linear search and as the name implies

11355
07:06:54,320 --> 07:06:57,000
you're pretty much going to end up

11356
07:06:55,478 --> 07:06:58,397
walking in sort of a straight line but

11357
07:06:57,000 --> 07:07:00,360
how are you going to do this well let me

11358
07:06:58,398 --> 07:07:02,398
propose that in a moment your first step

11359
07:07:00,360 --> 07:07:04,798
will be to think kind of like a loop for

11360
07:07:02,398 --> 07:07:06,760
each door from left to right what do we

11361
07:07:04,798 --> 07:07:10,440
want you to do on each iteration well if

11362
07:07:06,760 --> 07:07:12,000
50 is behind that door then we want to

11363
07:07:10,440 --> 07:07:13,760
go ahead and have you return true and

11364
07:07:12,000 --> 07:07:16,160
sort of hold up the 50 proudly if you

11365
07:07:13,760 --> 07:07:18,039
will for the group otherwise if you get

11366
07:07:16,160 --> 07:07:19,760
through that whole Loop and you haven't

11367
07:07:18,040 --> 07:07:22,000
found the number 50 you can just throw

11368
07:07:19,760 --> 07:07:24,638
up your hands and disappointment false

11369
07:07:22,000 --> 07:07:26,878
you've not found the number 50 so to be

11370
07:07:24,638 --> 07:07:29,718
clear step one is going to be for each

11371
07:07:26,878 --> 07:07:32,000
uh door from left to right how would you

11372
07:07:29,718 --> 07:07:32,000
like to

11373
07:07:33,600 --> 07:07:40,000
begin yep oh and then yep there we go

11374
07:07:37,280 --> 07:07:43,320
yep oh and if you'd like to at least

11375
07:07:40,000 --> 07:07:47,558
tell oh good good acting here what have

11376
07:07:43,320 --> 07:07:49,440
you found instead it's not 50 but 20 oh

11377
07:07:47,558 --> 07:07:51,958
okay so step one was a fail so let's

11378
07:07:49,440 --> 07:07:53,638
move on to step two inside of the Loop

11379
07:07:51,958 --> 07:07:57,440
what are you going to do next I'm going

11380
07:07:53,638 --> 07:07:57,440
to move to the next door

11381
07:07:58,718 --> 07:08:07,840
okay almost okay almost sort of a 500

11382
07:08:03,360 --> 07:08:07,840
instead next Locker I would rather

11383
07:08:08,440 --> 07:08:11,440
take

11384
07:08:11,718 --> 07:08:18,920
no okay we're not telling the

11385
07:08:15,280 --> 07:08:20,397
audience oh okay so keep going this is

11386
07:08:18,920 --> 07:08:23,397
step three

11387
07:08:20,398 --> 07:08:23,398
now

11388
07:08:24,440 --> 07:08:27,840
oh

11389
07:08:25,170 --> 07:08:33,160
[Music]

11390
07:08:27,840 --> 07:08:33,160
man five okay few more lockers to

11391
07:08:35,478 --> 07:08:39,280
check a little sad

11392
07:08:40,958 --> 07:08:44,920
guys all right second to last

11393
07:08:45,600 --> 07:08:52,600
step this one kind of close all right

11394
07:08:50,080 --> 07:08:57,638
and finally the last clearly you've been

11395
07:08:52,600 --> 07:09:00,440
perhaps set up here let's go all right

11396
07:08:57,638 --> 07:09:00,440
so the number

11397
07:09:01,398 --> 07:09:05,840
50 and Stephanie if I may let me ask you

11398
07:09:03,920 --> 07:09:08,039
a question here so on the screen this is

11399
07:09:05,840 --> 07:09:10,440
the pseudo code you just executed

11400
07:09:08,040 --> 07:09:12,040
suppose though I had done what many of

11401
07:09:10,440 --> 07:09:13,920
us have gotten into the habit of doing

11402
07:09:12,040 --> 07:09:16,280
when you have a if condition you often

11403
07:09:13,920 --> 07:09:18,280
have an else Branch as well suppose that

11404
07:09:16,280 --> 07:09:20,840
I had done this now and I'm marking it

11405
07:09:18,280 --> 07:09:22,680
in red to be clear this is wrong but

11406
07:09:20,840 --> 07:09:25,080
what would have have been bad about this

11407
07:09:22,680 --> 07:09:28,320
code using an if and an else might you

11408
07:09:25,080 --> 07:09:28,320
say any

11409
07:09:31,600 --> 07:09:37,199
instincts

11410
07:09:33,558 --> 07:09:38,638
um then you would end up like cancelling

11411
07:09:37,200 --> 07:09:41,040
canceling the code before you found the

11412
07:09:38,638 --> 07:09:42,200
50 yeah exactly just be eternally sad

11413
07:09:41,040 --> 07:09:44,520
indeed when Stephanie had opened the

11414
07:09:42,200 --> 07:09:46,240
first Locker she had found 20 20 of

11415
07:09:44,520 --> 07:09:47,958
course is not 50 she would have decreed

11416
07:09:46,240 --> 07:09:49,680
false but of course she hadn't checked

11417
07:09:47,958 --> 07:09:51,397
all of the rest of the locker so that

11418
07:09:49,680 --> 07:09:53,478
would seem to be a key detail that would

11419
07:09:51,398 --> 07:09:55,558
this implementation of the SoDo coat we

11420
07:09:53,478 --> 07:09:57,798
actually do go through as we did and

11421
07:09:55,558 --> 07:10:00,320
only return false not even with an else

11422
07:09:57,798 --> 07:10:02,239
but just at the end of the loop such

11423
07:10:00,320 --> 07:10:04,680
that we only reach that line if we don't

11424
07:10:02,240 --> 07:10:05,680
return truer uh earlier than that well

11425
07:10:04,680 --> 07:10:06,760
let's go ahead and do this let me take

11426
07:10:05,680 --> 07:10:08,280
the mic from you if you'd like to take a

11427
07:10:06,760 --> 07:10:09,679
seat next to Jackson Jackson in just a

11428
07:10:08,280 --> 07:10:12,039
moment we'll have you come up Carter if

11429
07:10:09,680 --> 07:10:13,958
you don't mind reorganizing the uh

11430
07:10:12,040 --> 07:10:15,920
lockers for us but in the meantime let

11431
07:10:13,958 --> 07:10:17,717
me point out how we might now translate

11432
07:10:15,920 --> 07:10:19,519
that same idea to code pretty high level

11433
07:10:17,718 --> 07:10:21,558
pretty English oriented with that pseudo

11434
07:10:19,520 --> 07:10:24,240
code but really now as of last week we

11435
07:10:21,558 --> 07:10:26,320
have syntax via which Stephanie and soon

11436
07:10:24,240 --> 07:10:28,600
Jackson could treat this Locker the set

11437
07:10:26,320 --> 07:10:30,798
of lockers as really indeed an array

11438
07:10:28,600 --> 07:10:32,557
using bracket notation so we can now get

11439
07:10:30,798 --> 07:10:34,478
a little closer in our pseudo code to

11440
07:10:32,558 --> 07:10:36,520
actual code and the way a computer

11441
07:10:34,478 --> 07:10:38,760
scientist for instance would translate

11442
07:10:36,520 --> 07:10:40,398
fairly high level English pseudo code

11443
07:10:38,760 --> 07:10:42,717
like this to something that's a little

11444
07:10:40,398 --> 07:10:44,478
closer to C or any language that

11445
07:10:42,718 --> 07:10:45,958
supports arrays would be a little more

11446
07:10:44,478 --> 07:10:48,000
cryptically like this but you'll see

11447
07:10:45,958 --> 07:10:51,239
more of this syntax in the coming days

11448
07:10:48,000 --> 07:10:52,718
for I from 0 to n minus one this is

11449
07:10:51,240 --> 07:10:54,520
still pseudo code but that's kind of

11450
07:10:52,718 --> 07:10:56,120
like the english-like way of expressing

11451
07:10:54,520 --> 07:10:59,680
what we've known come to know as a for

11452
07:10:56,120 --> 07:11:01,079
Loop if 50 is behind doors bracket I so

11453
07:10:59,680 --> 07:11:03,000
I'm assuming for the sake of discussion

11454
07:11:01,080 --> 07:11:05,638
that doors now is the name of my

11455
07:11:03,000 --> 07:11:07,120
variable this array of seven doors but

11456
07:11:05,638 --> 07:11:09,200
then the rest of the logic the rest of

11457
07:11:07,120 --> 07:11:10,638
the pseudo code really is the same way

11458
07:11:09,200 --> 07:11:12,120
and so you'll find in time that

11459
07:11:10,638 --> 07:11:13,760
programmers computer scientists more

11460
07:11:12,120 --> 07:11:16,557
generally when you start expressing

11461
07:11:13,760 --> 07:11:19,000
ideas algorithms to someone else instead

11462
07:11:16,558 --> 07:11:21,000
of maybe operating at this level here

11463
07:11:19,000 --> 07:11:22,718
you now have in your vocabulary really a

11464
07:11:21,000 --> 07:11:24,520
new new syntax that you can be a little

11465
07:11:22,718 --> 07:11:26,558
more specific not getting so into the

11466
07:11:24,520 --> 07:11:28,240
weeds of writing actual C code but at

11467
07:11:26,558 --> 07:11:30,280
least now doing something that's a

11468
07:11:28,240 --> 07:11:32,240
little closer to manipulating an array

11469
07:11:30,280 --> 07:11:36,520
like this so Jackson would you like to

11470
07:11:32,240 --> 07:11:38,798
uh stand on up all right yes yes support

11471
07:11:36,520 --> 07:11:41,840
for Jackson here too

11472
07:11:38,798 --> 07:11:43,120
nice and here now I'm going to allow you

11473
07:11:41,840 --> 07:11:44,958
an assumption that Stephanie did not

11474
07:11:43,120 --> 07:11:46,600
have Stephanie clearly was really doing

11475
07:11:44,958 --> 07:11:49,120
her best searching from left to right

11476
07:11:46,600 --> 07:11:50,478
using linear searches we'll Now call it

11477
07:11:49,120 --> 07:11:52,079
but they were pretty much in random

11478
07:11:50,478 --> 07:11:53,920
order right there was a 20 over there

11479
07:11:52,080 --> 07:11:56,040
there was a one over there and then a 50

11480
07:11:53,920 --> 07:11:58,079
so we deliberately jumbled things up and

11481
07:11:56,040 --> 07:12:00,080
did not sort the numbers for her but

11482
07:11:58,080 --> 07:12:02,200
Carter kindly has just come up to give

11483
07:12:00,080 --> 07:12:04,478
you a leg up Jackson by sorting the

11484
07:12:02,200 --> 07:12:07,120
numbers in advance and we'd like you

11485
07:12:04,478 --> 07:12:08,840
this time much like in week zero to do

11486
07:12:07,120 --> 07:12:11,079
something again and again but this time

11487
07:12:08,840 --> 07:12:12,718
using what we'll Now call binary search

11488
07:12:11,080 --> 07:12:14,638
it's exactly the same algorithm

11489
07:12:12,718 --> 07:12:16,478
conceptually as we did in week zero but

11490
07:12:14,638 --> 07:12:18,638
if we translate to the context of this

11491
07:12:16,478 --> 07:12:20,280
array we might now might say something

11492
07:12:18,638 --> 07:12:22,320
like this the first step for Jackson

11493
07:12:20,280 --> 07:12:24,280
might be to ask ask the question if 50

11494
07:12:22,320 --> 07:12:25,958
is behind the middle door where

11495
07:12:24,280 --> 07:12:28,079
presumably he's done some mental math to

11496
07:12:25,958 --> 07:12:29,877
figure out what the middle is then he's

11497
07:12:28,080 --> 07:12:31,478
going to just return true and hopefully

11498
07:12:29,878 --> 07:12:34,200
we'll get lucky and 50 will be right

11499
07:12:31,478 --> 07:12:36,120
there of course there's two other

11500
07:12:34,200 --> 07:12:39,320
possibilities at least which would be

11501
07:12:36,120 --> 07:12:41,680
what 50 is with respect to these

11502
07:12:39,320 --> 07:12:44,398
doors yeah so to the left or to the

11503
07:12:41,680 --> 07:12:46,558
right alternatively so if 50 is less

11504
07:12:44,398 --> 07:12:48,440
than the middle door then presumably

11505
07:12:46,558 --> 07:12:50,200
Jackson's going to want to go left else

11506
07:12:48,440 --> 07:12:52,000
if 50 is greater than the middle door

11507
07:12:50,200 --> 07:12:54,398
he's going to want to go right much like

11508
07:12:52,000 --> 07:12:56,240
I did uh physically last week with the

11509
07:12:54,398 --> 07:12:58,360
phone book dividing and conquering left

11510
07:12:56,240 --> 07:13:00,600
to right but there's actually a a fourth

11511
07:12:58,360 --> 07:13:02,680
case let's put it on the board first

11512
07:13:00,600 --> 07:13:03,638
what else might happen here that Jackson

11513
07:13:02,680 --> 07:13:07,120
should

11514
07:13:03,638 --> 07:13:09,120
consider yeah oh it's not there it's not

11515
07:13:07,120 --> 07:13:11,160
there so let me actually go back and

11516
07:13:09,120 --> 07:13:12,718
amend my my pseudo code here and just

11517
07:13:11,160 --> 07:13:15,398
say Jackson if we don't hand you any

11518
07:13:12,718 --> 07:13:16,920
doors at all or eventually as he's

11519
07:13:15,398 --> 07:13:18,718
dividing and conquering if he's left

11520
07:13:16,920 --> 07:13:20,557
with no more doors we have to handle

11521
07:13:18,718 --> 07:13:22,398
that situation so that the def behavior

11522
07:13:20,558 --> 07:13:23,680
is defined find all right so with that

11523
07:13:22,398 --> 07:13:25,120
said Jackson do you want to go ahead and

11524
07:13:23,680 --> 07:13:26,638
find us the number 50 and walk us

11525
07:13:25,120 --> 07:13:29,718
through verbally what you're doing and

11526
07:13:26,638 --> 07:13:32,239
finding all right so it looks like this

11527
07:13:29,718 --> 07:13:33,120
one is the middle door so I'm going to

11528
07:13:32,240 --> 07:13:38,920
open

11529
07:13:33,120 --> 07:13:40,718
it but it's 20 not 50 oh sad okay what's

11530
07:13:38,920 --> 07:13:43,877
going through your head now so now I'm

11531
07:13:40,718 --> 07:13:46,520
looking because 50 is higher than 20 I

11532
07:13:43,878 --> 07:13:48,200
want to look to the right good um and

11533
07:13:46,520 --> 07:13:53,680
look for the new middle door which would

11534
07:13:48,200 --> 07:13:56,600
be here nice and it's 100 sad um but 50

11535
07:13:53,680 --> 07:14:00,878
is less than 100 so now we know to look

11536
07:13:56,600 --> 07:14:03,717
left which would be here and Tada nice

11537
07:14:00,878 --> 07:14:05,440
very well done this time around

11538
07:14:03,718 --> 07:14:08,240
too

11539
07:14:05,440 --> 07:14:10,120
so thank you first to our volunteers

11540
07:14:08,240 --> 07:14:12,040
here and in fact um since you're fan of

11541
07:14:10,120 --> 07:14:14,200
Monopoly as we're so informed we have

11542
07:14:12,040 --> 07:14:17,440
the Cambridge edition of Monopoly with

11543
07:14:14,200 --> 07:14:19,120
all your Harvard favorites here you go

11544
07:14:17,440 --> 07:14:22,877
thank you so thank you to our volunteers

11545
07:14:19,120 --> 07:14:22,878
for finding us 50

11546
07:14:23,080 --> 07:14:28,160
so kind of was more popular than we

11547
07:14:25,280 --> 07:14:29,680
expected so here we can translate this

11548
07:14:28,160 --> 07:14:32,160
one more time into something a little

11549
07:14:29,680 --> 07:14:34,280
closer to code and again still pseudo

11550
07:14:32,160 --> 07:14:36,120
code but here now might be another

11551
07:14:34,280 --> 07:14:37,717
formulation of exactly what Jackson just

11552
07:14:36,120 --> 07:14:39,079
did just using the nomenclature now of

11553
07:14:37,718 --> 07:14:40,958
arrays where you can be a little more

11554
07:14:39,080 --> 07:14:42,398
precise with your instructions and still

11555
07:14:40,958 --> 07:14:44,280
leave it to someone else to translate

11556
07:14:42,398 --> 07:14:45,600
this finally to code but here we have

11557
07:14:44,280 --> 07:14:48,798
same question at the beginning if no

11558
07:14:45,600 --> 07:14:51,440
doors left return false if 50 is behind

11559
07:14:48,798 --> 07:14:52,920
doors bracket middle so I'm assuming

11560
07:14:51,440 --> 07:14:54,520
here because this is pseudo code that

11561
07:14:52,920 --> 07:14:56,717
somewhere I've done the mental math or

11562
07:14:54,520 --> 07:14:59,558
the actual math to figure out what the

11563
07:14:56,718 --> 07:15:01,718
index of middle is for instance if these

11564
07:14:59,558 --> 07:15:07,398
are seven doors in an array this would

11565
07:15:01,718 --> 07:15:09,240
be location zero 1 2 3 4 5 6 so somehow

11566
07:15:07,398 --> 07:15:12,398
I've taken the total number of doors

11567
07:15:09,240 --> 07:15:13,878
seven divided by two to find the middle

11568
07:15:12,398 --> 07:15:15,478
that's three and a half we have to deal

11569
07:15:13,878 --> 07:15:17,398
with rounding but suffice it to say

11570
07:15:15,478 --> 07:15:19,397
there's a well- defined formula for

11571
07:15:17,398 --> 07:15:21,040
finding the middle index given the total

11572
07:15:19,398 --> 07:15:23,000
number of lockers divide by two and then

11573
07:15:21,040 --> 07:15:24,718
round accordingly so that's presumably

11574
07:15:23,000 --> 07:15:27,920
what Jackson did just by counting in his

11575
07:15:24,718 --> 07:15:30,200
head to find us door number three not

11576
07:15:27,920 --> 07:15:32,199
the third door the fourth door but door

11577
07:15:30,200 --> 07:15:34,398
bracket three so this is just saying if

11578
07:15:32,200 --> 07:15:36,000
50 is behind door is bracket middle

11579
07:15:34,398 --> 07:15:39,040
return true that was not the case he

11580
07:15:36,000 --> 07:15:42,160
found a $20 bill instead else if 50 is

11581
07:15:39,040 --> 07:15:44,760
less than the uh doors bracket middle go

11582
07:15:42,160 --> 07:15:48,920
ahead and now it gets interesting search

11583
07:15:44,760 --> 07:15:50,958
doors zero through doors middle minus

11584
07:15:48,920 --> 07:15:53,280
one so it's getting a little more to the

11585
07:15:50,958 --> 07:15:55,920
Weeds now but if middle is three this

11586
07:15:53,280 --> 07:15:58,360
one here well we want to now have

11587
07:15:55,920 --> 07:16:00,199
Jackson search if 50 had been uh if the

11588
07:15:58,360 --> 07:16:03,280
number had been less we want to start at

11589
07:16:00,200 --> 07:16:05,000
bracket zero and go up through this one

11590
07:16:03,280 --> 07:16:06,199
when we deliberately subtract one CU

11591
07:16:05,000 --> 07:16:08,080
what's the point of looking in the same

11592
07:16:06,200 --> 07:16:12,320
Locker again we might as well do zero

11593
07:16:08,080 --> 07:16:14,280
through middle minus one else if 50 is

11594
07:16:12,320 --> 07:16:16,558
greater than doors bracket middle which

11595
07:16:14,280 --> 07:16:18,798
it was what did we then do Jackson

11596
07:16:16,558 --> 07:16:21,240
intuitively searched for doors middle

11597
07:16:18,798 --> 07:16:23,000
plus one through door

11598
07:16:21,240 --> 07:16:24,478
n minus one and honestly it gets a

11599
07:16:23,000 --> 07:16:25,878
little Annoying having the pluses and

11600
07:16:24,478 --> 07:16:28,360
the minuses here but just think of what

11601
07:16:25,878 --> 07:16:30,478
it means this is the middle door and

11602
07:16:28,360 --> 07:16:33,040
Jackson then did proceed to search

11603
07:16:30,478 --> 07:16:34,440
through doors middle plus one because

11604
07:16:33,040 --> 07:16:37,280
there's no point in searching this one

11605
07:16:34,440 --> 07:16:39,877
again and then the last element in any

11606
07:16:37,280 --> 07:16:42,958
array of size n where n is just our

11607
07:16:39,878 --> 07:16:44,680
go-to number uh for the size is always

11608
07:16:42,958 --> 07:16:46,320
going to be n minus one it's not going

11609
07:16:44,680 --> 07:16:48,798
to be n it's going to be n minus one

11610
07:16:46,320 --> 07:16:50,718
because we always start counting at Rays

11611
07:16:48,798 --> 07:16:52,360
at zero so here then we have a

11612
07:16:50,718 --> 07:16:54,840
translation into pseudo code that's a

11613
07:16:52,360 --> 07:16:56,360
little closer to C of this exact same

11614
07:16:54,840 --> 07:16:58,360
idea and here we come full circle to

11615
07:16:56,360 --> 07:17:00,600
week zero like in week zero is pretty

11616
07:16:58,360 --> 07:17:02,478
intuitive to imagine dividing and

11617
07:17:00,600 --> 07:17:04,717
conquering a problem like this but if

11618
07:17:02,478 --> 07:17:06,478
you now think back to actual your iPhone

11619
07:17:04,718 --> 07:17:08,160
your Android phone or the like when

11620
07:17:06,478 --> 07:17:10,280
you're doing autocomplete and searching

11621
07:17:08,160 --> 07:17:12,360
the list it's possible if you don't have

11622
07:17:10,280 --> 07:17:14,878
many friends or family or colleagues in

11623
07:17:12,360 --> 07:17:16,920
the phone you know what linear search

11624
07:17:14,878 --> 07:17:19,080
just checking every name for the person

11625
07:17:16,920 --> 07:17:21,120
you're searching for might be perfectly

11626
07:17:19,080 --> 07:17:22,600
fine but odds are your phones being

11627
07:17:21,120 --> 07:17:24,798
smarter than that especially if you

11628
07:17:22,600 --> 07:17:26,239
start to have dozens hundreds thousands

11629
07:17:24,798 --> 07:17:27,878
of people in your contacts over the

11630
07:17:26,240 --> 07:17:30,478
years what would be better than linear

11631
07:17:27,878 --> 07:17:32,520
search well perhaps binary search but

11632
07:17:30,478 --> 07:17:34,680
but but there's an assumption a

11633
07:17:32,520 --> 07:17:37,280
requirement which is what why was

11634
07:17:34,680 --> 07:17:40,520
Jackson ultimately able to find the 50

11635
07:17:37,280 --> 07:17:42,878
in just like three steps instead of a

11636
07:17:40,520 --> 07:17:45,398
full seven like

11637
07:17:42,878 --> 07:17:47,160
Stephanie because the array was sorted

11638
07:17:45,398 --> 07:17:48,920
and so this is sort of a teaser for what

11639
07:17:47,160 --> 07:17:50,360
we'll have to come back to later today

11640
07:17:48,920 --> 07:17:52,199
well you know how much effort did it

11641
07:17:50,360 --> 07:17:54,200
take someone like Carter how much effort

11642
07:17:52,200 --> 07:17:56,120
does it take your phone to sort all of

11643
07:17:54,200 --> 07:17:57,718
those names and numbers in advance

11644
07:17:56,120 --> 07:17:59,120
because maybe it's not actually worth

11645
07:17:57,718 --> 07:18:01,040
the amount of time now someone like

11646
07:17:59,120 --> 07:18:03,397
Google probably somehow keeps the

11647
07:18:01,040 --> 07:18:05,320
database of web pages sorted you could

11648
07:18:03,398 --> 07:18:07,160
imagine it being super slow if when you

11649
07:18:05,320 --> 07:18:09,760
type in cats or something else into

11650
07:18:07,160 --> 07:18:11,920
google.com if they searched linearly

11651
07:18:09,760 --> 07:18:13,638
over their entire data set ideally

11652
07:18:11,920 --> 07:18:16,440
they're doing something a little smarter

11653
07:18:13,638 --> 07:18:18,160
than that so we'll formalize now exactly

11654
07:18:16,440 --> 07:18:20,160
this kind of analysis and it's not going

11655
07:18:18,160 --> 07:18:22,160
to be so much mathy as it still will be

11656
07:18:20,160 --> 07:18:24,558
in intuitive but we'll introduce you to

11657
07:18:22,160 --> 07:18:26,200
some some jargon some terminology that

11658
07:18:24,558 --> 07:18:28,240
most any programmer or computer

11659
07:18:26,200 --> 07:18:31,160
scientist might use when analyzing their

11660
07:18:28,240 --> 07:18:33,120
own algorithms let's formalize now what

11661
07:18:31,160 --> 07:18:35,000
this kind of analysis is so right right

11662
07:18:33,120 --> 07:18:37,200
now I claim binary search better than

11663
07:18:35,000 --> 07:18:39,120
linear search but how much better and

11664
07:18:37,200 --> 07:18:40,878
why exactly well it all comes back to

11665
07:18:39,120 --> 07:18:43,120
this kind of graph so this recall is how

11666
07:18:40,878 --> 07:18:45,920
we analyzed the phone book back in week

11667
07:18:43,120 --> 07:18:47,760
zero and recall that indeed we had these

11668
07:18:45,920 --> 07:18:49,638
these formulas rough formulas that

11669
07:18:47,760 --> 07:18:51,877
describe the running time of those three

11670
07:18:49,638 --> 07:18:53,320
algorithms one page at a time two pages

11671
07:18:51,878 --> 07:18:55,798
at a time and then tearing the thing

11672
07:18:53,320 --> 07:18:58,040
again and again in half and precisely if

11673
07:18:55,798 --> 07:18:59,717
you count it up the number of pages I

11674
07:18:58,040 --> 07:19:01,600
was touching or the number of pages I

11675
07:18:59,718 --> 07:19:03,718
was tearing it's fair to say that the

11676
07:19:01,600 --> 07:19:06,039
first algorithm in the worst case might

11677
07:19:03,718 --> 07:19:07,920
have taken n total Pages it didn't

11678
07:19:06,040 --> 07:19:09,398
because I was searching for John Harvard

11679
07:19:07,920 --> 07:19:11,039
at the time which is somewhat early in

11680
07:19:09,398 --> 07:19:12,638
the alphabet but if I were searching

11681
07:19:11,040 --> 07:19:14,718
with some for someone with the last name

11682
07:19:12,638 --> 07:19:16,638
of Z I would have had to keep going and

11683
07:19:14,718 --> 07:19:18,520
going in the worst case through all n

11684
07:19:16,638 --> 07:19:20,239
Pages not as bad for the second

11685
07:19:18,520 --> 07:19:22,000
algorithm and that's why we do n divided

11686
07:19:20,240 --> 07:19:25,920
by two and even that's a bit of a white

11687
07:19:22,000 --> 07:19:27,878
lie right it's probably n / 2 + 1 in

11688
07:19:25,920 --> 07:19:29,359
case I have to double back but again I'm

11689
07:19:27,878 --> 07:19:31,000
sort of doing this more generally to

11690
07:19:29,360 --> 07:19:32,360
capture the essence of these things and

11691
07:19:31,000 --> 07:19:34,920
then we really got into the weeds with

11692
07:19:32,360 --> 07:19:36,520
like log base 2 of n for that third and

11693
07:19:34,920 --> 07:19:38,679
final algorithm and at the time we

11694
07:19:36,520 --> 07:19:41,040
claimed anytime you're doing dividing

11695
07:19:38,680 --> 07:19:42,120
something in half in half in half odds

11696
07:19:41,040 --> 07:19:43,638
are there's going to be some kind of

11697
07:19:42,120 --> 07:19:45,600
logarithm involved and we'll see that

11698
07:19:43,638 --> 07:19:47,958
today but today we're going to actually

11699
07:19:45,600 --> 07:19:49,877
start using computer science terminology

11700
07:19:47,958 --> 07:19:52,798
and we're going to sort of formalize

11701
07:19:49,878 --> 07:19:55,558
this imprecision if you will we are not

11702
07:19:52,798 --> 07:19:57,958
going to care generally about exactly

11703
07:19:55,558 --> 07:19:59,000
how many steps some algorithm takes

11704
07:19:57,958 --> 07:20:01,239
because that's not going to be that

11705
07:19:59,000 --> 07:20:02,920
enlightening especially if maybe you

11706
07:20:01,240 --> 07:20:04,520
have a faster computer tomorrow than you

11707
07:20:02,920 --> 07:20:06,920
did today it wouldn't really be fair to

11708
07:20:04,520 --> 07:20:08,558
compare numbers too precisely we really

11709
07:20:06,920 --> 07:20:11,519
kind of want to with a wave of the hand

11710
07:20:08,558 --> 07:20:13,798
just get a sense of roughly how slow or

11711
07:20:11,520 --> 07:20:15,798
how fast an algorithm is so the notation

11712
07:20:13,798 --> 07:20:18,397
here is deliberate that is literally a

11713
07:20:15,798 --> 07:20:21,160
capital O often italicized referred to

11714
07:20:18,398 --> 07:20:24,440
as Big O and so the first algorithm is

11715
07:20:21,160 --> 07:20:27,440
in Big O of n the second algorithm is in

11716
07:20:24,440 --> 07:20:30,798
Big O of n / two the third algorithm is

11717
07:20:27,440 --> 07:20:33,920
in Big O of log base 2 of n but even

11718
07:20:30,798 --> 07:20:36,638
that is kind of unnecessary detail when

11719
07:20:33,920 --> 07:20:38,877
using Big O notation you really don't

11720
07:20:36,638 --> 07:20:40,920
care about we'll see the smaller ordered

11721
07:20:38,878 --> 07:20:42,878
terms right we're not going to care

11722
07:20:40,920 --> 07:20:45,199
about the divided by two because you

11723
07:20:42,878 --> 07:20:47,840
know what the shape of these algorithms

11724
07:20:45,200 --> 07:20:49,080
is almost the same and really the idea

11725
07:20:47,840 --> 07:20:50,478
the algorithm itself is sort of

11726
07:20:49,080 --> 07:20:52,718
fundamentally the same okay and instead

11727
07:20:50,478 --> 07:20:54,958
of one page at a time I'm doing two but

11728
07:20:52,718 --> 07:20:57,160
if you throw millions of pages billions

11729
07:20:54,958 --> 07:20:58,638
of pages at me those algorithms are

11730
07:20:57,160 --> 07:21:00,558
really going to kind of perform the same

11731
07:20:58,638 --> 07:21:01,840
as n gets really large goes off toward

11732
07:21:00,558 --> 07:21:03,760
infinity and the same is true for

11733
07:21:01,840 --> 07:21:05,240
logarithms even if you're a little rusty

11734
07:21:03,760 --> 07:21:07,840
it turns out that whether you do the

11735
07:21:05,240 --> 07:21:10,080
math with log base 2 log base 3 log base

11736
07:21:07,840 --> 07:21:11,878
10 you can just multiply one by the

11737
07:21:10,080 --> 07:21:13,958
other to really get the same formula

11738
07:21:11,878 --> 07:21:15,760
this is only to say a computer scientist

11739
07:21:13,958 --> 07:21:18,397
would generally say that the first two

11740
07:21:15,760 --> 07:21:20,840
algorithms are on the order of eps the

11741
07:21:18,398 --> 07:21:23,280
third algorithm is on the order of log

11742
07:21:20,840 --> 07:21:25,360
end steps and we don't really care

11743
07:21:23,280 --> 07:21:27,239
precisely what we mean beyond that and

11744
07:21:25,360 --> 07:21:28,798
this Big O notation as we'll see and

11745
07:21:27,240 --> 07:21:31,440
actually let me let me zoom out if you

11746
07:21:28,798 --> 07:21:33,958
can imagine suddenly making the x- axis

11747
07:21:31,440 --> 07:21:35,877
much longer so more pages on the screen

11748
07:21:33,958 --> 07:21:37,717
at once it is indeed going to be the

11749
07:21:35,878 --> 07:21:39,440
shapes of these curves that matter

11750
07:21:37,718 --> 07:21:41,760
because imagine in your mind's eye as

11751
07:21:39,440 --> 07:21:43,840
you zoom out zoom out zoom out zoom out

11752
07:21:41,760 --> 07:21:46,280
and as n gets much much much bigger on

11753
07:21:43,840 --> 07:21:48,520
the xaxis the red and the yellow line

11754
07:21:46,280 --> 07:21:50,680
are essentially going to look the same

11755
07:21:48,520 --> 07:21:53,080
once n is sufficiently large but the

11756
07:21:50,680 --> 07:21:54,558
green line is never going to look the

11757
07:21:53,080 --> 07:21:55,760
same it's going to be a fundamentally

11758
07:21:54,558 --> 07:21:58,558
different shape and so that's the

11759
07:21:55,760 --> 07:22:02,160
intuition of bigo to get a sense of

11760
07:21:58,558 --> 07:22:04,280
these uh rates of performance like this

11761
07:22:02,160 --> 07:22:06,718
so here then is Big O here is perhaps a

11762
07:22:04,280 --> 07:22:08,039
cheat sheet of like the common formulas

11763
07:22:06,718 --> 07:22:10,160
that a computer scientist certainly in

11764
07:22:08,040 --> 07:22:11,920
an introductory context might use when

11765
07:22:10,160 --> 07:22:14,398
analyzing algorithms and let's consider

11766
07:22:11,920 --> 07:22:15,958
for a moment which of our first two

11767
07:22:14,398 --> 07:22:17,958
algorithms linear search and binary

11768
07:22:15,958 --> 07:22:20,280
search fall into these categories so

11769
07:22:17,958 --> 07:22:23,760
I've ordered them from sort of slowest

11770
07:22:20,280 --> 07:22:25,199
to fastest so order of n s it's not

11771
07:22:23,760 --> 07:22:27,199
something we've actually seen yet but it

11772
07:22:25,200 --> 07:22:29,000
tends to be slow because it's quadratic

11773
07:22:27,200 --> 07:22:30,920
you're doing n * n that's got to add up

11774
07:22:29,000 --> 07:22:33,520
to a lot of steps better today is going

11775
07:22:30,920 --> 07:22:35,760
to be n Lin even better is going to be n

11776
07:22:33,520 --> 07:22:39,320
even better than that is login and best

11777
07:22:35,760 --> 07:22:41,079
is soall order of one like one step or

11778
07:22:39,320 --> 07:22:43,840
maybe two steps maybe even a thousand

11779
07:22:41,080 --> 07:22:46,318
steps but a fixed finite number of steps

11780
07:22:43,840 --> 07:22:48,638
that never changes no how matter how big

11781
07:22:46,318 --> 07:22:51,638
n is so given this chart just to be

11782
07:22:48,638 --> 07:22:54,478
clear linear search let's consider the

11783
07:22:51,638 --> 07:22:57,000
worst case in the worst case how many

11784
07:22:54,478 --> 07:22:59,798
steps did it take someone like Stephanie

11785
07:22:57,000 --> 07:23:03,160
to find the uh solution to the problem

11786
07:22:59,798 --> 07:23:05,760
assuming not seven doors but n doors

11787
07:23:03,160 --> 07:23:08,079
yeah so on the order of N and in this

11788
07:23:05,760 --> 07:23:10,359
case it's exactly n but you know what

11789
07:23:08,080 --> 07:23:11,958
you know maybe it's arguably too n right

11790
07:23:10,360 --> 07:23:13,398
because it took Stephanie a couple of

11791
07:23:11,958 --> 07:23:14,840
steps like she had to lift the latch she

11792
07:23:13,398 --> 07:23:16,638
had to open the door maybe it's three

11793
07:23:14,840 --> 07:23:19,240
steps you had to show the money so now

11794
07:23:16,638 --> 07:23:21,160
it's 3n 2 N but there we don't really

11795
07:23:19,240 --> 07:23:23,200
care about that level of precision we

11796
07:23:21,160 --> 07:23:25,440
really just care about the fundamental

11797
07:23:23,200 --> 07:23:27,760
number of operations so we'll say yes on

11798
07:23:25,440 --> 07:23:30,160
the order of n so that might be an upper

11799
07:23:27,760 --> 07:23:32,798
bound we'll call this for linear search

11800
07:23:30,160 --> 07:23:34,958
and how about binary search in Jackson's

11801
07:23:32,798 --> 07:23:37,000
case or in general me and week zero if

11802
07:23:34,958 --> 07:23:40,840
there's end doors how many steps did it

11803
07:23:37,000 --> 07:23:43,240
take Jackson or me using binary

11804
07:23:40,840 --> 07:23:45,360
search in this case it was literally

11805
07:23:43,240 --> 07:23:48,120
three but that's not a

11806
07:23:45,360 --> 07:23:50,638
formula yeah so it's on the order of log

11807
07:23:48,120 --> 07:23:52,239
n and indeed if there's seven doors well

11808
07:23:50,638 --> 07:23:53,798
that's almost eight if you just do a

11809
07:23:52,240 --> 07:23:55,958
little bit of rounding and indeed if you

11810
07:23:53,798 --> 07:23:57,958
take log base 2 of eight okay so that

11811
07:23:55,958 --> 07:23:58,958
does actually give us three so the math

11812
07:23:57,958 --> 07:24:00,520
actually checks out and if you're not

11813
07:23:58,958 --> 07:24:03,120
comy with logarithms no big deal just

11814
07:24:00,520 --> 07:24:04,878
think about it intuitively uh logarithm

11815
07:24:03,120 --> 07:24:07,397
of base two is just dividing something

11816
07:24:04,878 --> 07:24:10,318
again and again so on this chart when we

11817
07:24:07,398 --> 07:24:12,840
consider Big O which to be clear allows

11818
07:24:10,318 --> 07:24:14,239
you to describe the order of an

11819
07:24:12,840 --> 07:24:16,318
algorithm's running time like the

11820
07:24:14,240 --> 07:24:19,398
magnitude of it but it also describes

11821
07:24:16,318 --> 07:24:22,040
more specifically an upper bound so in

11822
07:24:19,398 --> 07:24:24,798
the worst case for instance these are

11823
07:24:22,040 --> 07:24:27,040
pretty good measures of how good uh or

11824
07:24:24,798 --> 07:24:29,079
rather of how bad linear search and

11825
07:24:27,040 --> 07:24:30,760
binary search might be why well suppose

11826
07:24:29,080 --> 07:24:32,798
you're searching a thousand page phone

11827
07:24:30,760 --> 07:24:34,000
book and the person's name starts with z

11828
07:24:32,798 --> 07:24:36,039
the algorithm is still going to be on

11829
07:24:34,000 --> 07:24:38,680
the order of n steps why because it

11830
07:24:36,040 --> 07:24:42,240
might take you as many as all end steps

11831
07:24:38,680 --> 07:24:44,360
to find it now that's not necessarily

11832
07:24:42,240 --> 07:24:47,160
going to be the case in practice if I

11833
07:24:44,360 --> 07:24:48,520
use Big O as an upper bound well it

11834
07:24:47,160 --> 07:24:50,600
would be nice if there's sort of a

11835
07:24:48,520 --> 07:24:52,360
corresponding lower bound especially if

11836
07:24:50,600 --> 07:24:55,760
you want to consider not just best uh

11837
07:24:52,360 --> 07:24:57,398
worst cases but maybe best cases so what

11838
07:24:55,760 --> 07:25:00,039
might we use here well so this is a

11839
07:24:57,398 --> 07:25:01,398
capital Greek omega symbol so Omega is

11840
07:25:00,040 --> 07:25:03,878
the symbol that a computer scientist

11841
07:25:01,398 --> 07:25:05,958
uses generally to describe a lower bound

11842
07:25:03,878 --> 07:25:08,000
on an algorithm often in the context of

11843
07:25:05,958 --> 07:25:10,397
best case though not necessarily so a

11844
07:25:08,000 --> 07:25:12,318
lower bound means how few steps might an

11845
07:25:10,398 --> 07:25:14,080
algorithm take and here too same

11846
07:25:12,318 --> 07:25:16,958
formulas and we'll fill in these blanks

11847
07:25:14,080 --> 07:25:19,240
over time some algorithms might always

11848
07:25:16,958 --> 07:25:21,397
take a minimum of n squ steps or on the

11849
07:25:19,240 --> 07:25:25,760
order of n steps some might only take n

11850
07:25:21,398 --> 07:25:28,798
logn or n or log n or one so something

11851
07:25:25,760 --> 07:25:30,440
like uh linear search when Stephanie

11852
07:25:28,798 --> 07:25:32,360
started with linear search she didn't

11853
07:25:30,440 --> 07:25:34,840
get lucky this time on stage but what if

11854
07:25:32,360 --> 07:25:38,000
she had and the first door she opened

11855
07:25:34,840 --> 07:25:41,440
were 50 how much you then describe the

11856
07:25:38,000 --> 07:25:43,120
lower bound on linear search in this

11857
07:25:41,440 --> 07:25:46,397
so-called best

11858
07:25:43,120 --> 07:25:50,397
case using this list of possible

11859
07:25:46,398 --> 07:25:53,240
answers yeah yeah so Omega of one so in

11860
07:25:50,398 --> 07:25:55,360
the best case the lower bound on how

11861
07:25:53,240 --> 07:25:57,360
many steps it might take uh linear

11862
07:25:55,360 --> 07:25:59,760
search to find something might just be

11863
07:25:57,360 --> 07:26:02,080
one step why because maybe Stephanie had

11864
07:25:59,760 --> 07:26:04,519
gotten lucky and we had pre-filled these

11865
07:26:02,080 --> 07:26:06,120
lockers with the numbers in some other

11866
07:26:04,520 --> 07:26:08,200
order such that she might have open the

11867
07:26:06,120 --> 07:26:09,638
first locker and waila the number 50

11868
07:26:08,200 --> 07:26:12,200
could have been there so a lower bound

11869
07:26:09,638 --> 07:26:14,397
arguably could indeed be Omega of one

11870
07:26:12,200 --> 07:26:16,760
for linear search and how about now for

11871
07:26:14,398 --> 07:26:18,840
Jackson he used binary search so he

11872
07:26:16,760 --> 07:26:21,478
dived right into the middle of the

11873
07:26:18,840 --> 07:26:25,080
problem but what would be a lower bound

11874
07:26:21,478 --> 07:26:27,040
on binary search using this logic yeah

11875
07:26:25,080 --> 07:26:29,040
yeah so again Omega of one why because

11876
07:26:27,040 --> 07:26:30,600
maybe he just gets lucky and indeed

11877
07:26:29,040 --> 07:26:33,280
right in the middle of the lockers could

11878
07:26:30,600 --> 07:26:36,120
have been the number 50 it wasn't and so

11879
07:26:33,280 --> 07:26:38,199
more Germain in Jackson's uh actual

11880
07:26:36,120 --> 07:26:41,160
practice would have been the Big O

11881
07:26:38,200 --> 07:26:42,840
discussion but Big O and Omega upper

11882
07:26:41,160 --> 07:26:44,318
bound and lower bound just allow a

11883
07:26:42,840 --> 07:26:45,600
computer scientist to kind of wrestle

11884
07:26:44,318 --> 07:26:47,079
with what could happen maybe in the

11885
07:26:45,600 --> 07:26:48,958
worst case what can happen in the best

11886
07:26:47,080 --> 07:26:50,760
case and you can even get even more

11887
07:26:48,958 --> 07:26:52,557
precise like the average case or the

11888
07:26:50,760 --> 07:26:54,280
like and this is indeed what Engineers

11889
07:26:52,558 --> 07:26:56,440
might do at a whiteboard in a company in

11890
07:26:54,280 --> 07:26:58,000
a university when designing an algorithm

11891
07:26:56,440 --> 07:26:59,920
and trying to make arguments as to like

11892
07:26:58,000 --> 07:27:02,160
why their algorithm is better than

11893
07:26:59,920 --> 07:27:04,519
someone else's by way of these kinds of

11894
07:27:02,160 --> 07:27:07,958
analyses and just so you've seen it it

11895
07:27:04,520 --> 07:27:10,878
turns out that if some algorithm happens

11896
07:27:07,958 --> 07:27:13,079
to have an identical upper bound and

11897
07:27:10,878 --> 07:27:14,958
lower bound you can actually use a

11898
07:27:13,080 --> 07:27:17,160
capital Greek Theta as well and this is

11899
07:27:14,958 --> 07:27:19,680
the last of the the Greek symbols today

11900
07:27:17,160 --> 07:27:21,680
but a Greek Theta indicates a coinci

11901
07:27:19,680 --> 07:27:24,000
idents of both upper bound and lower

11902
07:27:21,680 --> 07:27:25,318
bound that is they are one and the same

11903
07:27:24,000 --> 07:27:26,878
that was not the case for our discussion

11904
07:27:25,318 --> 07:27:29,680
a second ago of linear search not the

11905
07:27:26,878 --> 07:27:32,440
case for binary search but you could use

11906
07:27:29,680 --> 07:27:33,840
the same kinds of formulas if it turns

11907
07:27:32,440 --> 07:27:36,760
out that your upper bound and lower

11908
07:27:33,840 --> 07:27:38,398
bound are the same so for instance if I

11909
07:27:36,760 --> 07:27:42,760
were to count everyone like literally in

11910
07:27:38,398 --> 07:27:44,360
this room 1 2 3 4 five six and so forth

11911
07:27:42,760 --> 07:27:48,519
you could actually say that counting in

11912
07:27:44,360 --> 07:27:50,120
that way is in Theta of n right because

11913
07:27:48,520 --> 07:27:52,318
I in the best case it's going to take me

11914
07:27:50,120 --> 07:27:53,638
end points at the uh people in the

11915
07:27:52,318 --> 07:27:55,000
audience in the worst case it's going to

11916
07:27:53,638 --> 07:27:56,680
take me n it's always going to take me

11917
07:27:55,000 --> 07:27:58,398
end steps if I want to count everyone in

11918
07:27:56,680 --> 07:28:00,200
the room you can't really do better than

11919
07:27:58,398 --> 07:28:02,000
that unless you skip people so that

11920
07:28:00,200 --> 07:28:05,000
would be an example off the cuff of

11921
07:28:02,000 --> 07:28:09,520
something where Theta is instead germine

11922
07:28:05,000 --> 07:28:11,958
are any questions now on Big O on Omega

11923
07:28:09,520 --> 07:28:14,318
or Theta which are now just more formal

11924
07:28:11,958 --> 07:28:16,680
tools in the toolkit for talking about

11925
07:28:14,318 --> 07:28:18,600
the design of our

11926
07:28:16,680 --> 07:28:21,120
algorithms any

11927
07:28:18,600 --> 07:28:25,877
questions

11928
07:28:21,120 --> 07:28:28,120
no seeing none yeah oh is this yes no

11929
07:28:25,878 --> 07:28:30,160
okay so we're good so let's go ahead and

11930
07:28:28,120 --> 07:28:32,280
translate this perhaps to some some

11931
07:28:30,160 --> 07:28:34,718
actual code let me go over to vs code

11932
07:28:32,280 --> 07:28:36,239
here and let's see if we can't now

11933
07:28:34,718 --> 07:28:38,760
translate some of these ideas to some

11934
07:28:36,240 --> 07:28:40,478
actual code not so much using new syntax

11935
07:28:38,760 --> 07:28:42,318
yet we're going to still operate in this

11936
07:28:40,478 --> 07:28:43,878
world of arrays like last week so let me

11937
07:28:42,318 --> 07:28:46,638
go ahead and create a program called

11938
07:28:43,878 --> 07:28:48,718
search. C by executing code space

11939
07:28:46,638 --> 07:28:50,160
search. c in my terminal and then up

11940
07:28:48,718 --> 07:28:52,840
here let's go ahead and include our

11941
07:28:50,160 --> 07:28:56,000
usual so include cs50.h so I can get

11942
07:28:52,840 --> 07:28:59,160
some input include standard i.h so I can

11943
07:28:56,000 --> 07:29:00,638
print some output we'll do int main void

11944
07:28:59,160 --> 07:29:02,440
which the meaning of which we did start

11945
07:29:00,638 --> 07:29:04,239
to tease apart last week the fact that

11946
07:29:02,440 --> 07:29:06,079
it's void again today just means no

11947
07:29:04,240 --> 07:29:08,160
command line arguments and let me go

11948
07:29:06,080 --> 07:29:11,000
ahead and do this let me go ahead and

11949
07:29:08,160 --> 07:29:13,079
declare just for discussion's sake a

11950
07:29:11,000 --> 07:29:14,840
static array like an array that never

11951
07:29:13,080 --> 07:29:18,240
changes and the Syntax for this is going

11952
07:29:14,840 --> 07:29:20,360
to be give me an array called numbers

11953
07:29:18,240 --> 07:29:22,240
using the square bracket not ation and

11954
07:29:20,360 --> 07:29:26,958
I'm going to immediately initialize it

11955
07:29:22,240 --> 07:29:29,080
to 20 500 10 5 100 1 and 50 reminiscent

11956
07:29:26,958 --> 07:29:31,520
of those same denominations as before so

11957
07:29:29,080 --> 07:29:34,160
this is a slightly new syntax that we've

11958
07:29:31,520 --> 07:29:35,920
uh perhaps not seen and the curly braces

11959
07:29:34,160 --> 07:29:38,079
here which are different from for loops

11960
07:29:35,920 --> 07:29:40,717
and while loops and functions just tell

11961
07:29:38,080 --> 07:29:42,878
the compiler please give me an array of

11962
07:29:40,718 --> 07:29:44,600
whatever size this is containing those

11963
07:29:42,878 --> 07:29:47,600
numbers left to right I could

11964
07:29:44,600 --> 07:29:49,519
alternatively use last week's syntax of

11965
07:29:47,600 --> 07:29:52,318
saying something like this let's see one

11966
07:29:49,520 --> 07:29:55,000
2 3 4 5 six seven denominations I could

11967
07:29:52,318 --> 07:29:59,360
alternatively do this and then I could

11968
07:29:55,000 --> 07:30:04,398
say numbers bracket 0 uh numbers bracket

11969
07:29:59,360 --> 07:30:06,558
0 equals 20 numbers bracket 1 equal 500

11970
07:30:04,398 --> 07:30:08,120
and I could do this five more times

11971
07:30:06,558 --> 07:30:09,638
that's just a little tedious if you know

11972
07:30:08,120 --> 07:30:11,520
the numbers in advance you don't have to

11973
07:30:09,638 --> 07:30:13,200
tell the compiler how many there are you

11974
07:30:11,520 --> 07:30:17,680
can just let it figure it out that your

11975
07:30:13,200 --> 07:30:20,040
numbers are be will be 20 500 10 5 100 1

11976
07:30:17,680 --> 07:30:22,318
and 5050 so this is how you statically

11977
07:30:20,040 --> 07:30:24,080
Define an array all right let me just go

11978
07:30:22,318 --> 07:30:26,478
ahead and ask the user now for a number

11979
07:30:24,080 --> 07:30:28,200
we'll call it n by using get int and

11980
07:30:26,478 --> 07:30:30,478
prompting them for a number so nothing

11981
07:30:28,200 --> 07:30:33,280
new there and now let me go ahead and

11982
07:30:30,478 --> 07:30:34,878
Implement linear search and the pseudo

11983
07:30:33,280 --> 07:30:37,160
code we had for this before used some

11984
07:30:34,878 --> 07:30:40,840
array like notation let me go ahead then

11985
07:30:37,160 --> 07:30:42,558
and start similarly four in I and it's

11986
07:30:40,840 --> 07:30:44,440
you almost always start counting at I by

11987
07:30:42,558 --> 07:30:46,398
convention so that's perhaps a good

11988
07:30:44,440 --> 07:30:48,920
starting point I'm going to do this so

11989
07:30:46,398 --> 07:30:50,760
long as I is less than seven not the

11990
07:30:48,920 --> 07:30:52,318
best design to hard code the seven but

11991
07:30:50,760 --> 07:30:53,638
this is just for demonstration sake for

11992
07:30:52,318 --> 07:30:55,160
now because I know how many numbers I

11993
07:30:53,638 --> 07:30:57,120
put in there and then I'm going to do

11994
07:30:55,160 --> 07:30:58,958
i++ so now I have the beginnings of a

11995
07:30:57,120 --> 07:31:01,200
loop that will just allow me to iterate

11996
07:30:58,958 --> 07:31:05,600
over the entire array and let me ask

11997
07:31:01,200 --> 07:31:08,398
this if the current number at location I

11998
07:31:05,600 --> 07:31:10,717
equals equals n which is the number the

11999
07:31:08,398 --> 07:31:12,440
human typed in then let's go ahead and

12000
07:31:10,718 --> 07:31:16,160
do something simple like print F quote

12001
07:31:12,440 --> 07:31:18,039
unquote found back sln and then per our

12002
07:31:16,160 --> 07:31:19,638
discussion last week to indicate that

12003
07:31:18,040 --> 07:31:22,478
this is successful I'm going to going to

12004
07:31:19,638 --> 07:31:24,079
return zero if I found it and if I don't

12005
07:31:22,478 --> 07:31:27,760
find it I'm just going to go down here

12006
07:31:24,080 --> 07:31:29,718
and by default say not found back sln

12007
07:31:27,760 --> 07:31:32,039
and just for convention whoops just for

12008
07:31:29,718 --> 07:31:34,478
good measure per convention I'll return

12009
07:31:32,040 --> 07:31:36,878
one or really any value other than zero

12010
07:31:34,478 --> 07:31:39,520
zero recall means success and any other

12011
07:31:36,878 --> 07:31:41,000
integer tends to mean error of some sort

12012
07:31:39,520 --> 07:31:44,160
irrespective of the number I'm looking

12013
07:31:41,000 --> 07:31:45,680
for so just to revisit the only thing

12014
07:31:44,160 --> 07:31:48,079
that's new here is the syntax for

12015
07:31:45,680 --> 07:31:50,280
creating an array of seven numbers these

12016
07:31:48,080 --> 07:31:52,760
numbers and then after after that we

12017
07:31:50,280 --> 07:31:55,120
have really highlighted here an

12018
07:31:52,760 --> 07:31:56,840
implementation of linear search I mean

12019
07:31:55,120 --> 07:31:59,039
this is the C version I dare say of what

12020
07:31:56,840 --> 07:32:00,798
Stephanie did on the board whereas now

12021
07:31:59,040 --> 07:32:03,520
the array is called numbers instead of

12022
07:32:00,798 --> 07:32:05,557
doors but I think it's pretty much the

12023
07:32:03,520 --> 07:32:08,360
same let me go ahead and open my

12024
07:32:05,558 --> 07:32:11,920
terminal window and run make

12025
07:32:08,360 --> 07:32:13,080
search seems to compile okay search and

12026
07:32:11,920 --> 07:32:15,239
let's go ahead and search for a number

12027
07:32:13,080 --> 07:32:17,280
we'll start with what we did before 50

12028
07:32:15,240 --> 07:32:20,440
and it's found let's go ahead and run it

12029
07:32:17,280 --> 07:32:22,478
again/ search let's search for maybe 20

12030
07:32:20,440 --> 07:32:24,478
at the beginning that one too is found

12031
07:32:22,478 --> 07:32:28,440
let's run it one more time searching for

12032
07:32:24,478 --> 07:32:31,079
like 1,000 which is not uh in among the

12033
07:32:28,440 --> 07:32:33,079
uh denominations and that one indeed is

12034
07:32:31,080 --> 07:32:35,000
not found so we've taken an idea from

12035
07:32:33,080 --> 07:32:38,360
week zero now formalized in week three

12036
07:32:35,000 --> 07:32:40,798
and just translated it now to code

12037
07:32:38,360 --> 07:32:43,240
questions on this implementation of

12038
07:32:40,798 --> 07:32:45,520
linear

12039
07:32:43,240 --> 07:32:49,958
search linear

12040
07:32:45,520 --> 07:32:52,478
search nothing oh so successful so far

12041
07:32:49,958 --> 07:32:53,958
today okay so let's see if we can't

12042
07:32:52,478 --> 07:32:55,558
maybe make this a little more

12043
07:32:53,958 --> 07:32:57,079
interesting and see if we can't trip

12044
07:32:55,558 --> 07:33:00,120
over a detail that's going to be

12045
07:32:57,080 --> 07:33:02,478
important in C instead of doing numbers

12046
07:33:00,120 --> 07:33:04,239
let me go ahead and do this we'll stay

12047
07:33:02,478 --> 07:33:05,200
on theme with Monopoly and I went down

12048
07:33:04,240 --> 07:33:06,798
the rabbit hole of reading the

12049
07:33:05,200 --> 07:33:09,318
wikkipedia article on Monopoly and the

12050
07:33:06,798 --> 07:33:11,239
original uh pieces or tokens that came

12051
07:33:09,318 --> 07:33:12,718
with Monopoly and it turns out we can

12052
07:33:11,240 --> 07:33:14,878
represent those with strings so I'm

12053
07:33:12,718 --> 07:33:18,000
going to create an array called strings

12054
07:33:14,878 --> 07:33:20,360
plural of whatever size I defined here

12055
07:33:18,000 --> 07:33:22,840
and the very first first Monopoly pieces

12056
07:33:20,360 --> 07:33:27,040
back in the day were a battleship that

12057
07:33:22,840 --> 07:33:29,520
you could play with a boot a cannon an

12058
07:33:27,040 --> 07:33:32,240
iron a

12059
07:33:29,520 --> 07:33:33,760
thimble and a top hat some of which you

12060
07:33:32,240 --> 07:33:35,440
might know from the game nowadays turns

12061
07:33:33,760 --> 07:33:37,679
out they've been changing these uh had

12062
07:33:35,440 --> 07:33:39,638
no idea over the years so here is now an

12063
07:33:37,680 --> 07:33:42,160
array of strings let me go ahead and

12064
07:33:39,638 --> 07:33:44,600
prompt the user now not for an integer

12065
07:33:42,160 --> 07:33:46,798
anymore I want to Now search for one of

12066
07:33:44,600 --> 07:33:48,840
these strings still using linear search

12067
07:33:46,798 --> 07:33:51,557
so let me create a string s set it equal

12068
07:33:48,840 --> 07:33:54,200
to string prompt the user for a string

12069
07:33:51,558 --> 07:33:57,558
to search for and then I think my code

12070
07:33:54,200 --> 07:33:59,840
here is almost the same except for one

12071
07:33:57,558 --> 07:34:03,040
detail I now have an array called

12072
07:33:59,840 --> 07:34:05,120
strings I now have a variable called s

12073
07:34:03,040 --> 07:34:07,040
but it turns out for reasons we'll

12074
07:34:05,120 --> 07:34:10,360
explore in more detail next week this

12075
07:34:07,040 --> 07:34:13,280
line of code is not going to work and it

12076
07:34:10,360 --> 07:34:14,958
turns out the reason has to do with what

12077
07:34:13,280 --> 07:34:17,478
we discussed last week of like what a

12078
07:34:14,958 --> 07:34:20,760
string really is and what is a string

12079
07:34:17,478 --> 07:34:23,878
again a string is an array and it turns

12080
07:34:20,760 --> 07:34:26,679
out though that equals equals is not

12081
07:34:23,878 --> 07:34:29,120
going to generously compare all of the

12082
07:34:26,680 --> 07:34:31,318
characters in an array for you just

12083
07:34:29,120 --> 07:34:33,000
because you use equal equals it turns

12084
07:34:31,318 --> 07:34:37,558
out it's not going to compare every

12085
07:34:33,000 --> 07:34:39,920
letter and so thankfully there is in the

12086
07:34:37,558 --> 07:34:42,160
uh string library that we introduced

12087
07:34:39,920 --> 07:34:43,679
last week a solution to this problem the

12088
07:34:42,160 --> 07:34:45,920
reason for the problem we'll explore in

12089
07:34:43,680 --> 07:34:47,318
more detail next week but for now just

12090
07:34:45,920 --> 07:34:49,557
know that when you want to compare

12091
07:34:47,318 --> 07:34:51,478
strings in C especially if you've come

12092
07:34:49,558 --> 07:34:53,478
into the class knowing a bit of Java or

12093
07:34:51,478 --> 07:34:55,160
python or some other language you cannot

12094
07:34:53,478 --> 07:34:58,040
use equals equals even though you could

12095
07:34:55,160 --> 07:35:00,920
in scratch you cannot in C so what I

12096
07:34:58,040 --> 07:35:03,398
have to actually do here is this I have

12097
07:35:00,920 --> 07:35:05,760
to ask the question does the return

12098
07:35:03,398 --> 07:35:07,000
value of a function called stir compare

12099
07:35:05,760 --> 07:35:10,920
or stir

12100
07:35:07,000 --> 07:35:15,360
comp equal zero when passed in the

12101
07:35:10,920 --> 07:35:17,039
current string and that user input so if

12102
07:35:15,360 --> 07:35:19,478
you read the documentation for this

12103
07:35:17,040 --> 07:35:22,120
function called stir compare you'll see

12104
07:35:19,478 --> 07:35:24,718
that it takes two strings as input first

12105
07:35:22,120 --> 07:35:26,397
one and second one it then someone

12106
07:35:24,718 --> 07:35:28,000
decades ago wrote the code that probably

12107
07:35:26,398 --> 07:35:30,240
uses a four Loop or a while loop to

12108
07:35:28,000 --> 07:35:33,360
compare every character in each of those

12109
07:35:30,240 --> 07:35:36,360
strings and it turns out it returns zero

12110
07:35:33,360 --> 07:35:38,600
if they are in fact equal turns out too

12111
07:35:36,360 --> 07:35:41,638
it will return a positive number or a

12112
07:35:38,600 --> 07:35:43,840
negative number in other situations any

12113
07:35:41,638 --> 07:35:46,557
intuition for why it might actually be

12114
07:35:43,840 --> 07:35:49,718
useful to have a function that allows

12115
07:35:46,558 --> 07:35:51,280
you to check if two strings are equal

12116
07:35:49,718 --> 07:35:55,240
if they're not equal what else might be

12117
07:35:51,280 --> 07:35:55,239
interesting to know when comparing two

12118
07:35:56,318 --> 07:36:00,200
strings are if certain values

12119
07:36:01,600 --> 07:36:06,079
are okay possibly maybe you want to know

12120
07:36:03,958 --> 07:36:07,958
just how similar they are um and that's

12121
07:36:06,080 --> 07:36:11,200
indeed an algorithm unto itself but stir

12122
07:36:07,958 --> 07:36:11,199
compare is a little simpler than

12123
07:36:14,000 --> 07:36:18,080
that exactly if you're trying to like

12124
07:36:16,360 --> 07:36:19,478
alphabetize a whole list of strings just

12125
07:36:18,080 --> 07:36:21,360
like your phone probably is for your

12126
07:36:19,478 --> 07:36:23,958
context or address book it turns out

12127
07:36:21,360 --> 07:36:26,160
that stir compare will actually return a

12128
07:36:23,958 --> 07:36:28,958
positive number or a negative number or

12129
07:36:26,160 --> 07:36:31,760
a zero based on whether maybe it comes

12130
07:36:28,958 --> 07:36:33,840
alphabetically first or later or or in

12131
07:36:31,760 --> 07:36:36,000
fact equal so that can be a useful thing

12132
07:36:33,840 --> 07:36:37,360
and that's just a teaser for a lower

12133
07:36:36,000 --> 07:36:39,440
level explanation that we'll see next

12134
07:36:37,360 --> 07:36:41,200
week so now let me cross my fingers and

12135
07:36:39,440 --> 07:36:43,318
see if I got this right let me go ahead

12136
07:36:41,200 --> 07:36:47,440
and do make

12137
07:36:43,318 --> 07:36:49,160
search did compile okay albeit slowly

12138
07:36:47,440 --> 07:36:51,877
do/ search and let's search for

12139
07:36:49,160 --> 07:36:53,760
something like the thimble and we see

12140
07:36:51,878 --> 07:36:55,200
that that's indeed found otherwise let's

12141
07:36:53,760 --> 07:36:56,958
search for something that I know isn't

12142
07:36:55,200 --> 07:37:00,240
there like a race car which was there

12143
07:36:56,958 --> 07:37:02,680
when I grew up but huh segmentation

12144
07:37:00,240 --> 07:37:04,120
fault core dumped like and actually some

12145
07:37:02,680 --> 07:37:06,080
of you have tripped over this error

12146
07:37:04,120 --> 07:37:08,440
before anyone want to admit seeing this

12147
07:37:06,080 --> 07:37:10,600
so yeah not something we've talked about

12148
07:37:08,440 --> 07:37:12,760
and um honestly not something I intended

12149
07:37:10,600 --> 07:37:15,760
just now but that too we'll see next

12150
07:37:12,760 --> 07:37:17,798
week any intuition for why my program

12151
07:37:15,760 --> 07:37:20,679
just

12152
07:37:17,798 --> 07:37:23,120
broke I didn't really change the logic

12153
07:37:20,680 --> 07:37:24,600
it's still linear search let me hide the

12154
07:37:23,120 --> 07:37:26,200
terminal so you can see all of the code

12155
07:37:24,600 --> 07:37:28,840
at once the only thing I did was

12156
07:37:26,200 --> 07:37:31,718
switched from integers to Strings and I

12157
07:37:28,840 --> 07:37:33,520
switched to stir compare here but

12158
07:37:31,718 --> 07:37:35,000
segmentation fault happened and the

12159
07:37:33,520 --> 07:37:38,040
teaser is that that somehow relates to

12160
07:37:35,000 --> 07:37:38,040
the computer's memory

12161
07:37:39,600 --> 07:37:46,199
yeah yeah and this is subtle but spot on

12162
07:37:42,360 --> 07:37:49,360
so 1 2 3 4 5 six elements total in this

12163
07:37:46,200 --> 07:37:51,120
array versus the seven number

12164
07:37:49,360 --> 07:37:53,080
of Monopoly denominations that we had

12165
07:37:51,120 --> 07:37:54,798
earlier and this is where see sort of

12166
07:37:53,080 --> 07:37:57,080
case in point this came back to bite me

12167
07:37:54,798 --> 07:37:58,798
the fact that I hardcoded this value as

12168
07:37:57,080 --> 07:38:00,840
to opposed to maybe separating it out as

12169
07:37:58,798 --> 07:38:02,798
a constant or declaring it higher up

12170
07:38:00,840 --> 07:38:05,798
kind of bit me here because now I'm

12171
07:38:02,798 --> 07:38:07,920
iterating over an array of size six but

12172
07:38:05,798 --> 07:38:09,557
clearly I'm going one step too far

12173
07:38:07,920 --> 07:38:12,120
because I'm literally going to iterate

12174
07:38:09,558 --> 07:38:14,398
seven times not six so it's as though

12175
07:38:12,120 --> 07:38:16,000
I'm looking at memory that's over here

12176
07:38:14,398 --> 07:38:17,840
and indeed next week we'll focus on

12177
07:38:16,000 --> 07:38:19,478
memory and that's just a bad thing so

12178
07:38:17,840 --> 07:38:21,280
odds are not even and seeing your code

12179
07:38:19,478 --> 07:38:23,920
from this past week if any of you have

12180
07:38:21,280 --> 07:38:26,079
had segmentation faults odds are you

12181
07:38:23,920 --> 07:38:28,397
touched memory that you shouldn't have

12182
07:38:26,080 --> 07:38:30,680
you maybe looped too many times you

12183
07:38:28,398 --> 07:38:32,360
might have uh used a negative number to

12184
07:38:30,680 --> 07:38:34,200
get into your array in general you

12185
07:38:32,360 --> 07:38:35,760
touched memory that you shouldn't have

12186
07:38:34,200 --> 07:38:37,478
and you touched a segment of memory that

12187
07:38:35,760 --> 07:38:39,717
you shouldn't have the fix though at

12188
07:38:37,478 --> 07:38:41,798
least in my case is simple just don't do

12189
07:38:39,718 --> 07:38:43,718
that so let me go ahead and recompile

12190
07:38:41,798 --> 07:38:46,557
this make uh

12191
07:38:43,718 --> 07:38:49,398
search do/ search and I'll search again

12192
07:38:46,558 --> 07:38:51,160
for uh race car and

12193
07:38:49,398 --> 07:38:53,558
and now it does not crash but it does

12194
07:38:51,160 --> 07:38:54,760
tell me it's not found so subtle but

12195
07:38:53,558 --> 07:38:57,440
something you might yourself have

12196
07:38:54,760 --> 07:39:01,039
tripped over already questions then on

12197
07:38:57,440 --> 07:39:04,359
what I just did intentionally or

12198
07:39:01,040 --> 07:39:04,360
otherwise yeah in

12199
07:39:06,280 --> 07:39:11,079
front return don't return Z return so

12200
07:39:10,080 --> 07:39:13,318
what

12201
07:39:11,080 --> 07:39:15,840
the a really good question so the

12202
07:39:13,318 --> 07:39:18,318
program will still work even if I don't

12203
07:39:15,840 --> 07:39:21,280
return zero or return one in fact let me

12204
07:39:18,318 --> 07:39:23,160
go ahead head and do that and just hide

12205
07:39:21,280 --> 07:39:25,557
my terminal window for a second let's

12206
07:39:23,160 --> 07:39:28,240
get rid of the return here let's get rid

12207
07:39:25,558 --> 07:39:30,520
of the return here however Watch What

12208
07:39:28,240 --> 07:39:33,120
Happens here uh let me go ahead and

12209
07:39:30,520 --> 07:39:35,080
recompile this make search Let Me scroll

12210
07:39:33,120 --> 07:39:37,318
up in my code here let me go ahead and

12211
07:39:35,080 --> 07:39:39,160
do do/ search and let me go ahead and

12212
07:39:37,318 --> 07:39:41,120
search for the first thing in the list

12213
07:39:39,160 --> 07:39:42,638
Battleship so I know that this should be

12214
07:39:41,120 --> 07:39:45,397
found I hit

12215
07:39:42,638 --> 07:39:46,760
enter huh interesting so it's saying

12216
07:39:45,398 --> 07:39:50,558
found not found but do you see why

12217
07:39:46,760 --> 07:39:50,557
logically in this case

12218
07:39:51,958 --> 07:39:56,000
exactly so the loop is still running so

12219
07:39:54,160 --> 07:39:58,878
there's a couple of solutions to this I

12220
07:39:56,000 --> 07:40:00,840
could for instance somehow break out of

12221
07:39:58,878 --> 07:40:03,760
the code here but that's going to still

12222
07:40:00,840 --> 07:40:05,760
result in line 18 executing I could then

12223
07:40:03,760 --> 07:40:07,920
instead just return here I don't

12224
07:40:05,760 --> 07:40:09,840
strictly need to return one down at the

12225
07:40:07,920 --> 07:40:11,557
bottom but I made this claim last week

12226
07:40:09,840 --> 07:40:13,440
that it tends to be helpful as your

12227
07:40:11,558 --> 07:40:15,680
programs get more sophisticated to at

12228
07:40:13,440 --> 07:40:17,478
least signify just like a real world

12229
07:40:15,680 --> 07:40:20,200
programmer error codes when something

12230
07:40:17,478 --> 07:40:22,558
goes wrong so returning zero in main is

12231
07:40:20,200 --> 07:40:24,600
the easiest way to signify my code is

12232
07:40:22,558 --> 07:40:26,520
done I'm ready to exit successfully

12233
07:40:24,600 --> 07:40:28,160
that's it but down here I could

12234
07:40:26,520 --> 07:40:29,600
absolutely still return zero because

12235
07:40:28,160 --> 07:40:31,878
it's not a huge deal it's not really an

12236
07:40:29,600 --> 07:40:33,239
error that deserves annoying the user

12237
07:40:31,878 --> 07:40:35,318
with some kind of popup that something

12238
07:40:33,240 --> 07:40:37,600
went wrong but return one is just a

12239
07:40:35,318 --> 07:40:39,200
lower level way of signaling H it didn't

12240
07:40:37,600 --> 07:40:41,557
really find what I was looking for and

12241
07:40:39,200 --> 07:40:44,478
remember from last week you can see this

12242
07:40:41,558 --> 07:40:46,160
as follows if I recompile this again now

12243
07:40:44,478 --> 07:40:50,638
that I've reverted those changes so make

12244
07:40:46,160 --> 07:40:53,440
search and if I do uh /search and search

12245
07:40:50,638 --> 07:40:55,000
for Battleship which is indeed found

12246
07:40:53,440 --> 07:40:57,160
recall I can execute this magical

12247
07:40:55,000 --> 07:40:58,638
command Echo dollar sign question mark

12248
07:40:57,160 --> 07:41:02,240
which you're not going to often execute

12249
07:40:58,638 --> 07:41:05,200
but it shows you what main returned if I

12250
07:41:02,240 --> 07:41:08,080
run search again and search for race car

12251
07:41:05,200 --> 07:41:09,638
which is not found I see not found but I

12252
07:41:08,080 --> 07:41:12,000
can also run this command again and see

12253
07:41:09,638 --> 07:41:13,520
that oh it returned one so now if you

12254
07:41:12,000 --> 07:41:15,040
fast forward a few months a few years

12255
07:41:13,520 --> 07:41:17,200
when you're actually writing code in a

12256
07:41:15,040 --> 07:41:19,280
company or for larger projects you might

12257
07:41:17,200 --> 07:41:20,878
want to be automating software you might

12258
07:41:19,280 --> 07:41:23,600
not want the human to necessarily be

12259
07:41:20,878 --> 07:41:25,638
running it manually you might want um

12260
07:41:23,600 --> 07:41:27,680
code to be automated by some nightly

12261
07:41:25,638 --> 07:41:30,958
process or something like that using

12262
07:41:27,680 --> 07:41:33,840
these exit codes can a program determine

12263
07:41:30,958 --> 07:41:38,079
yes or no that other code succeeded or

12264
07:41:33,840 --> 07:41:39,958
failed other questions on linear search

12265
07:41:38,080 --> 07:41:42,240
in this

12266
07:41:39,958 --> 07:41:47,000
way no all right well let's translate

12267
07:41:42,240 --> 07:41:49,440
this to one other feature of uh C here

12268
07:41:47,000 --> 07:41:51,280
by incorporating these ideas now into

12269
07:41:49,440 --> 07:41:54,557
one other program so I'm going to create

12270
07:41:51,280 --> 07:41:56,798
a phone book in C by doing code space

12271
07:41:54,558 --> 07:41:56,798
phone

12272
07:41:57,798 --> 07:42:02,160
book.car a phone book for an actual name

12273
07:42:00,478 --> 07:42:03,638
and getting back a number so I'm going

12274
07:42:02,160 --> 07:42:05,878
to go ahead and quickly include some of

12275
07:42:03,638 --> 07:42:09,120
the same things cs50.h so we can get

12276
07:42:05,878 --> 07:42:10,920
input uh standard io. so we can print

12277
07:42:09,120 --> 07:42:12,878
output and I'm going to preemptively

12278
07:42:10,920 --> 07:42:16,160
include string.h in case we need that

12279
07:42:12,878 --> 07:42:18,200
one as well uh int main void no need for

12280
07:42:16,160 --> 07:42:20,600
uh command line arguments today and let

12281
07:42:18,200 --> 07:42:23,240
me me give myself now an array of names

12282
07:42:20,600 --> 07:42:25,717
for this phone book so string names

12283
07:42:23,240 --> 07:42:27,440
equals and then in curly braces how

12284
07:42:25,718 --> 07:42:29,280
about Carter will be one person in the

12285
07:42:27,440 --> 07:42:30,798
phone book and David myself will be the

12286
07:42:29,280 --> 07:42:32,360
other so we'll keep it short so we don't

12287
07:42:30,798 --> 07:42:34,798
have to type too many names but this is

12288
07:42:32,360 --> 07:42:36,878
a phone book with two people thus far

12289
07:42:34,798 --> 07:42:38,798
suppose now we want to also store

12290
07:42:36,878 --> 07:42:40,478
Carter's phone number in mind so it's

12291
07:42:38,798 --> 07:42:42,798
not just saying found or not found it's

12292
07:42:40,478 --> 07:42:45,440
literally looking up our phone numbers

12293
07:42:42,798 --> 07:42:48,120
like a proper phone book well at the

12294
07:42:45,440 --> 07:42:49,840
moment there's really no way to do this

12295
07:42:48,120 --> 07:42:52,440
I could do something hackish like I

12296
07:42:49,840 --> 07:42:55,878
could put a number like

12297
07:42:52,440 --> 07:43:00,798
617495 1000 after Carter I could maybe

12298
07:42:55,878 --> 07:43:02,360
do something like 949 uh 468 2750 after

12299
07:43:00,798 --> 07:43:04,000
me but now you're kind of doing the

12300
07:43:02,360 --> 07:43:05,878
whole apples and oranges thing right

12301
07:43:04,000 --> 07:43:08,120
like now it's not strings it's a string

12302
07:43:05,878 --> 07:43:10,558
int string int all right so maybe I

12303
07:43:08,120 --> 07:43:12,557
could just make all of these strings but

12304
07:43:10,558 --> 07:43:14,200
now it's just a conceptual mixing of

12305
07:43:12,558 --> 07:43:15,840
apples and oranges like yes that's an

12306
07:43:14,200 --> 07:43:17,440
array of four strings but now you're on

12307
07:43:15,840 --> 07:43:19,360
the honor System to know that the first

12308
07:43:17,440 --> 07:43:21,397
string is a name the second string is a

12309
07:43:19,360 --> 07:43:23,520
number the third string is like you can

12310
07:43:21,398 --> 07:43:26,360
do it but it's a bit of a hack so to

12311
07:43:23,520 --> 07:43:28,160
speak so what might be cleaner than this

12312
07:43:26,360 --> 07:43:30,160
instead of combining our phone numbers

12313
07:43:28,160 --> 07:43:33,360
into the same array as our names what

12314
07:43:30,160 --> 07:43:36,840
else might we do that's perhaps a little

12315
07:43:33,360 --> 07:43:40,398
better say a little

12316
07:43:36,840 --> 07:43:41,440
Lou a 2d array uh possibly something we

12317
07:43:40,398 --> 07:43:42,718
could do I'm going to keep it even

12318
07:43:41,440 --> 07:43:44,638
simpler now because we haven't used

12319
07:43:42,718 --> 07:43:47,120
those by name even though that is we saw

12320
07:43:44,638 --> 07:43:48,478
last week technically what argv is what

12321
07:43:47,120 --> 07:43:50,200
else could I do if I want to store names

12322
07:43:48,478 --> 07:43:51,920
and numbers

12323
07:43:50,200 --> 07:43:53,398
yeahp yeah let me go with this

12324
07:43:51,920 --> 07:43:54,958
suggestion just it's a little simpler

12325
07:43:53,398 --> 07:43:56,600
rather than complicate things in

12326
07:43:54,958 --> 07:43:59,760
literally different dimensions let me go

12327
07:43:56,600 --> 07:44:02,280
ahead and do string well I could do int

12328
07:43:59,760 --> 07:44:05,318
numbers but you know what so that we can

12329
07:44:02,280 --> 07:44:07,239
support punctuation like dashes or even

12330
07:44:05,318 --> 07:44:08,558
parentheses or country codes I'm going

12331
07:44:07,240 --> 07:44:11,280
to do this instead I'm going to do

12332
07:44:08,558 --> 07:44:13,398
string numbers so that I can represent

12333
07:44:11,280 --> 07:44:17,160
Carter's number as quote unquote plus

12334
07:44:13,398 --> 07:44:19,478
one for the US 617 495 1,000 complete

12335
07:44:17,160 --> 07:44:21,638
with hyphens as is us convention and

12336
07:44:19,478 --> 07:44:24,760
then for mine I'll go ahead and do + one

12337
07:44:21,638 --> 07:44:28,680
949 how about 468

12338
07:44:24,760 --> 07:44:30,120
275 semi colon and now down below let's

12339
07:44:28,680 --> 07:44:32,878
actually enable the user to search this

12340
07:44:30,120 --> 07:44:35,120
phone book just like in week zero we did

12341
07:44:32,878 --> 07:44:37,200
string name equals get string and let's

12342
07:44:35,120 --> 07:44:39,318
ask the user for a name presumably David

12343
07:44:37,200 --> 07:44:41,878
or Carter or someone else and now let's

12344
07:44:39,318 --> 07:44:45,398
re-implement linear search so four in I

12345
07:44:41,878 --> 07:44:47,798
gets zero I is less than two and do as I

12346
07:44:45,398 --> 07:44:49,920
say not as I do I think we should beware

12347
07:44:47,798 --> 07:44:53,798
this coding but we'll keep it simple for

12348
07:44:49,920 --> 07:44:55,359
now i++ and then in this for loop I

12349
07:44:53,798 --> 07:44:58,520
think we have all of the ingredients to

12350
07:44:55,360 --> 07:45:02,318
solve this so if the return value of

12351
07:44:58,520 --> 07:45:04,878
stir compare of all of the names bracket

12352
07:45:02,318 --> 07:45:07,638
I comparing against the name that the

12353
07:45:04,878 --> 07:45:09,680
human typed in if all of that equals

12354
07:45:07,638 --> 07:45:11,520
equals zero that is all of the

12355
07:45:09,680 --> 07:45:14,080
characters in those two strings are

12356
07:45:11,520 --> 07:45:16,000
equal then I think we can go ahead and

12357
07:45:14,080 --> 07:45:18,160
say found just like last time but you

12358
07:45:16,000 --> 07:45:20,440
know what let's actually print Carter or

12359
07:45:18,160 --> 07:45:24,280
my phone number so found percent s and

12360
07:45:20,440 --> 07:45:26,239
we'll plug in numbers bracket I and then

12361
07:45:24,280 --> 07:45:28,717
just for consistency I'll return zero

12362
07:45:26,240 --> 07:45:31,478
here and down here how about I'll say

12363
07:45:28,718 --> 07:45:34,600
something like uh print F not found just

12364
07:45:31,478 --> 07:45:36,638
to be clear and then I'll return one as

12365
07:45:34,600 --> 07:45:39,000
well so just a recap here's all of the

12366
07:45:36,638 --> 07:45:40,798
code it's almost the same as before

12367
07:45:39,000 --> 07:45:42,760
except now it's useful I'm not just

12368
07:45:40,798 --> 07:45:45,199
saying found or not found I found a

12369
07:45:42,760 --> 07:45:48,160
number in Monopoly or I found a a piece

12370
07:45:45,200 --> 07:45:49,520
in Monopoly I'm looking up in one array

12371
07:45:48,160 --> 07:45:52,000
of the strings and then I'm printing

12372
07:45:49,520 --> 07:45:56,398
from the other array the answer so let

12373
07:45:52,000 --> 07:45:58,920
me go ahead here and run the compiler

12374
07:45:56,398 --> 07:46:01,680
make phone book enter okay that's

12375
07:45:58,920 --> 07:46:04,280
promising no errors do/ phonebook now

12376
07:46:01,680 --> 07:46:06,520
and let's search for for instance Carter

12377
07:46:04,280 --> 07:46:07,798
enter all right so we found Carter's

12378
07:46:06,520 --> 07:46:10,240
number all right let me do that again

12379
07:46:07,798 --> 07:46:11,520
phone book Let's search for David all

12380
07:46:10,240 --> 07:46:12,680
right we seem to have found David's

12381
07:46:11,520 --> 07:46:14,680
number all right let's do it one last

12382
07:46:12,680 --> 07:46:17,680
time phone book enter and now we'll

12383
07:46:14,680 --> 07:46:19,040
search for like John Harvard enter not

12384
07:46:17,680 --> 07:46:21,200
found

12385
07:46:19,040 --> 07:46:23,440
all right so I dare say albeit with

12386
07:46:21,200 --> 07:46:25,478
minimal testing this code is

12387
07:46:23,440 --> 07:46:27,798
correct would anyone now like to

12388
07:46:25,478 --> 07:46:30,079
critique the design does something rub

12389
07:46:27,798 --> 07:46:32,557
you the wrong way perhaps about this

12390
07:46:30,080 --> 07:46:32,558
approach

12391
07:46:33,080 --> 07:46:37,798
here and as always think about how if

12392
07:46:36,360 --> 07:46:39,638
the program maybe gets longer more

12393
07:46:37,798 --> 07:46:42,440
complicated how decisions like this

12394
07:46:39,638 --> 07:46:45,958
might unfold

12395
07:46:42,440 --> 07:46:48,280
yeah okay so if I is less than two so

12396
07:46:45,958 --> 07:46:49,397
technically I if I change the number of

12397
07:46:48,280 --> 07:46:50,920
people in this phone book I'm going to

12398
07:46:49,398 --> 07:46:52,398
have to update I and we've already seen

12399
07:46:50,920 --> 07:46:55,039
that I get myself into trouble so that's

12400
07:46:52,398 --> 07:46:55,040
bad design

12401
07:47:02,878 --> 07:47:07,600
goodes yeah so again I'm sort of

12402
07:47:05,360 --> 07:47:09,680
trusting myself not to screw up if I add

12403
07:47:07,600 --> 07:47:11,760
John or anyone else to the first array

12404
07:47:09,680 --> 07:47:13,600
but I forget to add their number to the

12405
07:47:11,760 --> 07:47:15,440
second array you know eventually things

12406
07:47:13,600 --> 07:47:17,318
are going to drift and be inconsistent

12407
07:47:15,440 --> 07:47:18,920
and then the just code will be incorrect

12408
07:47:17,318 --> 07:47:21,600
at that point so so sort of a poor

12409
07:47:18,920 --> 07:47:25,958
design setting me up for future failure

12410
07:47:21,600 --> 07:47:25,958
if you will other thoughts

12411
07:47:31,318 --> 07:47:36,079
yeah yeah really good we're assuming the

12412
07:47:33,718 --> 07:47:38,440
same order from left to right the names

12413
07:47:36,080 --> 07:47:40,040
go and from left to right the numbers go

12414
07:47:38,440 --> 07:47:41,478
but that's kind of just the honor System

12415
07:47:40,040 --> 07:47:43,520
like there's literally nothing in code

12416
07:47:41,478 --> 07:47:45,638
preventing me from reversing the order

12417
07:47:43,520 --> 07:47:47,478
for whatever reason or maybe sorting the

12418
07:47:45,638 --> 07:47:49,397
names like they're sorted now and maybe

12419
07:47:47,478 --> 07:47:51,280
that's deliberate but maybe it's not so

12420
07:47:49,398 --> 07:47:52,958
this honor System here too is just not

12421
07:47:51,280 --> 07:47:55,478
good right I could put a comment in here

12422
07:47:52,958 --> 07:47:58,359
to remind myself to uh you know note to

12423
07:47:55,478 --> 07:47:59,718
self always update arrays the same way

12424
07:47:58,360 --> 07:48:00,920
but like that's something's going to

12425
07:47:59,718 --> 07:48:04,280
happen eventually especially when we

12426
07:48:00,920 --> 07:48:06,359
have not two but three but 30 300 names

12427
07:48:04,280 --> 07:48:08,840
and numbers it would be nice to keep all

12428
07:48:06,360 --> 07:48:10,638
of the related data together and so in

12429
07:48:08,840 --> 07:48:12,958
fact the one new feature of C we'll

12430
07:48:10,638 --> 07:48:16,039
introduce today is one that actually

12431
07:48:12,958 --> 07:48:18,600
allows us to implement our very own data

12432
07:48:16,040 --> 07:48:21,558
structures you can think of a raay as a

12433
07:48:18,600 --> 07:48:23,638
very lightweight data structure and that

12434
07:48:21,558 --> 07:48:25,478
allows you to Cluster related data back

12435
07:48:23,638 --> 07:48:27,718
to back to back to back and this is how

12436
07:48:25,478 --> 07:48:29,680
strings are implemented they are a data

12437
07:48:27,718 --> 07:48:31,958
structure effectively implemented with

12438
07:48:29,680 --> 07:48:33,840
an array but with c and with other

12439
07:48:31,958 --> 07:48:36,039
languages it turns out you can invent

12440
07:48:33,840 --> 07:48:37,600
your own data types whether they're one

12441
07:48:36,040 --> 07:48:42,360
dimensional two-dimensional even or

12442
07:48:37,600 --> 07:48:45,000
Beyond and with uh with C can you

12443
07:48:42,360 --> 07:48:47,120
specifically create your own types that

12444
07:48:45,000 --> 07:48:49,160
have their own name so for instance

12445
07:48:47,120 --> 07:48:52,760
wouldn't it have been nice if C came

12446
07:48:49,160 --> 07:48:55,798
with not just Char and int and float and

12447
07:48:52,760 --> 07:48:58,280
uh uh long and and others wouldn't it be

12448
07:48:55,798 --> 07:49:00,600
nice if C came with a data type called

12449
07:48:58,280 --> 07:49:02,318
person and ideally a person would have a

12450
07:49:00,600 --> 07:49:04,478
name and a number now that's a little

12451
07:49:02,318 --> 07:49:06,638
naive and unrealistic like why would

12452
07:49:04,478 --> 07:49:08,558
they define a person to have just those

12453
07:49:06,638 --> 07:49:10,397
two Fields certainly people could have

12454
07:49:08,558 --> 07:49:12,160
disagreed what a person is so they leave

12455
07:49:10,398 --> 07:49:14,160
it to us like the authors of C gave us

12456
07:49:12,160 --> 07:49:16,440
all of these Primitives inss and floats

12457
07:49:14,160 --> 07:49:17,878
and strings and so forth but it's up to

12458
07:49:16,440 --> 07:49:20,039
us now to use those in a more

12459
07:49:17,878 --> 07:49:23,840
interesting way so that we can create an

12460
07:49:20,040 --> 07:49:25,878
array of person variables if you will

12461
07:49:23,840 --> 07:49:28,080
inside of an array called people just to

12462
07:49:25,878 --> 07:49:29,798
pluralize it here so how are we going to

12463
07:49:28,080 --> 07:49:32,958
do this well for now let's just

12464
07:49:29,798 --> 07:49:34,717
stipulate that a person in the world

12465
07:49:32,958 --> 07:49:36,199
will have a name and a number that we

12466
07:49:34,718 --> 07:49:37,398
could argue all day long what else a

12467
07:49:36,200 --> 07:49:39,760
person should have and that's fine you

12468
07:49:37,398 --> 07:49:42,520
can invent your own person

12469
07:49:39,760 --> 07:49:44,798
eventually at the moment I'm using just

12470
07:49:42,520 --> 07:49:46,478
two variables to define a person's name

12471
07:49:44,798 --> 07:49:49,079
and number but wouldn't it be nice to

12472
07:49:46,478 --> 07:49:52,160
encapsulate that is combined these two

12473
07:49:49,080 --> 07:49:54,718
data types into a new and improved data

12474
07:49:52,160 --> 07:49:56,760
type called person and the Syntax for

12475
07:49:54,718 --> 07:49:59,200
that is going to be this so it's a bit

12476
07:49:56,760 --> 07:50:00,920
of a mouthful but you can perhaps infer

12477
07:49:59,200 --> 07:50:02,878
what some of this is doing here so it

12478
07:50:00,920 --> 07:50:04,760
turns out C has a keyword called type

12479
07:50:02,878 --> 07:50:07,440
def as the name kind of suggests this

12480
07:50:04,760 --> 07:50:09,760
allows you to Define your own type

12481
07:50:07,440 --> 07:50:12,120
struct is an indication that it's a

12482
07:50:09,760 --> 07:50:14,160
structure it's like a a structure that

12483
07:50:12,120 --> 07:50:16,200
has multiple values inside of it that

12484
07:50:14,160 --> 07:50:17,600
you are trying to Define and then at the

12485
07:50:16,200 --> 07:50:19,680
very bottom here outside of the Curve

12486
07:50:17,600 --> 07:50:22,239
early braces is the name of the type

12487
07:50:19,680 --> 07:50:24,240
that you want to create so you don't

12488
07:50:22,240 --> 07:50:25,878
have discretion over using type def or

12489
07:50:24,240 --> 07:50:27,558
struct in this particular case but you

12490
07:50:25,878 --> 07:50:30,040
can name the thing whatever you want and

12491
07:50:27,558 --> 07:50:32,160
you can put anything in the structure

12492
07:50:30,040 --> 07:50:34,600
that you want as well and as soon as

12493
07:50:32,160 --> 07:50:37,079
this semicolon is executed at the bottom

12494
07:50:34,600 --> 07:50:40,397
of the code every line thereafter can

12495
07:50:37,080 --> 07:50:43,360
now have access to a person data type

12496
07:50:40,398 --> 07:50:46,760
whether as a single variable or as an

12497
07:50:43,360 --> 07:50:49,000
entire array so if I want to build on

12498
07:50:46,760 --> 07:50:51,519
this then let me go ahead and do this

12499
07:50:49,000 --> 07:50:55,398
let me go back to my C code here and I'm

12500
07:50:51,520 --> 07:50:57,478
going to go ahead and uh change just a

12501
07:50:55,398 --> 07:50:59,478
couple of things let's go ahead and do

12502
07:50:57,478 --> 07:51:02,440
this I'm going to go ahead and first get

12503
07:50:59,478 --> 07:51:05,200
rid of those two hardcoded arrays and

12504
07:51:02,440 --> 07:51:09,280
let me go ahead and at the top of my

12505
07:51:05,200 --> 07:51:11,718
file invent this type so type def struct

12506
07:51:09,280 --> 07:51:14,120
inside of it will be a string name and

12507
07:51:11,718 --> 07:51:15,878
then a string number and then the name

12508
07:51:14,120 --> 07:51:17,760
of this structure will be person and

12509
07:51:15,878 --> 07:51:19,398
best practice would have me Define at

12510
07:51:17,760 --> 07:51:21,199
the very top of my file so that any of

12511
07:51:19,398 --> 07:51:23,638
my functions in fact could use it even

12512
07:51:21,200 --> 07:51:26,760
though I just have Main in this case now

12513
07:51:23,638 --> 07:51:30,079
if I want it I could do this like person

12514
07:51:26,760 --> 07:51:31,958
P1 and person P2 but we know from last

12515
07:51:30,080 --> 07:51:34,478
week like that already is bad design if

12516
07:51:31,958 --> 07:51:36,557
you want to have multiple instances of

12517
07:51:34,478 --> 07:51:39,280
the same type of variable we should

12518
07:51:36,558 --> 07:51:39,280
probably use what

12519
07:51:39,478 --> 07:51:44,718
instead and yeah an array so let me not

12520
07:51:43,000 --> 07:51:47,958
even go down that road let me instead

12521
07:51:44,718 --> 07:51:49,798
just do this person uh will be the type

12522
07:51:47,958 --> 07:51:51,600
of the array but I'm going to call it I

12523
07:51:49,798 --> 07:51:53,120
could call it persons but in English we

12524
07:51:51,600 --> 07:51:55,877
typically say people so I'll call the

12525
07:51:53,120 --> 07:51:57,200
array people and I want two people to

12526
07:51:55,878 --> 07:51:58,440
exist in this array though I could

12527
07:51:57,200 --> 07:52:02,160
certainly change that number to be

12528
07:51:58,440 --> 07:52:04,397
anything I want how now do you put a

12529
07:52:02,160 --> 07:52:06,160
name inside of a person and then put the

12530
07:52:04,398 --> 07:52:08,200
number inside of that same person well

12531
07:52:06,160 --> 07:52:10,240
slightly new syntax today I'm going to

12532
07:52:08,200 --> 07:52:12,718
go ahead and say this people bracket

12533
07:52:10,240 --> 07:52:14,878
zero just gives me the first person in

12534
07:52:12,718 --> 07:52:18,398
the array that's not new but if you want

12535
07:52:14,878 --> 07:52:21,040
to go inside of that person in memory

12536
07:52:18,398 --> 07:52:23,840
you use a DOT and then you just specify

12537
07:52:21,040 --> 07:52:25,680
the name of the attribute therein so if

12538
07:52:23,840 --> 07:52:27,718
I want to set the first person's name to

12539
07:52:25,680 --> 07:52:29,160
Carter I just use that so-called dot

12540
07:52:27,718 --> 07:52:31,638
notation and then if I want to set

12541
07:52:29,160 --> 07:52:33,478
Carter's number using dot notation I

12542
07:52:31,638 --> 07:52:36,557
would do this plus one

12543
07:52:33,478 --> 07:52:38,840
617495 1000 and then if I want to do the

12544
07:52:36,558 --> 07:52:40,000
same for myself I would now do people

12545
07:52:38,840 --> 07:52:42,878
bracket

12546
07:52:40,000 --> 07:52:46,200
1name equals quote unquote David and

12547
07:52:42,878 --> 07:52:48,840
then people bracket one still number

12548
07:52:46,200 --> 07:52:51,120
equals quote unquote + 1

12549
07:52:48,840 --> 07:52:54,600
949468

12550
07:52:51,120 --> 07:52:56,798
2750 and now at the bottom of my file I

12551
07:52:54,600 --> 07:53:00,280
think my logic can pretty much stay the

12552
07:52:56,798 --> 07:53:01,920
same I can still on this line here

12553
07:53:00,280 --> 07:53:04,120
prompt the user for the name of the

12554
07:53:01,920 --> 07:53:05,519
person they want to look up for now even

12555
07:53:04,120 --> 07:53:06,760
though I admit it's not the best design

12556
07:53:05,520 --> 07:53:08,200
I'm just doing this for demonstration

12557
07:53:06,760 --> 07:53:10,557
sake I'm going to leave the two there

12558
07:53:08,200 --> 07:53:12,040
because I know I have two people but

12559
07:53:10,558 --> 07:53:14,440
down here this is going to have to

12560
07:53:12,040 --> 07:53:16,798
change I don't want to compare names

12561
07:53:14,440 --> 07:53:20,039
bracket I anymore what do I want to type

12562
07:53:16,798 --> 07:53:24,798
here as the first first argument to stir

12563
07:53:20,040 --> 07:53:28,478
compare what do I want to do here

12564
07:53:24,798 --> 07:53:31,280
yeah so people i. name yeah so I want to

12565
07:53:28,478 --> 07:53:32,958
go into the people array at the I

12566
07:53:31,280 --> 07:53:34,878
location because that's what my Loop is

12567
07:53:32,958 --> 07:53:37,120
doing it's updating I again and again

12568
07:53:34,878 --> 07:53:38,600
and then look at name and that's good I

12569
07:53:37,120 --> 07:53:40,360
think now I need to change this too what

12570
07:53:38,600 --> 07:53:42,877
do I want to print if the person is

12571
07:53:40,360 --> 07:53:45,600
found someone

12572
07:53:42,878 --> 07:53:49,280
else what do I want to print here if I

12573
07:53:45,600 --> 07:53:49,280
found the person's name

12574
07:53:49,318 --> 07:53:55,798
yeah say a little

12575
07:53:52,200 --> 07:53:56,840
louder perfect so people bracket. number

12576
07:53:55,798 --> 07:53:59,318
if indeed I want to print the

12577
07:53:56,840 --> 07:54:00,878
corresponding number to this person and

12578
07:53:59,318 --> 07:54:03,680
then I think the rest of my code can

12579
07:54:00,878 --> 07:54:06,120
stay the same so let me go ahead and run

12580
07:54:03,680 --> 07:54:08,760
make phonebook to recompile this version

12581
07:54:06,120 --> 07:54:11,039
so far so good/ phonebook let's go ahead

12582
07:54:08,760 --> 07:54:12,239
and type in Carter's name found all

12583
07:54:11,040 --> 07:54:14,638
right let's go ahead and run it again

12584
07:54:12,240 --> 07:54:16,200
David's name found let's go ahead and

12585
07:54:14,638 --> 07:54:18,760
run it one more time type in John

12586
07:54:16,200 --> 07:54:22,080
Harvard for instance not found in this

12587
07:54:18,760 --> 07:54:23,478
case so fundamentally the code isn't all

12588
07:54:22,080 --> 07:54:25,920
that different linear search is still

12589
07:54:23,478 --> 07:54:27,840
behaving the same way and I admit this

12590
07:54:25,920 --> 07:54:30,239
is kind of ugly looking like we've kind

12591
07:54:27,840 --> 07:54:32,680
of made a two-line solution like five

12592
07:54:30,240 --> 07:54:34,878
lines of code now but if we fast forward

12593
07:54:32,680 --> 07:54:37,280
a week or two when we start saving

12594
07:54:34,878 --> 07:54:40,318
information to files uh we'll introduce

12595
07:54:37,280 --> 07:54:42,280
you to files like CSV value CSV files

12596
07:54:40,318 --> 07:54:43,718
comma separated values or spreadsheet

12597
07:54:42,280 --> 07:54:45,557
files which you've surely opened on your

12598
07:54:43,718 --> 07:54:46,878
Mac or PC at some point in the past

12599
07:54:45,558 --> 07:54:48,878
suffice it to say We'll soon learn

12600
07:54:46,878 --> 07:54:51,360
Techni for storing information like

12601
07:54:48,878 --> 07:54:52,840
names and numbers in files and at that

12602
07:54:51,360 --> 07:54:54,440
point we're not going to do any of this

12603
07:54:52,840 --> 07:54:56,240
hackish sort of hardcoding of the number

12604
07:54:54,440 --> 07:54:57,478
two and manually typing my name and

12605
07:54:56,240 --> 07:54:59,318
Carter's name and number into our

12606
07:54:57,478 --> 07:55:01,040
program we'll read the information

12607
07:54:59,318 --> 07:55:02,760
dynamically from a file and in a few

12608
07:55:01,040 --> 07:55:05,680
weeks we'll read it dynamically from a

12609
07:55:02,760 --> 07:55:07,717
database instead but this is for now

12610
07:55:05,680 --> 07:55:10,558
just syntactically how we can create an

12611
07:55:07,718 --> 07:55:12,840
array of size two containing one person

12612
07:55:10,558 --> 07:55:14,440
each we can update the name and number

12613
07:55:12,840 --> 07:55:15,958
of the first person update the name and

12614
07:55:14,440 --> 07:55:18,877
the number of the second person and then

12615
07:55:15,958 --> 07:55:20,638
later search across those names and

12616
07:55:18,878 --> 07:55:23,240
print out the corresponding numbers and

12617
07:55:20,638 --> 07:55:26,600
in this sense this is a better design

12618
07:55:23,240 --> 07:55:29,240
why because my person data type

12619
07:55:26,600 --> 07:55:31,359
encapsulates now everything that it

12620
07:55:29,240 --> 07:55:33,398
means to be a person at least in this

12621
07:55:31,360 --> 07:55:36,000
narrow world and if I want to add

12622
07:55:33,398 --> 07:55:37,638
something to the notion of a person for

12623
07:55:36,000 --> 07:55:40,240
instance I could go up to my typed Def

12624
07:55:37,638 --> 07:55:42,638
and tomorrow add an address to every

12625
07:55:40,240 --> 07:55:44,200
person and start reading that in as well

12626
07:55:42,638 --> 07:55:47,200
and now it's not the honor System it's

12627
07:55:44,200 --> 07:55:49,160
not a names array a numbers array and a

12628
07:55:47,200 --> 07:55:51,280
addesses array and everything else you

12629
07:55:49,160 --> 07:55:53,360
might imagine related to a person it's

12630
07:55:51,280 --> 07:55:57,199
all encapsulated which is a a term of

12631
07:55:53,360 --> 07:55:58,520
art inside of the same type reminiscent

12632
07:55:57,200 --> 07:55:59,920
if some of you have programmed before of

12633
07:55:58,520 --> 07:56:02,558
something called objectoriented

12634
07:55:59,920 --> 07:56:06,318
programming but we're not there yet C is

12635
07:56:02,558 --> 07:56:09,240
not that questions on this use of struct

12636
07:56:06,318 --> 07:56:12,878
or this new syntax the dot operator

12637
07:56:09,240 --> 07:56:16,080
being really the juicy part

12638
07:56:12,878 --> 07:56:19,080
here any questions

12639
07:56:16,080 --> 07:56:19,080
yeah

12640
07:56:21,718 --> 07:56:28,280
on what line

12641
07:56:24,120 --> 07:56:30,079
number 16 so yes so syntactically we

12642
07:56:28,280 --> 07:56:32,360
introduced the square brackets last week

12643
07:56:30,080 --> 07:56:34,280
so doing people bracket zero just means

12644
07:56:32,360 --> 07:56:36,200
go to the first person in the array that

12645
07:56:34,280 --> 07:56:38,360
was like when Stephanie literally opened

12646
07:56:36,200 --> 07:56:39,920
this door that's uh that's doors bracket

12647
07:56:38,360 --> 07:56:42,398
zero but this is of course people

12648
07:56:39,920 --> 07:56:44,920
bracket zero instead today the dot is a

12649
07:56:42,398 --> 07:56:47,558
new piece of syntax it means go inside

12650
07:56:44,920 --> 07:56:50,280
of that person in memory

12651
07:56:47,558 --> 07:56:51,760
and look at the name therein and set it

12652
07:56:50,280 --> 07:56:53,680
equal to Carter and do the same for

12653
07:56:51,760 --> 07:56:55,798
number so that's all it's like open the

12654
07:56:53,680 --> 07:56:59,558
locker door go inside of it and check or

12655
07:56:55,798 --> 07:56:59,557
set the name and the number

12656
07:57:07,200 --> 07:57:12,920
yeah attributes is fine uh good question

12657
07:57:10,478 --> 07:57:15,360
in the struct can you set default values

12658
07:57:12,920 --> 07:57:17,120
short answer no and this is where C

12659
07:57:15,360 --> 07:57:19,080
becomes less featurable than more more

12660
07:57:17,120 --> 07:57:21,318
modern languages like Python and Java

12661
07:57:19,080 --> 07:57:23,200
and others where you can in fact do that

12662
07:57:21,318 --> 07:57:24,798
so when we transition to python in a few

12663
07:57:23,200 --> 07:57:26,638
weeks time we'll see how we can start

12664
07:57:24,798 --> 07:57:28,638
solving problems like that but for now

12665
07:57:26,638 --> 07:57:32,520
it's up to you to initialize name and

12666
07:57:28,638 --> 07:57:32,520
number to something

12667
07:57:42,558 --> 07:57:46,600
yeah really good question how can we

12668
07:57:44,958 --> 07:57:47,478
adjust or critique the design of what

12669
07:57:46,600 --> 07:57:49,397
I'm doing

12670
07:57:47,478 --> 07:57:51,680
this is one of the few situations where

12671
07:57:49,398 --> 07:57:54,600
I would say hypocritically do as I say

12672
07:57:51,680 --> 07:57:56,718
not as I do I am using pretty ugly lines

12673
07:57:54,600 --> 07:57:58,920
like this just to introduce the syntax

12674
07:57:56,718 --> 07:58:00,478
but my claim pedagogically today is that

12675
07:57:58,920 --> 07:58:02,440
eventually when we start storing names

12676
07:58:00,478 --> 07:58:04,397
and numbers or other things in files or

12677
07:58:02,440 --> 07:58:06,840
in databases you won't have this

12678
07:58:04,398 --> 07:58:08,398
redundancy you'll have one line of code

12679
07:58:06,840 --> 07:58:10,638
or two lines of code that read the

12680
07:58:08,398 --> 07:58:13,160
information from the file or database

12681
07:58:10,638 --> 07:58:14,798
and then fill the entire array with that

12682
07:58:13,160 --> 07:58:16,520
data for now I'm just doing it manually

12683
07:58:14,798 --> 07:58:19,520
so is to keep our Focus only on the new

12684
07:58:16,520 --> 07:58:22,318
syntax but that's it so forgive the bad

12685
07:58:19,520 --> 07:58:23,638
Design By Design today other questions

12686
07:58:22,318 --> 07:58:26,718
on

12687
07:58:23,638 --> 07:58:27,760
this all right that's been a lot already

12688
07:58:26,718 --> 07:58:29,440
why don't we go ahead and take our

12689
07:58:27,760 --> 07:58:31,120
10-minute break with snacks first we

12690
07:58:29,440 --> 07:58:35,638
have some delightful brownies in the

12691
07:58:31,120 --> 07:58:37,397
lobby all right we are back and up until

12692
07:58:35,638 --> 07:58:39,920
now it clearly seems to be a good thing

12693
07:58:37,398 --> 07:58:42,000
if your data is sorted because you can

12694
07:58:39,920 --> 07:58:43,519
use binary search you know a little more

12695
07:58:42,000 --> 07:58:46,120
some little something more about the

12696
07:58:43,520 --> 07:58:49,600
data uh but it turns out that sorting of

12697
07:58:46,120 --> 07:58:53,280
itself is kind of a problem to solve too

12698
07:58:49,600 --> 07:58:55,239
and you might think well if sorting is

12699
07:58:53,280 --> 07:58:56,920
going to be pretty fast we absolutely

12700
07:58:55,240 --> 07:58:58,040
should do it before we start searching

12701
07:58:56,920 --> 07:59:00,280
because that'll just speed up all of our

12702
07:58:58,040 --> 07:59:02,080
searches but if sorting is slow that

12703
07:59:00,280 --> 07:59:04,199
kind of invites the question well should

12704
07:59:02,080 --> 07:59:06,200
we bother sorting our data if we're only

12705
07:59:04,200 --> 07:59:08,318
going to search the data maybe once

12706
07:59:06,200 --> 07:59:10,080
maybe twice and so here is going to be

12707
07:59:08,318 --> 07:59:11,760
potentially a trade-off so let's

12708
07:59:10,080 --> 07:59:13,160
consider what it means really to sort

12709
07:59:11,760 --> 07:59:15,840
data in our case it's just going to be

12710
07:59:13,160 --> 07:59:17,318
simple and use numbers but it might in

12711
07:59:15,840 --> 07:59:19,760
the case of the Googles of the World be

12712
07:59:17,318 --> 07:59:21,478
actual web pages or persons or the like

12713
07:59:19,760 --> 07:59:25,120
so here is our typical picture for

12714
07:59:21,478 --> 07:59:27,280
sorting input uh for solving any problem

12715
07:59:25,120 --> 07:59:30,557
input at left and output at right the

12716
07:59:27,280 --> 07:59:33,680
input to our sort problem is going to be

12717
07:59:30,558 --> 07:59:35,760
uh some unsorted set of values and the

12718
07:59:33,680 --> 07:59:37,840
output ideally will be the same set of

12719
07:59:35,760 --> 07:59:39,840
values sorted and if we do this

12720
07:59:37,840 --> 07:59:41,920
concretely let's suppose that we want to

12721
07:59:39,840 --> 07:59:45,638
go about sorting this list of numbers 7

12722
07:59:41,920 --> 07:59:47,839
2 5 4 1 6 03 so it's all of the numbers

12723
07:59:45,638 --> 07:59:49,798
from 0 to 7 but they're somehow jumbled

12724
07:59:47,840 --> 07:59:51,200
up randomly that's going to be the input

12725
07:59:49,798 --> 07:59:53,440
to the problem and the goal is now to

12726
07:59:51,200 --> 07:59:57,840
sort those so that you indeed get out 0

12727
07:59:53,440 --> 07:59:59,638
1 2 3 4 5 67 instead so it turns out

12728
07:59:57,840 --> 08:00:02,718
there's lots of different ways we can

12729
07:59:59,638 --> 08:00:04,478
actually sort numbers like these here um

12730
08:00:02,718 --> 08:00:06,920
and in fact just to complement our

12731
08:00:04,478 --> 08:00:08,878
search example earlier could we perhaps

12732
08:00:06,920 --> 08:00:10,199
quickly get some eight volunteers to

12733
08:00:08,878 --> 08:00:12,760
come up if you're comfortable appearing

12734
08:00:10,200 --> 08:00:17,160
on the internet if you want to do one

12735
08:00:12,760 --> 08:00:20,798
okay uh two three four five 6 7 eight

12736
08:00:17,160 --> 08:00:20,798
how about all right come on

12737
08:00:22,958 --> 08:00:27,877
down all

12738
08:00:25,840 --> 08:00:30,280
right come on over here and I'll give

12739
08:00:27,878 --> 08:00:32,680
you each a number and if you want to

12740
08:00:30,280 --> 08:00:35,318
start to organize yourselves in the same

12741
08:00:32,680 --> 08:00:38,760
order you see the numbers on the

12742
08:00:35,318 --> 08:00:40,520
board okay so look up on the overhead

12743
08:00:38,760 --> 08:00:42,478
and organize yourselves from left to

12744
08:00:40,520 --> 08:00:44,680
right in that same

12745
08:00:42,478 --> 08:00:46,200
order and let's have the first of you

12746
08:00:44,680 --> 08:00:47,160
perfect if you want to come uh right

12747
08:00:46,200 --> 08:00:49,360
over here

12748
08:00:47,160 --> 08:00:51,878
how about right in line with this all

12749
08:00:49,360 --> 08:00:54,680
right and a few more

12750
08:00:51,878 --> 08:00:57,040
numbers all right number

12751
08:00:54,680 --> 08:00:59,878
two six

12752
08:00:57,040 --> 08:01:02,398
and perfect just the right number all

12753
08:00:59,878 --> 08:01:04,318
right no uhoh all right there we go

12754
08:01:02,398 --> 08:01:09,638
number three all right so let's just do

12755
08:01:04,318 --> 08:01:11,079
a quick check we have 7 2 5 4 1 603 very

12756
08:01:09,638 --> 08:01:12,239
good so far do you want to just scooch a

12757
08:01:11,080 --> 08:01:14,360
little this way just to make a little

12758
08:01:12,240 --> 08:01:16,840
more of room all right and let's

12759
08:01:14,360 --> 08:01:18,520
consider now who we have here on stage

12760
08:01:16,840 --> 08:01:21,160
you want to each say a quick hello to

12761
08:01:18,520 --> 08:01:23,760
the audience hi my name is Ryan uh I'm a

12762
08:01:21,160 --> 08:01:26,200
first year from Penny

12763
08:01:23,760 --> 08:01:29,120
Packer hi my name is Cel I'm a first

12764
08:01:26,200 --> 08:01:30,520
year at Strauss um hi my name is Lucy

12765
08:01:29,120 --> 08:01:32,958
I'm a first year from

12766
08:01:30,520 --> 08:01:33,878
greo hi my name is Shiloh I'm a first

12767
08:01:32,958 --> 08:01:36,000
year in

12768
08:01:33,878 --> 08:01:38,120
Wigglesworth hi my name is Jack and I'm

12769
08:01:36,000 --> 08:01:40,398
a first year in

12770
08:01:38,120 --> 08:01:43,039
St hi my name is Katherine I'm a first

12771
08:01:40,398 --> 08:01:45,798
year in stra hi my name is Michael and

12772
08:01:43,040 --> 08:01:48,080
my first year at Penny Packer hi my name

12773
08:01:45,798 --> 08:01:51,199
is Muhammad at my first here in massuse

12774
08:01:48,080 --> 08:01:53,080
nice welcome aboard all right so let's

12775
08:01:51,200 --> 08:01:55,440
consider now how we might go about

12776
08:01:53,080 --> 08:01:58,040
sorting Our Kind volunteers here the

12777
08:01:55,440 --> 08:02:00,079
goal being to get them into order from

12778
08:01:58,040 --> 08:02:01,718
uh smallest to largest so that

12779
08:02:00,080 --> 08:02:03,200
presumably then we can use something

12780
08:02:01,718 --> 08:02:05,360
smarter than just linear search we could

12781
08:02:03,200 --> 08:02:07,558
actually use binary search assuming that

12782
08:02:05,360 --> 08:02:08,760
they are already then sorted so let me

12783
08:02:07,558 --> 08:02:10,000
propose that we first consider an

12784
08:02:08,760 --> 08:02:12,717
algorithm that actually has a name

12785
08:02:10,000 --> 08:02:15,080
called selection sort and selection sort

12786
08:02:12,718 --> 08:02:16,798
is going to be one that literally has me

12787
08:02:15,080 --> 08:02:19,120
or really you as the programmer

12788
08:02:16,798 --> 08:02:21,557
selecting the smallest element again and

12789
08:02:19,120 --> 08:02:23,360
again and then putting them into the

12790
08:02:21,558 --> 08:02:25,478
appropriate place so let me go ahead and

12791
08:02:23,360 --> 08:02:27,080
start this here uh starting with the

12792
08:02:25,478 --> 08:02:28,440
number seven at the moment seven is the

12793
08:02:27,080 --> 08:02:30,240
smallest number I found so I'm going to

12794
08:02:28,440 --> 08:02:31,920
make mental note of that with a mental

12795
08:02:30,240 --> 08:02:33,520
variable if you will I'm going to move

12796
08:02:31,920 --> 08:02:34,920
on now oh number two is obviously

12797
08:02:33,520 --> 08:02:36,600
smaller so I'm just going to update my

12798
08:02:34,920 --> 08:02:38,760
mental reminder that two is now the

12799
08:02:36,600 --> 08:02:41,638
smallest effectively forgetting for now

12800
08:02:38,760 --> 08:02:43,600
number seven uh five not smaller four

12801
08:02:41,638 --> 08:02:45,920
not smaller one smaller and I'm going to

12802
08:02:43,600 --> 08:02:47,958
make mental note of that six not smaller

12803
08:02:45,920 --> 08:02:49,600
zero smaller I'll make mental note of

12804
08:02:47,958 --> 08:02:52,039
that having forgotten now everything

12805
08:02:49,600 --> 08:02:53,760
else and now number three is not smaller

12806
08:02:52,040 --> 08:02:56,080
so what's your name again Michael so

12807
08:02:53,760 --> 08:02:57,958
Michael is number zero he belongs of

12808
08:02:56,080 --> 08:03:02,718
course way down there but unfortunately

12809
08:02:57,958 --> 08:03:04,397
you are Ryan Ryan Ryan is in the way so

12810
08:03:02,718 --> 08:03:05,558
what should we do how should we start to

12811
08:03:04,398 --> 08:03:08,558
sort this

12812
08:03:05,558 --> 08:03:12,638
list where should number zero

12813
08:03:08,558 --> 08:03:12,638
go yeah do you want to say the

12814
08:03:13,200 --> 08:03:16,958
L yeah so let's just go ahead and swap

12815
08:03:15,520 --> 08:03:19,040
so if you want to go ahead and zero go

12816
08:03:16,958 --> 08:03:20,920
on where seven is we need to make room

12817
08:03:19,040 --> 08:03:22,600
for number seven it would kind of be

12818
08:03:20,920 --> 08:03:24,920
cheating if maybe everyone kind of

12819
08:03:22,600 --> 08:03:26,120
politely stepped over to the side why

12820
08:03:24,920 --> 08:03:27,839
because if we imagine all of our

12821
08:03:26,120 --> 08:03:29,638
volunteers here to be in Array like

12822
08:03:27,840 --> 08:03:31,878
that's a crazy amount of work to have

12823
08:03:29,638 --> 08:03:33,478
every element in the array shift to the

12824
08:03:31,878 --> 08:03:35,558
left just to make room so we're going to

12825
08:03:33,478 --> 08:03:37,440
keep it simple and just evict whoever is

12826
08:03:35,558 --> 08:03:39,000
there now maybe we get lucky and number

12827
08:03:37,440 --> 08:03:41,079
seven is actually closer to its

12828
08:03:39,000 --> 08:03:42,680
destination maybe we get unlucky and it

12829
08:03:41,080 --> 08:03:45,160
goes farther away but we've at least

12830
08:03:42,680 --> 08:03:47,200
solved one problem if we had n problems

12831
08:03:45,160 --> 08:03:49,120
at first now we have n minus one because

12832
08:03:47,200 --> 08:03:51,240
number zero is indeed in the right place

12833
08:03:49,120 --> 08:03:53,520
so if I continue to act this out let me

12834
08:03:51,240 --> 08:03:56,240
go ahead and say two okay currently the

12835
08:03:53,520 --> 08:04:00,520
smallest five no four no one currently

12836
08:03:56,240 --> 08:04:02,680
the smallest I'll make mental note 6 7 3

12837
08:04:00,520 --> 08:04:05,520
and now let me pause one is obviously

12838
08:04:02,680 --> 08:04:07,798
the now smallest element so did I need

12839
08:04:05,520 --> 08:04:10,000
to keep going well it turns out at least

12840
08:04:07,798 --> 08:04:12,039
as I've defined selection sort I do need

12841
08:04:10,000 --> 08:04:13,798
to keep going because I only claim that

12842
08:04:12,040 --> 08:04:15,638
I'm using one variable in my mind to

12843
08:04:13,798 --> 08:04:17,318
remember the then smallest element I'm

12844
08:04:15,638 --> 08:04:19,397
not smart enough like us humans to

12845
08:04:17,318 --> 08:04:20,878
remember oh wait a minute one is

12846
08:04:19,398 --> 08:04:22,840
definitely the smallest now I don't have

12847
08:04:20,878 --> 08:04:24,520
that whole recollection so I just am

12848
08:04:22,840 --> 08:04:26,600
keeping track of the now smallest so

12849
08:04:24,520 --> 08:04:29,200
number one what your name was Jack Jack

12850
08:04:26,600 --> 08:04:31,318
where should jack go probably there and

12851
08:04:29,200 --> 08:04:33,240
what's your name itel itel okay so Jack

12852
08:04:31,318 --> 08:04:35,840
and itel if you want to swap places

12853
08:04:33,240 --> 08:04:37,478
we've now solved two of the end total

12854
08:04:35,840 --> 08:04:39,318
problems and now we'll do it a little

12855
08:04:37,478 --> 08:04:41,280
faster if each of you want to sort of

12856
08:04:39,318 --> 08:04:44,478
start to swap as I find the right person

12857
08:04:41,280 --> 08:04:47,120
so five smallest four is smaller two is

12858
08:04:44,478 --> 08:04:49,440
smaller got to keep checking okay two

12859
08:04:47,120 --> 08:04:51,120
was smaller all right now I'm going to

12860
08:04:49,440 --> 08:04:53,920
go back to the beginning all right four

12861
08:04:51,120 --> 08:04:55,760
is small five is not six is not seven is

12862
08:04:53,920 --> 08:04:58,717
oh three is small where do you want to

12863
08:04:55,760 --> 08:05:00,318
go okay good I'm going to go back here

12864
08:04:58,718 --> 08:05:02,000
and I can be a little smart I don't have

12865
08:05:00,318 --> 08:05:03,878
to go all the way to the end because I

12866
08:05:02,000 --> 08:05:05,920
know these folks are already sorted so I

12867
08:05:03,878 --> 08:05:08,040
can at least optimize slightly so now

12868
08:05:05,920 --> 08:05:09,717
five is small six is small seven is four

12869
08:05:08,040 --> 08:05:11,040
four is smaller if you want to go in

12870
08:05:09,718 --> 08:05:13,080
place

12871
08:05:11,040 --> 08:05:15,280
there and now here things get

12872
08:05:13,080 --> 08:05:16,600
interesting I can optimize by not

12873
08:05:15,280 --> 08:05:18,958
looking at these folks anymore more cuz

12874
08:05:16,600 --> 08:05:21,877
they're obviously problem solved but now

12875
08:05:18,958 --> 08:05:24,120
five is small six is not seven is not

12876
08:05:21,878 --> 08:05:25,600
okay five you can stay where you are now

12877
08:05:24,120 --> 08:05:27,760
a human in the room is obviously going

12878
08:05:25,600 --> 08:05:29,840
to question why I'm wasting any more

12879
08:05:27,760 --> 08:05:32,239
time but with selection sort as I've

12880
08:05:29,840 --> 08:05:35,280
defined it thus far I still have to now

12881
08:05:32,240 --> 08:05:37,360
check six is smallest not seven and now

12882
08:05:35,280 --> 08:05:39,079
my final step okay they're all in place

12883
08:05:37,360 --> 08:05:40,920
so here too is this dichotomy between

12884
08:05:39,080 --> 08:05:42,558
what we all have is this bird's eye view

12885
08:05:40,920 --> 08:05:44,199
of the whole problem where it's obvious

12886
08:05:42,558 --> 08:05:46,318
where everyone needs to go but a

12887
08:05:44,200 --> 08:05:48,120
computer implementing this with an array

12888
08:05:46,318 --> 08:05:49,760
really has to be more methodical and

12889
08:05:48,120 --> 08:05:51,557
we're actually saving a step here if we

12890
08:05:49,760 --> 08:05:53,280
were really doing this none of these

12891
08:05:51,558 --> 08:05:54,958
numbers would be visible all eight of

12892
08:05:53,280 --> 08:05:56,920
our volunteers would be inside of a

12893
08:05:54,958 --> 08:05:58,877
locked door and only then could we see

12894
08:05:56,920 --> 08:06:01,160
them one at a time but we're focusing

12895
08:05:58,878 --> 08:06:02,360
now just on the Sorting aspect so let me

12896
08:06:01,160 --> 08:06:04,600
just before we do one other

12897
08:06:02,360 --> 08:06:07,040
demonstration here proposed that what I

12898
08:06:04,600 --> 08:06:10,877
really just did here in pseudo code was

12899
08:06:07,040 --> 08:06:13,160
something like this 4 I from 0er to n

12900
08:06:10,878 --> 08:06:15,280
minus one keeping in mind that zero is

12901
08:06:13,160 --> 08:06:17,040
always the left of the array n minus one

12902
08:06:15,280 --> 08:06:19,360
is always the right end of of the array

12903
08:06:17,040 --> 08:06:21,878
for I from 0 to N minus1 I found the

12904
08:06:19,360 --> 08:06:24,718
smallest number between numbers bracket

12905
08:06:21,878 --> 08:06:26,520
I and numbers bracket n minus one and

12906
08:06:24,718 --> 08:06:28,240
that's the very geeky way of expressing

12907
08:06:26,520 --> 08:06:30,558
this optimization I'm always starting

12908
08:06:28,240 --> 08:06:32,360
from numbers bracket I wherever I am and

12909
08:06:30,558 --> 08:06:33,920
then everything else to the right and

12910
08:06:32,360 --> 08:06:36,600
that's what was allowing me to ignore

12911
08:06:33,920 --> 08:06:38,760
the already sorted volunteers if though

12912
08:06:36,600 --> 08:06:41,120
my last line says swap smallest number

12913
08:06:38,760 --> 08:06:42,679
with numbers I I think that implements

12914
08:06:41,120 --> 08:06:45,200
what our humans were doing by physically

12915
08:06:42,680 --> 08:06:46,958
walking to another spot all right so

12916
08:06:45,200 --> 08:06:49,398
that then would what we'll call

12917
08:06:46,958 --> 08:06:51,199
selection sort let's go ahead and take a

12918
08:06:49,398 --> 08:06:52,318
second approach here using an algorithm

12919
08:06:51,200 --> 08:06:53,878
that I'm going to call bubble sort but

12920
08:06:52,318 --> 08:06:55,280
to do this we need you all to reset to

12921
08:06:53,878 --> 08:06:56,520
your original locations we have a little

12922
08:06:55,280 --> 08:06:59,039
cheat sheet on the board if you'd like

12923
08:06:56,520 --> 08:07:00,280
to go back to this position here and let

12924
08:06:59,040 --> 08:07:02,000
me take a fundamentally different

12925
08:07:00,280 --> 08:07:03,638
approach because I'm not really liking

12926
08:07:02,000 --> 08:07:05,920
selection sort as is because it's kind

12927
08:07:03,638 --> 08:07:07,760
of a lot of walking back and forth and a

12928
08:07:05,920 --> 08:07:09,839
lot of walking suggests like a lot of

12929
08:07:07,760 --> 08:07:12,199
lot of steps again and again so what

12930
08:07:09,840 --> 08:07:13,680
might I do instead well bubble sort is

12931
08:07:12,200 --> 08:07:15,638
going to have me focus a little more

12932
08:07:13,680 --> 08:07:17,080
intuitively on just smaller problems and

12933
08:07:15,638 --> 08:07:19,160
let's see if this gets me somewhere else

12934
08:07:17,080 --> 08:07:21,318
so if I just look at this list without

12935
08:07:19,160 --> 08:07:23,360
looking at everyone else seven and two

12936
08:07:21,318 --> 08:07:25,239
this is obviously a problem why because

12937
08:07:23,360 --> 08:07:27,160
you're out of order so let's just solve

12938
08:07:25,240 --> 08:07:29,638
one tiny problem first so seven and two

12939
08:07:27,160 --> 08:07:31,160
why don't you swap I know two is in a

12940
08:07:29,638 --> 08:07:33,318
better place now because she's

12941
08:07:31,160 --> 08:07:35,680
definitely lower uh less than seven so I

12942
08:07:33,318 --> 08:07:37,798
think I can now move on seven and five

12943
08:07:35,680 --> 08:07:40,398
problem so let's solve that seven and

12944
08:07:37,798 --> 08:07:42,600
four problem let's solve that s and one

12945
08:07:40,398 --> 08:07:44,638
let's solve that 7 and six let's solve

12946
08:07:42,600 --> 08:07:48,280
that 7 and zero solve that 7 and three

12947
08:07:44,638 --> 08:07:49,718
solve that okay done sorted right all

12948
08:07:48,280 --> 08:07:51,280
obviously not if you just glance at

12949
08:07:49,718 --> 08:07:52,920
these numbers here but we have

12950
08:07:51,280 --> 08:07:55,520
fundamentally taken a bite out of the

12951
08:07:52,920 --> 08:07:58,280
problem seven is indeed in the right

12952
08:07:55,520 --> 08:08:02,120
place so we maximally have n minus one

12953
08:07:58,280 --> 08:08:03,878
other problems to solve so how do I do

12954
08:08:02,120 --> 08:08:06,680
this I think I can just repeat the same

12955
08:08:03,878 --> 08:08:10,280
logic let me go over here two and five

12956
08:08:06,680 --> 08:08:13,878
good five and four no five and one no

12957
08:08:10,280 --> 08:08:17,638
five and six yes 6 and zero no six and

12958
08:08:13,878 --> 08:08:18,920
three no so so now we've solved two of

12959
08:08:17,638 --> 08:08:20,557
the problems and what's nice about

12960
08:08:18,920 --> 08:08:22,359
Bubble sword at least as this glance

12961
08:08:20,558 --> 08:08:24,080
it's nice and simple it's nice and local

12962
08:08:22,360 --> 08:08:26,080
and you just keep incrementally solving

12963
08:08:24,080 --> 08:08:27,958
more and more problems so let's go ahead

12964
08:08:26,080 --> 08:08:30,360
and do this again and I'll do it we can

12965
08:08:27,958 --> 08:08:33,600
do it faster two and four we know are

12966
08:08:30,360 --> 08:08:37,440
good four and one four and five five and

12967
08:08:33,600 --> 08:08:40,798
zero five and three five and six six and

12968
08:08:37,440 --> 08:08:43,958
seven good so we go back two and one ah

12969
08:08:40,798 --> 08:08:46,600
now another problem solve two and four

12970
08:08:43,958 --> 08:08:48,798
four and zero four and three

12971
08:08:46,600 --> 08:08:51,239
four and five five and six six and seven

12972
08:08:48,798 --> 08:08:53,280
and so notice too as per its name the

12973
08:08:51,240 --> 08:08:54,840
largest elements have bubbled their way

12974
08:08:53,280 --> 08:08:56,520
up to the top and that's what seems to

12975
08:08:54,840 --> 08:08:58,240
be happening just as we're fixing some

12976
08:08:56,520 --> 08:09:01,760
remaining problems so almost done one

12977
08:08:58,240 --> 08:09:04,398
and two two and zero two and three three

12978
08:09:01,760 --> 08:09:07,239
and four four and five five and six six

12979
08:09:04,398 --> 08:09:09,958
and seven almost done obviously to us

12980
08:09:07,240 --> 08:09:12,000
humans it looks done how do I know as

12981
08:09:09,958 --> 08:09:14,039
the computer for sure what would be the

12982
08:09:12,000 --> 08:09:17,000
most Surefire way for me to now oh it's

12983
08:09:14,040 --> 08:09:19,798
not done sorry uh that's a bug

12984
08:09:17,000 --> 08:09:21,200
okay one and zero okay one and two two

12985
08:09:19,798 --> 08:09:22,680
and three three and four three four and

12986
08:09:21,200 --> 08:09:25,360
five five and six six and seven okay so

12987
08:09:22,680 --> 08:09:28,360
now it's obviously sorted to the rest of

12988
08:09:25,360 --> 08:09:29,840
us on stage how could I confirm as much

12989
08:09:28,360 --> 08:09:31,958
as code right you're doing it with your

12990
08:09:29,840 --> 08:09:33,638
mind just glancing at this how would the

12991
08:09:31,958 --> 08:09:36,239
computer the code know for sure that

12992
08:09:33,638 --> 08:09:39,557
this list is now sorted

12993
08:09:36,240 --> 08:09:42,040
yeah let's do one more time and look uh

12994
08:09:39,558 --> 08:09:42,040
draw what

12995
08:09:43,558 --> 08:09:47,878
conclusion yeah let's do it one more

12996
08:09:45,558 --> 08:09:50,040
time even though it's a little wasteful

12997
08:09:47,878 --> 08:09:52,360
but logically if I go through the whole

12998
08:09:50,040 --> 08:09:54,798
list comparing pairs again again and

12999
08:09:52,360 --> 08:09:56,558
again and I don't do any work that time

13000
08:09:54,798 --> 08:09:58,360
now it's obviously logically safe to

13001
08:09:56,558 --> 08:09:59,920
just stop because otherwise I'm wasting

13002
08:09:58,360 --> 08:10:02,600
my time doing the same thing again and

13003
08:09:59,920 --> 08:10:03,877
again if no one's actually moving so I'm

13004
08:10:02,600 --> 08:10:05,120
afraid we don't have Monopoly games for

13005
08:10:03,878 --> 08:10:06,558
all of you but we do have eight stress

13006
08:10:05,120 --> 08:10:07,878
balls and a round of applause if we

13007
08:10:06,558 --> 08:10:09,478
could for our

13008
08:10:07,878 --> 08:10:11,798
volunteers if you want to put your

13009
08:10:09,478 --> 08:10:15,079
numbers on the Shelf

13010
08:10:11,798 --> 08:10:17,160
there so if we consider for a moment

13011
08:10:15,080 --> 08:10:20,040
thank you thank you so

13012
08:10:17,160 --> 08:10:24,160
much

13013
08:10:20,040 --> 08:10:26,878
sure thank you thanks sure so if we

13014
08:10:24,160 --> 08:10:29,318
consider now these two algorithms which

13015
08:10:26,878 --> 08:10:31,600
one is better any intuition for whether

13016
08:10:29,318 --> 08:10:33,878
selection sort the first is better or

13017
08:10:31,600 --> 08:10:36,239
worse than bubble sort the

13018
08:10:33,878 --> 08:10:39,240
second any

13019
08:10:36,240 --> 08:10:39,240
thoughts

13020
08:10:41,040 --> 08:10:45,798
yeah okay so bubbl swort seemed like

13021
08:10:44,240 --> 08:10:47,798
less work especially since I was

13022
08:10:45,798 --> 08:10:49,440
focusing on those localized problems

13023
08:10:47,798 --> 08:10:52,557
other

13024
08:10:49,440 --> 08:10:55,160
intuition selection sort versus bubble

13025
08:10:52,558 --> 08:10:56,878
sort well let me propose that we try to

13026
08:10:55,160 --> 08:10:58,680
like quantize this so we can actually

13027
08:10:56,878 --> 08:11:00,798
analyze it in some way and this is not

13028
08:10:58,680 --> 08:11:02,160
an exercise we'll do constantly for lots

13029
08:11:00,798 --> 08:11:04,039
of algorithms but these are pretty

13030
08:11:02,160 --> 08:11:06,000
representative of algorithms so we can

13031
08:11:04,040 --> 08:11:07,478
wrap our minds around indeed the

13032
08:11:06,000 --> 08:11:09,798
performance or the design of these

13033
08:11:07,478 --> 08:11:12,760
things so here is my pseudo code for

13034
08:11:09,798 --> 08:11:14,878
selection sort whereby as it's as per

13035
08:11:12,760 --> 08:11:17,478
its name I just iteratively select the

13036
08:11:14,878 --> 08:11:19,798
next smallest element El again and again

13037
08:11:17,478 --> 08:11:21,600
so how can we go about analyzing

13038
08:11:19,798 --> 08:11:23,638
something like this well we could just

13039
08:11:21,600 --> 08:11:25,840
do it on paper pencil and count up the

13040
08:11:23,638 --> 08:11:28,000
number of steps that seem to be implied

13041
08:11:25,840 --> 08:11:29,958
logically by the code we could literally

13042
08:11:28,000 --> 08:11:31,878
comp count like the number of steps I

13043
08:11:29,958 --> 08:11:33,440
was taking again and again left to right

13044
08:11:31,878 --> 08:11:36,000
we could also just com uh count the

13045
08:11:33,440 --> 08:11:37,680
number of comparisons I was making with

13046
08:11:36,000 --> 08:11:39,000
each of the persons involved and I was

13047
08:11:37,680 --> 08:11:41,160
doing it kind of quickly in selection

13048
08:11:39,000 --> 08:11:42,520
sort but every time I was looking at a

13049
08:11:41,160 --> 08:11:44,000
person trying to decide do I want to

13050
08:11:42,520 --> 08:11:46,040
remember that number is small as that

13051
08:11:44,000 --> 08:11:48,080
number I was comparing two values with

13052
08:11:46,040 --> 08:11:49,878
an equals equals or less than or greater

13053
08:11:48,080 --> 08:11:52,040
than sign at least if we had done this

13054
08:11:49,878 --> 08:11:54,000
in code so that tends to be the norm

13055
08:11:52,040 --> 08:11:55,520
when analyzing algorithms like these

13056
08:11:54,000 --> 08:11:58,600
counting the number of comparisons

13057
08:11:55,520 --> 08:12:00,080
because it's kind of a global uh it's

13058
08:11:58,600 --> 08:12:01,600
kind of a global unit of measure we can

13059
08:12:00,080 --> 08:12:05,318
use to compare different algorithms

13060
08:12:01,600 --> 08:12:07,440
entirely so think too that in the

13061
08:12:05,318 --> 08:12:09,239
general case when we have more than

13062
08:12:07,440 --> 08:12:11,440
eight volunteers more than seven doors

13063
08:12:09,240 --> 08:12:13,240
we can generalize our our array in

13064
08:12:11,440 --> 08:12:15,680
general as this is the first element at

13065
08:12:13,240 --> 08:12:18,958
bracket zero and the end of it is always

13066
08:12:15,680 --> 08:12:21,360
n minus one so arrays uh or doors in

13067
08:12:18,958 --> 08:12:23,958
this case or volunteers are always

13068
08:12:21,360 --> 08:12:26,200
numerically indexed from zero on up to n

13069
08:12:23,958 --> 08:12:28,520
minus one if there's n of them in total

13070
08:12:26,200 --> 08:12:31,520
so how do we analyze the code of

13071
08:12:28,520 --> 08:12:34,680
selection sort well how many steps did

13072
08:12:31,520 --> 08:12:36,798
it take me to find the first smallest

13073
08:12:34,680 --> 08:12:38,398
element or more precisely how many

13074
08:12:36,798 --> 08:12:40,920
comparisons did I need to make when I

13075
08:12:38,398 --> 08:12:44,000
walked left to right to find our first

13076
08:12:40,920 --> 08:12:47,039
smallest person which ended up being

13077
08:12:44,000 --> 08:12:48,798
zero how many comparisons did I do when

13078
08:12:47,040 --> 08:12:50,280
walking left to right if there were

13079
08:12:48,798 --> 08:12:53,760
eight people on

13080
08:12:50,280 --> 08:12:55,760
stage how many total comparisons did I

13081
08:12:53,760 --> 08:12:59,079
do like if there's eight people I

13082
08:12:55,760 --> 08:13:02,000
compared these folks then then like this

13083
08:12:59,080 --> 08:13:03,200
person this person yeah yeah so seven

13084
08:13:02,000 --> 08:13:04,878
total right because if there's eight

13085
08:13:03,200 --> 08:13:07,120
people on stage you can only do seven

13086
08:13:04,878 --> 08:13:08,760
comparisons total because otherwise

13087
08:13:07,120 --> 08:13:10,638
you'd be comparing one number to itself

13088
08:13:08,760 --> 08:13:12,798
so it seems like in the general case if

13089
08:13:10,638 --> 08:13:14,920
you've got n numbers that you're trying

13090
08:13:12,798 --> 08:13:17,397
to sort finding the smallest element

13091
08:13:14,920 --> 08:13:20,239
first takes n minus one comparisons

13092
08:13:17,398 --> 08:13:21,680
maybe n it's total steps left or right

13093
08:13:20,240 --> 08:13:23,718
but the number of comparisons which I

13094
08:13:21,680 --> 08:13:25,840
claim is just a useful unit of measure

13095
08:13:23,718 --> 08:13:28,440
is n minus one how about finding the

13096
08:13:25,840 --> 08:13:30,398
next smallest person how many steps did

13097
08:13:28,440 --> 08:13:33,798
it take me to find the next smallest

13098
08:13:30,398 --> 08:13:33,798
number which ended up being the number

13099
08:13:33,878 --> 08:13:38,718
one

13100
08:13:36,318 --> 08:13:40,440
yeah yeah so just n minus two why

13101
08:13:38,718 --> 08:13:41,558
because I'd already solved one problem

13102
08:13:40,440 --> 08:13:42,958
someone was already in the right

13103
08:13:41,558 --> 08:13:44,718
position it would be silly to keep

13104
08:13:42,958 --> 08:13:46,199
counting them again and again so I can

13105
08:13:44,718 --> 08:13:48,638
Whittle down my number of comparisons

13106
08:13:46,200 --> 08:13:50,080
for the next past n minus 2 the third

13107
08:13:48,638 --> 08:13:52,600
past to find the third smallest number

13108
08:13:50,080 --> 08:13:54,878
would be n minus 3 and then dot dot dot

13109
08:13:52,600 --> 08:13:56,958
presumably this story this formula ends

13110
08:13:54,878 --> 08:13:59,160
when you have just one final pair the

13111
08:13:56,958 --> 08:14:00,840
people at the end to compare so if this

13112
08:13:59,160 --> 08:14:02,958
is looking a little reminiscent of some

13113
08:14:00,840 --> 08:14:04,360
kind of recurrence from high school or

13114
08:14:02,958 --> 08:14:05,840
high school math or physics or the like

13115
08:14:04,360 --> 08:14:07,878
let me just stipulate that if you

13116
08:14:05,840 --> 08:14:12,240
actually do out this math and generalize

13117
08:14:07,878 --> 08:14:13,600
it that is the same thing as n * nus1 /

13118
08:14:12,240 --> 08:14:15,558
2 and if you're Rusty on that no big

13119
08:14:13,600 --> 08:14:17,717
deal just kind of commit to memory that

13120
08:14:15,558 --> 08:14:18,878
anytime you add up this kind of series

13121
08:14:17,718 --> 08:14:20,440
something plus something slightly

13122
08:14:18,878 --> 08:14:22,000
smaller plus something slightly smaller

13123
08:14:20,440 --> 08:14:25,600
Each of which differs by one you're

13124
08:14:22,000 --> 08:14:27,878
going to get this formula n * n -1/ 2 if

13125
08:14:25,600 --> 08:14:30,120
we of course uh uh multiply that out

13126
08:14:27,878 --> 08:14:32,080
that's really n^ 2 minus n all divided

13127
08:14:30,120 --> 08:14:36,160
by two if we keep multiplying it out

13128
08:14:32,080 --> 08:14:38,558
that's n^2 / 2 minus n /2 and now we

13129
08:14:36,160 --> 08:14:40,920
have kind of a vocabulary with which we

13130
08:14:38,558 --> 08:14:42,878
can talk about the efficiency the design

13131
08:14:40,920 --> 08:14:44,397
of this algorithm but honestly I don't

13132
08:14:42,878 --> 08:14:49,120
really care about this level of

13133
08:14:44,398 --> 08:14:52,120
precision like n^2 / 2us n / 2 as n gets

13134
08:14:49,120 --> 08:14:54,120
really large which of these symbols

13135
08:14:52,120 --> 08:14:56,280
which of these terms is really going to

13136
08:14:54,120 --> 08:14:58,397
dominate become the biggest influencer

13137
08:14:56,280 --> 08:15:00,717
on the total value of

13138
08:14:58,398 --> 08:15:02,280
steps right it's the square right like

13139
08:15:00,718 --> 08:15:03,840
it's definitely not n divided by two

13140
08:15:02,280 --> 08:15:06,039
that's shaving some time off but N

13141
08:15:03,840 --> 08:15:08,520
squared as n gets big is going to get

13142
08:15:06,040 --> 08:15:10,920
really big if n is 100 then n squar is

13143
08:15:08,520 --> 08:15:12,920
bigger if N is a million n squ is really

13144
08:15:10,920 --> 08:15:15,079
bigger and so at the end of the day when

13145
08:15:12,920 --> 08:15:17,000
we really just talking about sort of a

13146
08:15:15,080 --> 08:15:19,398
wave of of the hand analysis and upper

13147
08:15:17,000 --> 08:15:22,558
bound if you will let's just say that

13148
08:15:19,398 --> 08:15:25,040
selection sort as analyzed here it's on

13149
08:15:22,558 --> 08:15:27,160
the order of n s steps it's not

13150
08:15:25,040 --> 08:15:30,840
precisely n squar steps but you know

13151
08:15:27,160 --> 08:15:34,160
what n^2 divided two the intuition here

13152
08:15:30,840 --> 08:15:36,238
might be that well it's half of that you

13153
08:15:34,160 --> 08:15:38,558
n squ is what really matters as n gets

13154
08:15:36,238 --> 08:15:39,878
really really large and that's when you

13155
08:15:38,558 --> 08:15:41,440
start thinking about and trying to solve

13156
08:15:39,878 --> 08:15:42,920
the Google problems of the world when n

13157
08:15:41,440 --> 08:15:44,680
gets large that's when you have to be

13158
08:15:42,920 --> 08:15:47,280
smarter than just sort of naive

13159
08:15:44,680 --> 08:15:49,878
implementations of any algorithm so

13160
08:15:47,280 --> 08:15:52,360
where then does this algorithm fall into

13161
08:15:49,878 --> 08:15:55,000
this categorization here well n^2 it

13162
08:15:52,360 --> 08:15:57,718
turns out is on the order of n squ steps

13163
08:15:55,000 --> 08:16:01,000
in the worst case whether it's sorted or

13164
08:15:57,718 --> 08:16:04,318
not it turns out though lower bound if

13165
08:16:01,000 --> 08:16:06,160
we consider this same code suppose the

13166
08:16:04,318 --> 08:16:07,840
best case scenario like our eight

13167
08:16:06,160 --> 08:16:10,079
volunteers came up on stage and just

13168
08:16:07,840 --> 08:16:12,120
because they already sorted themselves 0

13169
08:16:10,080 --> 08:16:14,440
through seven suppose they just happen

13170
08:16:12,120 --> 08:16:15,798
to be in that state how many steps would

13171
08:16:14,440 --> 08:16:20,600
selection store

13172
08:16:15,798 --> 08:16:24,360
take to sort an already sorted list of

13173
08:16:20,600 --> 08:16:24,359
volunteers any intuition

13174
08:16:25,798 --> 08:16:31,478
yeah would it still be

13175
08:16:29,120 --> 08:16:33,798
n so for the first pass it would still

13176
08:16:31,478 --> 08:16:35,680
be seven for the first per uh pass

13177
08:16:33,798 --> 08:16:37,760
across the humans because even though

13178
08:16:35,680 --> 08:16:39,638
yeah I'm claiming zero is here I don't

13179
08:16:37,760 --> 08:16:41,557
know that zero is the smallest until I

13180
08:16:39,638 --> 08:16:44,160
make my way all the way over there doing

13181
08:16:41,558 --> 08:16:46,360
all seven comparisons okay fine first

13182
08:16:44,160 --> 08:16:48,318
pass took seven more generally n minus

13183
08:16:46,360 --> 08:16:50,398
one steps what if I look for the next

13184
08:16:48,318 --> 08:16:53,478
smallest element and the humans in this

13185
08:16:50,398 --> 08:16:55,680
story are already sorted 0 through 7

13186
08:16:53,478 --> 08:16:57,718
well yes the number one's here and I see

13187
08:16:55,680 --> 08:16:59,840
them first but I don't know they're the

13188
08:16:57,718 --> 08:17:01,718
smallest until I compare against

13189
08:16:59,840 --> 08:17:03,398
everyone else get to the end of the list

13190
08:17:01,718 --> 08:17:05,878
oh well that was stupid I already had

13191
08:17:03,398 --> 08:17:07,680
the smallest person in hand then and so

13192
08:17:05,878 --> 08:17:10,318
this pseudo code this implementation of

13193
08:17:07,680 --> 08:17:12,238
selection sort is sort of fixed like

13194
08:17:10,318 --> 08:17:15,237
this there's no special case that says

13195
08:17:12,238 --> 08:17:17,398
if already sorted quit early it's always

13196
08:17:15,238 --> 08:17:19,920
going to take n squ steps and so in this

13197
08:17:17,398 --> 08:17:23,440
case if we borrow our uh jargon from

13198
08:17:19,920 --> 08:17:26,000
earlier using Omega notation just to be

13199
08:17:23,440 --> 08:17:29,318
clear selection sword is also going to

13200
08:17:26,000 --> 08:17:31,080
be in this Incarnation on an Omega of n

13201
08:17:29,318 --> 08:17:32,840
s because even in the best case where

13202
08:17:31,080 --> 08:17:34,958
the list is already sorted you're going

13203
08:17:32,840 --> 08:17:37,080
to waste a huge amount of time

13204
08:17:34,958 --> 08:17:38,318
essentially verifying as much or

13205
08:17:37,080 --> 08:17:40,680
discovering as much even though we

13206
08:17:38,318 --> 08:17:42,638
humans of course could see it right away

13207
08:17:40,680 --> 08:17:45,280
so selection sort would seem to take

13208
08:17:42,638 --> 08:17:47,798
both N squared steps in the uh worst

13209
08:17:45,280 --> 08:17:49,079
case n s steps in the best case and so

13210
08:17:47,798 --> 08:17:50,878
you know what we can use our Theta

13211
08:17:49,080 --> 08:17:52,760
terminology for that here would be an

13212
08:17:50,878 --> 08:17:55,000
algorithm just like counting earlier

13213
08:17:52,760 --> 08:17:57,079
that always takes N squared steps no

13214
08:17:55,000 --> 08:17:59,160
matter whether the array is sorted or

13215
08:17:57,080 --> 08:18:00,558
not from the get-go all right so

13216
08:17:59,160 --> 08:18:02,760
hopefully we can do better and someone

13217
08:18:00,558 --> 08:18:04,878
proposed earlier that bubble sort felt

13218
08:18:02,760 --> 08:18:07,440
like it was using fewer steps well let's

13219
08:18:04,878 --> 08:18:10,478
consider that next with bubble sort we

13220
08:18:07,440 --> 08:18:12,237
had this pseudo code I claim whereby

13221
08:18:10,478 --> 08:18:16,040
let's focus on the inside of the code

13222
08:18:12,238 --> 08:18:19,718
first down here what was I doing for I

13223
08:18:16,040 --> 08:18:22,440
from 0 to n minus 2 that's curious we've

13224
08:18:19,718 --> 08:18:24,760
never seen n minus 2 before but I asked

13225
08:18:22,440 --> 08:18:28,039
this question if numbers bracket I and

13226
08:18:24,760 --> 08:18:30,478
numbers bracket I + 1 are out of order

13227
08:18:28,040 --> 08:18:32,200
swap them so that was when I was

13228
08:18:30,478 --> 08:18:34,200
pointing at our first two volunteers

13229
08:18:32,200 --> 08:18:37,080
here I saw that they were out of order

13230
08:18:34,200 --> 08:18:40,878
so I swapped them how come I'm doing

13231
08:18:37,080 --> 08:18:42,360
that again and again up to nus 2 though

13232
08:18:40,878 --> 08:18:44,718
instead of n

13233
08:18:42,360 --> 08:18:47,638
minus1 which we've always used up until

13234
08:18:44,718 --> 08:18:50,558
now as our rightmost

13235
08:18:47,638 --> 08:18:55,160
boundary any intuition for why I'm doing

13236
08:18:50,558 --> 08:18:55,160
this from 0 to n minus 2

13237
08:18:59,200 --> 08:19:05,120
yeah exactly because I'm looking at the

13238
08:19:02,398 --> 08:19:07,840
E person per this pseudo code here and

13239
08:19:05,120 --> 08:19:09,718
the E plus one person I better make sure

13240
08:19:07,840 --> 08:19:11,318
I don't go Step Beyond the at boundaries

13241
08:19:09,718 --> 08:19:13,440
of my array so if you think of like my

13242
08:19:11,318 --> 08:19:15,478
left hand when my back was two here

13243
08:19:13,440 --> 08:19:17,877
pointing at the current person at the

13244
08:19:15,478 --> 08:19:19,160
first position my right hand for this if

13245
08:19:17,878 --> 08:19:20,798
conditioner is essentially pointing at

13246
08:19:19,160 --> 08:19:23,000
the person next to them and you want to

13247
08:19:20,798 --> 08:19:24,520
iterate with your left hand all through

13248
08:19:23,000 --> 08:19:26,520
these people but you don't want your

13249
08:19:24,520 --> 08:19:28,040
left hand to point at the last person

13250
08:19:26,520 --> 08:19:30,398
you want it to point at the second to

13251
08:19:28,040 --> 08:19:33,600
last person but we know that the last

13252
08:19:30,398 --> 08:19:34,718
person is always at n minus one so the

13253
08:19:33,600 --> 08:19:37,039
second to last person just

13254
08:19:34,718 --> 08:19:39,000
mathematically is at n minus 2 so it's a

13255
08:19:37,040 --> 08:19:40,798
subtlety but this is like a Segal

13256
08:19:39,000 --> 08:19:43,280
waiting to happen if you implemented

13257
08:19:40,798 --> 08:19:45,120
bubble sort using n minus one you will

13258
08:19:43,280 --> 08:19:47,199
my right hand would go beyond the

13259
08:19:45,120 --> 08:19:49,318
boundaries of the array so just bad all

13260
08:19:47,200 --> 08:19:51,360
right so why am I saying this end times

13261
08:19:49,318 --> 08:19:55,237
Well we did it very organically with

13262
08:19:51,360 --> 08:19:57,160
humans but each time someone uh each

13263
08:19:55,238 --> 08:19:59,000
pass I did through the array someone

13264
08:19:57,160 --> 08:20:01,920
bubbled their way up to the end number

13265
08:19:59,000 --> 08:20:04,478
seven then number six then number five

13266
08:20:01,920 --> 08:20:07,638
so if on each pass through the array of

13267
08:20:04,478 --> 08:20:09,840
volunteers I was solving at Mo at least

13268
08:20:07,638 --> 08:20:12,237
one problem it seems like bubble sort

13269
08:20:09,840 --> 08:20:14,478
can just run n times total to solve all

13270
08:20:12,238 --> 08:20:15,798
n problems cuz the first pass will get

13271
08:20:14,478 --> 08:20:17,397
at least one one number into place

13272
08:20:15,798 --> 08:20:19,120
second pass second number into place you

13273
08:20:17,398 --> 08:20:20,760
might get lucky and it would do more but

13274
08:20:19,120 --> 08:20:23,120
worst case this feels like enough just

13275
08:20:20,760 --> 08:20:27,120
do this blindly end times and they'll

13276
08:20:23,120 --> 08:20:28,200
all line up together well technically

13277
08:20:27,120 --> 08:20:29,798
all right now we're getting into the

13278
08:20:28,200 --> 08:20:31,840
weeds technically you can just repeat it

13279
08:20:29,798 --> 08:20:33,397
n minus one times because if you solve

13280
08:20:31,840 --> 08:20:35,520
all n minus one other problems and

13281
08:20:33,398 --> 08:20:37,238
you're left with one like literally that

13282
08:20:35,520 --> 08:20:38,520
person's where they need to be just

13283
08:20:37,238 --> 08:20:39,680
logically if you've already sorted

13284
08:20:38,520 --> 08:20:41,760
everything else and you've got just the

13285
08:20:39,680 --> 08:20:43,840
one left it's already bubbled up so how

13286
08:20:41,760 --> 08:20:45,840
do we analyze this well in bubble sore

13287
08:20:43,840 --> 08:20:49,040
we might do something like this I'm

13288
08:20:45,840 --> 08:20:51,120
essentially doing n minus one Things N

13289
08:20:49,040 --> 08:20:52,280
minus one times now let me back up to

13290
08:20:51,120 --> 08:20:54,760
the pseudo code because this one's a

13291
08:20:52,280 --> 08:20:57,039
little less obvious this is where you

13292
08:20:54,760 --> 08:20:59,478
can actually mathematically infer from

13293
08:20:57,040 --> 08:21:01,760
your Loop uh how many steps you're

13294
08:20:59,478 --> 08:21:03,798
taking so this first line literally says

13295
08:21:01,760 --> 08:21:04,877
repeat the following n minus one times

13296
08:21:03,798 --> 08:21:06,520
so that's going to translate very

13297
08:21:04,878 --> 08:21:09,360
straightforwardly to our mathematical

13298
08:21:06,520 --> 08:21:11,478
formula do something n minus one times

13299
08:21:09,360 --> 08:21:13,920
this Loop just because I'm using four

13300
08:21:11,478 --> 08:21:15,680
Loop terminology it's framed a little

13301
08:21:13,920 --> 08:21:20,397
differently but but if you're iterating

13302
08:21:15,680 --> 08:21:23,398
from 0 to nus 2 you're iterating a total

13303
08:21:20,398 --> 08:21:24,680
of nus1 times and again the arithmetic

13304
08:21:23,398 --> 08:21:26,680
is getting a little annoying but this

13305
08:21:24,680 --> 08:21:29,718
just means do the following n minus one

13306
08:21:26,680 --> 08:21:32,440
times so do n minus one Things N minus

13307
08:21:29,718 --> 08:21:35,478
one times we can now uh run out the math

13308
08:21:32,440 --> 08:21:38,160
as follows we have the formula n minus1

13309
08:21:35,478 --> 08:21:42,360
* n minus1 we do our little foil method

13310
08:21:38,160 --> 08:21:45,520
here N2 -1 * N - 1 * n + 1 we can

13311
08:21:42,360 --> 08:21:47,318
combine like terms n^ 2 - 2 n plus one

13312
08:21:45,520 --> 08:21:49,238
but at this point when n gets really

13313
08:21:47,318 --> 08:21:51,440
large which term are we really going to

13314
08:21:49,238 --> 08:21:55,680
care about this is on the order

13315
08:21:51,440 --> 08:21:58,079
of yeah n s so at least ASM totically

13316
08:21:55,680 --> 08:22:00,398
ASM totically means as n approaches

13317
08:21:58,080 --> 08:22:02,080
Infinity gets really large turns out

13318
08:22:00,398 --> 08:22:04,238
that the upper bounds on selection sort

13319
08:22:02,080 --> 08:22:06,120
and bubble sort are essentially the same

13320
08:22:04,238 --> 08:22:07,520
now if we really nitpicked and compared

13321
08:22:06,120 --> 08:22:09,318
the total number of comparisons they

13322
08:22:07,520 --> 08:22:10,920
might differ slightly but as n gets

13323
08:22:09,318 --> 08:22:12,638
large honestly you're barely going to

13324
08:22:10,920 --> 08:22:15,359
notice the difference it would seem

13325
08:22:12,638 --> 08:22:18,718
between these two algorithms

13326
08:22:15,360 --> 08:22:20,478
but what about um the lower bound if the

13327
08:22:18,718 --> 08:22:24,280
upper bound on Bubble sword is also Big

13328
08:22:20,478 --> 08:22:26,840
O of n what about the lower bound here

13329
08:22:24,280 --> 08:22:29,237
well with this pseudo code what would

13330
08:22:26,840 --> 08:22:30,440
the lower bound be on bubble sort even

13331
08:22:29,238 --> 08:22:31,878
in the best case when all of the

13332
08:22:30,440 --> 08:22:34,680
volunteers are

13333
08:22:31,878 --> 08:22:36,718
sorted any

13334
08:22:34,680 --> 08:22:38,798
intuition in this pseudo code yeah in

13335
08:22:36,718 --> 08:22:38,798
the

13336
08:22:43,680 --> 08:22:46,840
middle

13337
08:22:45,238 --> 08:22:48,360
good question isn't bubble sorts

13338
08:22:46,840 --> 08:22:51,120
designed such that you wouldn't need to

13339
08:22:48,360 --> 08:22:54,040
compare numbers that have already uh

13340
08:22:51,120 --> 08:22:56,520
bubbled up that's what's happening here

13341
08:22:54,040 --> 08:22:59,080
in the middle implicitly I'm always

13342
08:22:56,520 --> 08:23:00,600
going from left to right but remember

13343
08:22:59,080 --> 08:23:01,878
that even when I screwed up at the end

13344
08:23:00,600 --> 08:23:04,079
and the last two people were out of

13345
08:23:01,878 --> 08:23:05,958
order I do always need to restart at the

13346
08:23:04,080 --> 08:23:07,238
beginning because the big numbers are

13347
08:23:05,958 --> 08:23:09,680
going that way and the small numbers are

13348
08:23:07,238 --> 08:23:09,680
coming this

13349
08:23:11,200 --> 08:23:15,200
way so that is true there are some

13350
08:23:13,478 --> 08:23:17,600
slight optimizations that I'm kind of

13351
08:23:15,200 --> 08:23:18,920
glossing over here let me stipulate that

13352
08:23:17,600 --> 08:23:20,440
it would still end up being on the order

13353
08:23:18,920 --> 08:23:23,120
of n squ but that would definitely shave

13354
08:23:20,440 --> 08:23:25,237
off some actual running time here but

13355
08:23:23,120 --> 08:23:26,798
what if the list is already sorted our

13356
08:23:25,238 --> 08:23:29,040
our pseudo code at the moment has no

13357
08:23:26,798 --> 08:23:31,397
allowance for if list is already sorted

13358
08:23:29,040 --> 08:23:33,840
quit early so we're going to blindly do

13359
08:23:31,398 --> 08:23:36,600
n minus one Things N minus one times

13360
08:23:33,840 --> 08:23:39,040
unless we modify our pseudo code as I

13361
08:23:36,600 --> 08:23:41,600
did verbally earlier I propose this

13362
08:23:39,040 --> 08:23:43,638
inside of that outer loop if you make a

13363
08:23:41,600 --> 08:23:45,877
pass across all of the volunteers and

13364
08:23:43,638 --> 08:23:47,237
your mental counter has made no swaps

13365
08:23:45,878 --> 08:23:48,958
you have to keep track with some kind of

13366
08:23:47,238 --> 08:23:50,638
variable well then you might as well

13367
08:23:48,958 --> 08:23:52,798
stop because if you do a whole pass and

13368
08:23:50,638 --> 08:23:55,680
make no swaps why would you waste time

13369
08:23:52,798 --> 08:23:59,440
doing it again expecting different

13370
08:23:55,680 --> 08:24:01,520
Behavior so to help visualize these

13371
08:23:59,440 --> 08:24:03,760
whereby now bubble sort can be

13372
08:24:01,520 --> 08:24:06,398
advantageous if the data is already

13373
08:24:03,760 --> 08:24:08,397
sorted or mostly sorted why because it

13374
08:24:06,398 --> 08:24:10,638
does have this short circuit detail at

13375
08:24:08,398 --> 08:24:13,760
least if we implement it like that how

13376
08:24:10,638 --> 08:24:15,557
can we go about um visualizing these

13377
08:24:13,760 --> 08:24:17,798
things a little more clearly well let me

13378
08:24:15,558 --> 08:24:20,120
go ahead and do this let me pull up here

13379
08:24:17,798 --> 08:24:22,318
a visualization of exactly these

13380
08:24:20,120 --> 08:24:24,079
algorithms thanks to a third party tool

13381
08:24:22,318 --> 08:24:25,840
here that's going to help us visualize

13382
08:24:24,080 --> 08:24:27,878
these sorting algorithms as follows

13383
08:24:25,840 --> 08:24:29,760
small bars represent small numbers big

13384
08:24:27,878 --> 08:24:32,680
bars represent big numbers and so the

13385
08:24:29,760 --> 08:24:34,440
idea now is when I hit a button here to

13386
08:24:32,680 --> 08:24:36,080
get all of the small bars this way all

13387
08:24:34,440 --> 08:24:37,798
of the big bars this way so just like

13388
08:24:36,080 --> 08:24:40,200
our volunteers but instead of holding

13389
08:24:37,798 --> 08:24:42,237
lighted numbers its bars representing

13390
08:24:40,200 --> 08:24:45,160
their magnitude so let's go ahead and

13391
08:24:42,238 --> 08:24:48,238
start with for instance select

13392
08:24:45,160 --> 08:24:50,958
sort and you'll see in pink is being

13393
08:24:48,238 --> 08:24:52,798
highlighted the current number that is

13394
08:24:50,958 --> 08:24:54,440
being selected and then pulled all the

13395
08:24:52,798 --> 08:24:58,199
way to the left so this is selection

13396
08:24:54,440 --> 08:25:00,520
sort and again it's selecting the next

13397
08:24:58,200 --> 08:25:03,958
smallest element but you can see here

13398
08:25:00,520 --> 08:25:06,600
all the more visibly that just like my

13399
08:25:03,958 --> 08:25:08,638
human feet were taking a lot of steps so

13400
08:25:06,600 --> 08:25:11,397
is this algorithm touching these

13401
08:25:08,638 --> 08:25:13,878
elements again and again and again and

13402
08:25:11,398 --> 08:25:15,440
this is why the N squ is really a thing

13403
08:25:13,878 --> 08:25:17,160
there's got to be some inherent

13404
08:25:15,440 --> 08:25:18,717
redundancy here like why do we keep

13405
08:25:17,160 --> 08:25:20,840
looking at the same darn elements again

13406
08:25:18,718 --> 08:25:22,638
and again we do in terms of our pseudo

13407
08:25:20,840 --> 08:25:24,798
code need to do so but it's this

13408
08:25:22,638 --> 08:25:27,798
redundant comparisons that kind of

13409
08:25:24,798 --> 08:25:29,798
explains why n s is indeed the case so

13410
08:25:27,798 --> 08:25:31,079
now it's done small bars here big bars

13411
08:25:29,798 --> 08:25:32,397
there and I had to just keep talking

13412
08:25:31,080 --> 08:25:34,718
there to kill time because it's

13413
08:25:32,398 --> 08:25:36,718
relatively slow well let me randomize

13414
08:25:34,718 --> 08:25:38,440
the array just so we start with a

13415
08:25:36,718 --> 08:25:40,680
different order and now let me click on

13416
08:25:38,440 --> 08:25:43,520
bubbl sore and you'll see similar idea

13417
08:25:40,680 --> 08:25:45,760
but different algorithm so now the two

13418
08:25:43,520 --> 08:25:47,878
bars in pink are the two that are being

13419
08:25:45,760 --> 08:25:49,478
compared and fixed potentially if

13420
08:25:47,878 --> 08:25:50,840
they're out of order and you can see

13421
08:25:49,478 --> 08:25:54,040
already that the biggest bars are

13422
08:25:50,840 --> 08:25:56,398
bubbling their way up to the top but now

13423
08:25:54,040 --> 08:25:58,478
you can also see like this redundancy

13424
08:25:56,398 --> 08:26:00,478
like we keep swooping through the list

13425
08:25:58,478 --> 08:26:02,718
again and again just like I kept walking

13426
08:26:00,478 --> 08:26:04,558
back and forth and this is n squar this

13427
08:26:02,718 --> 08:26:06,840
is not that many bars what 10 20 there's

13428
08:26:04,558 --> 08:26:09,120
like 40 or something bars I'm guessing

13429
08:26:06,840 --> 08:26:11,798
that's pretty slow already just to sort

13430
08:26:09,120 --> 08:26:13,280
40 numbers and I think it's going to get

13431
08:26:11,798 --> 08:26:15,160
tedious if I keep talking over this so

13432
08:26:13,280 --> 08:26:18,039
let's just assume that this two is

13433
08:26:15,160 --> 08:26:20,238
relatively slow had I gotten lucky and

13434
08:26:18,040 --> 08:26:22,200
the list were almost sorted already

13435
08:26:20,238 --> 08:26:24,040
bubble sort would have been pretty fast

13436
08:26:22,200 --> 08:26:26,200
but this was a truly random array so we

13437
08:26:24,040 --> 08:26:29,160
did not get lucky so indeed the worst

13438
08:26:26,200 --> 08:26:31,080
case might be what's kicking in here so

13439
08:26:29,160 --> 08:26:33,079
I don't I feel like it'll be

13440
08:26:31,080 --> 08:26:34,840
anticlimactic like holding in a sneeze

13441
08:26:33,080 --> 08:26:37,680
if I don't let you see the end of this

13442
08:26:34,840 --> 08:26:39,958
so here we go nothing interesting is

13443
08:26:37,680 --> 08:26:45,718
about to happen almost

13444
08:26:39,958 --> 08:26:47,160
done ah okay done all right so thank you

13445
08:26:45,718 --> 08:26:51,878
thank

13446
08:26:47,160 --> 08:26:53,878
you so still somewhat slow though how

13447
08:26:51,878 --> 08:26:56,238
though can we perhaps do a little better

13448
08:26:53,878 --> 08:26:58,160
fundamentally so we can do so if we

13449
08:26:56,238 --> 08:27:00,000
introduce yet another technique and this

13450
08:26:58,160 --> 08:27:01,558
one isn't so much a function of code as

13451
08:27:00,000 --> 08:27:04,200
it is concept and it's something that

13452
08:27:01,558 --> 08:27:06,680
you might have seen in the real world um

13453
08:27:04,200 --> 08:27:10,440
but perhaps not so obviously so so it

13454
08:27:06,680 --> 08:27:12,638
turns out in programming recursion

13455
08:27:10,440 --> 08:27:15,079
refers to the ability of a function to

13456
08:27:12,638 --> 08:27:17,360
call itself in the world of mathematics

13457
08:27:15,080 --> 08:27:19,520
if you have a function f if F appears on

13458
08:27:17,360 --> 08:27:21,398
both the left side and the right side of

13459
08:27:19,520 --> 08:27:23,040
a formula that would be a recursive

13460
08:27:21,398 --> 08:27:24,680
function in the math world too whenever

13461
08:27:23,040 --> 08:27:28,080
f is defined in terms of itself or in

13462
08:27:24,680 --> 08:27:31,280
our case in Compu in programming anytime

13463
08:27:28,080 --> 08:27:32,958
a function calls itself that function is

13464
08:27:31,280 --> 08:27:34,360
said to be recursive and this is

13465
08:27:32,958 --> 08:27:35,680
actually something we've seen already in

13466
08:27:34,360 --> 08:27:38,000
class even though we didn't call it as

13467
08:27:35,680 --> 08:27:41,360
much so for instance consider this

13468
08:27:38,000 --> 08:27:44,680
pseudo code um from earlier whereby this

13469
08:27:41,360 --> 08:27:47,080
was the pseudo code for searching via AR

13470
08:27:44,680 --> 08:27:49,478
search a whole bunch of doors if no

13471
08:27:47,080 --> 08:27:51,600
doors are left return false that was the

13472
08:27:49,478 --> 08:27:53,280
the additional conditional we added but

13473
08:27:51,600 --> 08:27:55,557
then if number behind middle door return

13474
08:27:53,280 --> 08:27:58,520
true and here's the interesting part if

13475
08:27:55,558 --> 08:28:00,840
number is less than middle door search

13476
08:27:58,520 --> 08:28:03,000
the left half else if number is greater

13477
08:28:00,840 --> 08:28:05,878
than middle door search the right half

13478
08:28:03,000 --> 08:28:08,238
this pseudo code earlier was itself

13479
08:28:05,878 --> 08:28:10,000
recursive why because here is an

13480
08:28:08,238 --> 08:28:12,120
algorithm for searching but what's the

13481
08:28:10,000 --> 08:28:15,040
algorithm telling us well on this line

13482
08:28:12,120 --> 08:28:17,237
and this line it's telling us to search

13483
08:28:15,040 --> 08:28:19,080
something else so even though it's not

13484
08:28:17,238 --> 08:28:21,080
explicitly defined in code as having a

13485
08:28:19,080 --> 08:28:22,840
name if this is a search algorithm and

13486
08:28:21,080 --> 08:28:25,638
yet the search algorithm is using a

13487
08:28:22,840 --> 08:28:27,638
search algorithm this pseudo code is

13488
08:28:25,638 --> 08:28:29,600
recursive now that could quickly get you

13489
08:28:27,638 --> 08:28:33,237
into trouble if a function just calls

13490
08:28:29,600 --> 08:28:36,237
itself again and again and again but why

13491
08:28:33,238 --> 08:28:39,798
intuitively is it not problematic that

13492
08:28:36,238 --> 08:28:43,120
this code this pseudo code calls

13493
08:28:39,798 --> 08:28:46,120
itself why will the algorithm still stop

13494
08:28:43,120 --> 08:28:46,120
yeah

13495
08:28:46,840 --> 08:28:50,718
exactly it has some exit condition like

13496
08:28:48,638 --> 08:28:53,160
if no do is less and more more

13497
08:28:50,718 --> 08:28:55,478
importantly anytime you search the left

13498
08:28:53,160 --> 08:28:56,958
half you're searching a smaller version

13499
08:28:55,478 --> 08:28:58,798
of the problem anytime you search the

13500
08:28:56,958 --> 08:29:00,397
right half you're searching a smaller

13501
08:28:58,798 --> 08:29:02,360
version of the problem literally half

13502
08:29:00,398 --> 08:29:03,958
the size so this is why in the phone

13503
08:29:02,360 --> 08:29:06,160
book obviously I couldn't tear the phone

13504
08:29:03,958 --> 08:29:07,680
book in half uh infinitely many times

13505
08:29:06,160 --> 08:29:09,840
because it was literally getting smaller

13506
08:29:07,680 --> 08:29:12,520
each time so recursion is this ability

13507
08:29:09,840 --> 08:29:13,840
to call yourself if you will it's but

13508
08:29:12,520 --> 08:29:15,958
what's important is that you do it on a

13509
08:29:13,840 --> 08:29:18,238
small smaller smaller problem so that

13510
08:29:15,958 --> 08:29:20,318
eventually you have no more problems to

13511
08:29:18,238 --> 08:29:23,238
solve or no more data no more doors at

13512
08:29:20,318 --> 08:29:25,440
all so these two lines here would be the

13513
08:29:23,238 --> 08:29:27,238
recursive elements here but if we go

13514
08:29:25,440 --> 08:29:28,840
back to week zero we could have used

13515
08:29:27,238 --> 08:29:31,120
recursion in some other way so this was

13516
08:29:28,840 --> 08:29:33,160
our Cudo code for the phone book back in

13517
08:29:31,120 --> 08:29:34,638
week zero and recall that we described

13518
08:29:33,160 --> 08:29:36,840
these yellow lines as really

13519
08:29:34,638 --> 08:29:38,958
representing a loop some kind of cycle

13520
08:29:36,840 --> 08:29:41,440
again and again but there was a missed

13521
08:29:38,958 --> 08:29:43,638
opportunity here what if I had reinvent

13522
08:29:41,440 --> 08:29:44,798
reimplemented this code to do this

13523
08:29:43,638 --> 08:29:47,200
instead

13524
08:29:44,798 --> 08:29:49,039
instead of saying open to middle of left

13525
08:29:47,200 --> 08:29:51,600
half of book and then go back to line

13526
08:29:49,040 --> 08:29:53,280
three like literally inducing a loop or

13527
08:29:51,600 --> 08:29:55,638
open to Middle right half a book and go

13528
08:29:53,280 --> 08:29:57,520
back to line three inducing another loop

13529
08:29:55,638 --> 08:30:00,557
why don't I just recognize that what I'm

13530
08:29:57,520 --> 08:30:03,200
staring at now is a algorithm for

13531
08:30:00,558 --> 08:30:05,280
searching a phone book and if you want

13532
08:30:03,200 --> 08:30:08,600
to search a smaller phone book like a

13533
08:30:05,280 --> 08:30:10,557
through M or n through Z we'll just use

13534
08:30:08,600 --> 08:30:13,039
the same algorithm so I can replace

13535
08:30:10,558 --> 08:30:14,878
these yellow lines with just this

13536
08:30:13,040 --> 08:30:16,600
casually speaking search left half a

13537
08:30:14,878 --> 08:30:18,160
book search right half a book this would

13538
08:30:16,600 --> 08:30:20,478
be implicitly and now I can shorten the

13539
08:30:18,160 --> 08:30:22,120
whole thing a recursive implementation

13540
08:30:20,478 --> 08:30:23,920
of the phone book pseudo code from week

13541
08:30:22,120 --> 08:30:25,520
zero and it's recursive because if this

13542
08:30:23,920 --> 08:30:27,798
is a search algorithm and you're saying

13543
08:30:25,520 --> 08:30:29,600
go search something else that's fine

13544
08:30:27,798 --> 08:30:31,440
that's recursive but because you're

13545
08:30:29,600 --> 08:30:34,680
searching half of the phone book it's

13546
08:30:31,440 --> 08:30:37,280
indeed going to get smaller and smaller

13547
08:30:34,680 --> 08:30:39,718
even in the real world or the real

13548
08:30:37,280 --> 08:30:41,318
virtual world you can see recursive data

13549
08:30:39,718 --> 08:30:42,718
structures in the wild or at least in

13550
08:30:41,318 --> 08:30:44,798
Super Mario Brothers like this let me

13551
08:30:42,718 --> 08:30:47,280
get rid of all the distractions here and

13552
08:30:44,798 --> 08:30:50,120
focus on this pyramid where you have one

13553
08:30:47,280 --> 08:30:52,280
block then two then three then four well

13554
08:30:50,120 --> 08:30:54,079
this itself is technically recursively

13555
08:30:52,280 --> 08:30:57,557
defined in the sense that well what is a

13556
08:30:54,080 --> 08:30:59,478
pyramid of height four well it's really

13557
08:30:57,558 --> 08:31:01,238
what how would you describe a pyramid of

13558
08:30:59,478 --> 08:31:05,200
height four is actually the same thing

13559
08:31:01,238 --> 08:31:05,200
as a pyramid

13560
08:31:05,638 --> 08:31:10,318
of of of height three plus one

13561
08:31:08,798 --> 08:31:11,920
additional layer well what's a pyramid

13562
08:31:10,318 --> 08:31:14,200
of height three well it's technically a

13563
08:31:11,920 --> 08:31:16,280
pyramid of height two plus one

13564
08:31:14,200 --> 08:31:17,920
additional layer and so even physical

13565
08:31:16,280 --> 08:31:19,798
structures can be recursive if you can

13566
08:31:17,920 --> 08:31:21,839
Define them in terms of itself now at

13567
08:31:19,798 --> 08:31:23,920
some point you have to say that if the

13568
08:31:21,840 --> 08:31:26,200
pyramid is of height one there's just

13569
08:31:23,920 --> 08:31:27,877
one block you can't forever say it's

13570
08:31:26,200 --> 08:31:29,558
defined in terms of a height negative 1

13571
08:31:27,878 --> 08:31:31,398
negative2 you would never stop so you

13572
08:31:29,558 --> 08:31:32,958
have to kind of have a special case

13573
08:31:31,398 --> 08:31:34,638
there but let's go ahead and translate

13574
08:31:32,958 --> 08:31:37,199
something like this in fact to code let

13575
08:31:34,638 --> 08:31:39,397
me go back to uh vs code here and let me

13576
08:31:37,200 --> 08:31:42,280
Implement a program called iteration

13577
08:31:39,398 --> 08:31:44,200
that refers to a loop iterating and let

13578
08:31:42,280 --> 08:31:45,760
me Implement a very simple pyramid like

13579
08:31:44,200 --> 08:31:49,360
that so let me go ahead and include the

13580
08:31:45,760 --> 08:31:52,877
cs50 library I'll include our standard

13581
08:31:49,360 --> 08:31:54,558
i.h in main void no command line

13582
08:31:52,878 --> 08:31:56,200
arguments today and let's go ahead and

13583
08:31:54,558 --> 08:31:58,798
do this let's declare a variable called

13584
08:31:56,200 --> 08:32:02,200
height ask the human for the height of

13585
08:31:58,798 --> 08:32:04,360
this pyramid and then let's go ahead and

13586
08:32:02,200 --> 08:32:06,638
draw a pyramid of that height now of

13587
08:32:04,360 --> 08:32:08,318
course draw does not yet exist so I'm

13588
08:32:06,638 --> 08:32:10,120
going to need to invent the draw a

13589
08:32:08,318 --> 08:32:11,680
function let me go ahead and Define a

13590
08:32:10,120 --> 08:32:12,840
function that doesn't have a return

13591
08:32:11,680 --> 08:32:14,160
value it's just going to have side

13592
08:32:12,840 --> 08:32:16,760
effects it's just going to print bricks

13593
08:32:14,160 --> 08:32:19,718
on the screen call draw and it takes in

13594
08:32:16,760 --> 08:32:21,600
an integer n as its input and how am I

13595
08:32:19,718 --> 08:32:24,000
going to implement this well again I

13596
08:32:21,600 --> 08:32:26,160
want to print one block then two then

13597
08:32:24,000 --> 08:32:27,440
three then four that's pretty

13598
08:32:26,160 --> 08:32:29,079
straightforward at least once you're

13599
08:32:27,440 --> 08:32:32,280
comfortable with loops let me go back to

13600
08:32:29,080 --> 08:32:37,318
the code here let me go ahead and say 4

13601
08:32:32,280 --> 08:32:38,920
into I gets zero I is less than n i ++

13602
08:32:37,318 --> 08:32:41,840
and that's going to iterate essentially

13603
08:32:38,920 --> 08:32:44,237
row by row and on each row I want to

13604
08:32:41,840 --> 08:32:46,398
print out one then two then three then

13605
08:32:44,238 --> 08:32:48,558
four bricks but I'm iterating from Z to

13606
08:32:46,398 --> 08:32:50,840
1 to two to three so I think that's okay

13607
08:32:48,558 --> 08:32:54,080
I can just say something like 4 in J

13608
08:32:50,840 --> 08:32:57,478
gets zero J Let's Be Clever about this

13609
08:32:54,080 --> 08:33:00,398
is less than I

13610
08:32:57,478 --> 08:33:02,600
j++ and now let me go ahead and inside

13611
08:33:00,398 --> 08:33:06,160
of this loop I think I can get away with

13612
08:33:02,600 --> 08:33:08,397
just printing out a single hash sign but

13613
08:33:06,160 --> 08:33:10,920
then outside of that Loop similar to

13614
08:33:08,398 --> 08:33:13,080
last week I'm going to print my new line

13615
08:33:10,920 --> 08:33:15,519
separately so a little non-obvious at

13616
08:33:13,080 --> 08:33:18,000
first but this outer loop iterates row

13617
08:33:15,520 --> 08:33:21,318
by row line by line if you will and then

13618
08:33:18,000 --> 08:33:26,478
the inner loop just Mak sure that when I

13619
08:33:21,318 --> 08:33:29,760
equals zero um let's see oh nope there's

13620
08:33:26,478 --> 08:33:33,079
a bug I need to make sure that it's j is

13621
08:33:29,760 --> 08:33:35,039
less than I + 1 so when I is zero on my

13622
08:33:33,080 --> 08:33:38,638
first line of output I'm going to print

13623
08:33:35,040 --> 08:33:41,318
out one brick when I is one I'm going to

13624
08:33:38,638 --> 08:33:44,397
print out two bricks and so forth so let

13625
08:33:41,318 --> 08:33:48,318
me go ahead and run make iteration

13626
08:33:44,398 --> 08:33:50,798
all right and now seems to compile

13627
08:33:48,318 --> 08:33:52,638
uhoh huh implicit Declaration of

13628
08:33:50,798 --> 08:33:54,237
function draw so I'm making week one

13629
08:33:52,638 --> 08:33:56,557
mistakes

13630
08:33:54,238 --> 08:33:59,040
again what say

13631
08:33:56,558 --> 08:34:00,440
again yeah the the Prototype is missing

13632
08:33:59,040 --> 08:34:02,558
I didn't declare it at the top that's an

13633
08:34:00,440 --> 08:34:04,798
easy fix and the only time really it's

13634
08:34:02,558 --> 08:34:06,638
okay and necessary to copy paste let me

13635
08:34:04,798 --> 08:34:09,120
copy the functions declaration there end

13636
08:34:06,638 --> 08:34:11,557
it with a semicolon so that clang now

13637
08:34:09,120 --> 08:34:14,120
knows that draw will exist make

13638
08:34:11,558 --> 08:34:16,000
iteration now it works thank you /

13639
08:34:14,120 --> 08:34:18,318
iteration we'll type in something like

13640
08:34:16,000 --> 08:34:21,200
four and there we have it our pyramid of

13641
08:34:18,318 --> 08:34:23,000
height 1 2 3 4 that looks pretty similar

13642
08:34:21,200 --> 08:34:24,160
to this albeit using hashes so that's

13643
08:34:23,000 --> 08:34:26,040
how we would have implemented this like

13644
08:34:24,160 --> 08:34:28,638
two weeks ago in week one maybe last

13645
08:34:26,040 --> 08:34:31,120
week but just using arrays but let me

13646
08:34:28,638 --> 08:34:33,237
propose that we could do something

13647
08:34:31,120 --> 08:34:35,237
recursively instead let me close this

13648
08:34:33,238 --> 08:34:38,760
version of the code and let me go back

13649
08:34:35,238 --> 08:34:39,920
to VSS code and open up recursion doc

13650
08:34:38,760 --> 08:34:42,039
just to demonstrate something

13651
08:34:39,920 --> 08:34:43,717
recursively and I'll do it incorrectly

13652
08:34:42,040 --> 08:34:46,920
deliberately the first time so let me

13653
08:34:43,718 --> 08:34:51,318
include cs50.h let me include standard

13654
08:34:46,920 --> 08:34:55,397
i.h let me do uh int main void and let

13655
08:34:51,318 --> 08:34:58,318
me just blindly draw a pyramid initially

13656
08:34:55,398 --> 08:34:59,878
of height one but now in my draw

13657
08:34:58,318 --> 08:35:02,079
function let me reimplement it a little

13658
08:34:59,878 --> 08:35:03,840
differently so my draw function this

13659
08:35:02,080 --> 08:35:05,360
time is still going to take a number n

13660
08:35:03,840 --> 08:35:09,000
but that's how many hashes it's going to

13661
08:35:05,360 --> 08:35:12,160
print so let's do four into I gets zero

13662
08:35:09,000 --> 08:35:14,840
I is less than n i

13663
08:35:12,160 --> 08:35:18,718
++ then let's go ahead and print out a

13664
08:35:14,840 --> 08:35:22,000
single hash mark here and then after

13665
08:35:18,718 --> 08:35:24,718
that let's print out the end of the line

13666
08:35:22,000 --> 08:35:28,760
just as before but now this of course is

13667
08:35:24,718 --> 08:35:30,638
only going to draw a single um row it's

13668
08:35:28,760 --> 08:35:33,039
going to print out one hash or two

13669
08:35:30,638 --> 08:35:35,638
hashes or three hashes but only on one

13670
08:35:33,040 --> 08:35:38,040
line let me now incorrectly but just

13671
08:35:35,638 --> 08:35:40,397
kind of curiously say all right well if

13672
08:35:38,040 --> 08:35:42,440
this draws a pyramid of height one let's

13673
08:35:40,398 --> 08:35:44,840
just use ourself to draw a pyramid of

13674
08:35:42,440 --> 08:35:47,397
height n plus one so the first time I

13675
08:35:44,840 --> 08:35:49,360
call draw it will print out one hash

13676
08:35:47,398 --> 08:35:52,040
then the second time I call draw it will

13677
08:35:49,360 --> 08:35:53,958
print out two hashes then three then

13678
08:35:52,040 --> 08:35:58,360
four so we're kind of laying These

13679
08:35:53,958 --> 08:36:01,520
Bricks down from top to bottom uh make

13680
08:35:58,360 --> 08:36:03,958
recursion uh oops I screwed up again so

13681
08:36:01,520 --> 08:36:06,360
let's copy the Prototype here let's put

13682
08:36:03,958 --> 08:36:09,280
this down over here semicolon let's do

13683
08:36:06,360 --> 08:36:12,280
this again uh make recursion all right

13684
08:36:09,280 --> 08:36:13,798
all good/ recursion and now let me

13685
08:36:12,280 --> 08:36:16,237
increase the size of my terminal window

13686
08:36:13,798 --> 08:36:17,557
just so you can see more of the output

13687
08:36:16,238 --> 08:36:20,638
and here we

13688
08:36:17,558 --> 08:36:23,000
have okay bad but thank you so we have

13689
08:36:20,638 --> 08:36:24,557
an infinitely tall pyramid and it's just

13690
08:36:23,000 --> 08:36:26,600
flying across the screen which is why it

13691
08:36:24,558 --> 08:36:28,920
looks kind of like a mess but I printed

13692
08:36:26,600 --> 08:36:30,600
out a pyramid of height one and then two

13693
08:36:28,920 --> 08:36:32,920
and then three and then four and

13694
08:36:30,600 --> 08:36:35,160
unfortunately what am I lacking any sort

13695
08:36:32,920 --> 08:36:36,557
of quick condition any kind of condition

13696
08:36:35,160 --> 08:36:38,638
that says wait a minute when it's too

13697
08:36:36,558 --> 08:36:40,920
tall stop all together so this is an

13698
08:36:38,638 --> 08:36:43,079
infinite Loop but it's not a loop it's a

13699
08:36:40,920 --> 08:36:45,397
recursive call and actually doing this

13700
08:36:43,080 --> 08:36:46,798
in en is very bad we'll see next week

13701
08:36:45,398 --> 08:36:48,878
that if you call a function too many

13702
08:36:46,798 --> 08:36:51,079
times you can actually trigger yet one

13703
08:36:48,878 --> 08:36:52,318
yet another of those segmentation faults

13704
08:36:51,080 --> 08:36:54,398
cuz you're using too much memory

13705
08:36:52,318 --> 08:36:56,000
essentially but for now I haven't

13706
08:36:54,398 --> 08:36:58,160
triggered that yet control C is your

13707
08:36:56,000 --> 08:36:59,360
friend to cancel and as an aside if

13708
08:36:58,160 --> 08:37:01,318
you're playing along at home or play

13709
08:36:59,360 --> 08:37:02,958
with this code later I actually cheated

13710
08:37:01,318 --> 08:37:05,318
here we have a special clang

13711
08:37:02,958 --> 08:37:07,440
configuration feature that prevents you

13712
08:37:05,318 --> 08:37:09,398
from calling a function like that and

13713
08:37:07,440 --> 08:37:11,237
creating a problem I overrode it just to

13714
08:37:09,398 --> 08:37:12,478
for demonstration sake but odds are at

13715
08:37:11,238 --> 08:37:14,398
home you wouldn't be able to compile

13716
08:37:12,478 --> 08:37:17,000
this code yourself but let me do a

13717
08:37:14,398 --> 08:37:20,120
proper version recursively of this code

13718
08:37:17,000 --> 08:37:21,840
as follows let me go back into the code

13719
08:37:20,120 --> 08:37:24,200
here let me go ahead and not just

13720
08:37:21,840 --> 08:37:26,080
blindly start drawing one then two then

13721
08:37:24,200 --> 08:37:28,840
three layers of bricks let me prompt the

13722
08:37:26,080 --> 08:37:31,600
human as before for the height of the

13723
08:37:28,840 --> 08:37:33,798
pyramid they want using our get in

13724
08:37:31,600 --> 08:37:35,680
function and now let me call draw of

13725
08:37:33,798 --> 08:37:38,160
height again so now I'm going back to

13726
08:37:35,680 --> 08:37:40,558
the looplike version but instead of

13727
08:37:38,160 --> 08:37:43,440
using a loop now this is where recursion

13728
08:37:40,558 --> 08:37:46,718
gets rather elegant if you will let me

13729
08:37:43,440 --> 08:37:48,600
go ahead and execute and code uh the

13730
08:37:46,718 --> 08:37:52,080
draw function as

13731
08:37:48,600 --> 08:37:53,877
follows per your definition if a pyramid

13732
08:37:52,080 --> 08:37:56,360
of height four is really just a pyramid

13733
08:37:53,878 --> 08:37:57,878
of height three plus another row well

13734
08:37:56,360 --> 08:38:00,558
let's take that literally let me go back

13735
08:37:57,878 --> 08:38:02,840
to my code and if you want to draw a

13736
08:38:00,558 --> 08:38:05,398
pyramid of height four well go right

13737
08:38:02,840 --> 08:38:07,760
ahead and draw a pyramid of height uh

13738
08:38:05,398 --> 08:38:09,760
three first or more generally n minus

13739
08:38:07,760 --> 08:38:11,920
one but what's the second step well once

13740
08:38:09,760 --> 08:38:14,237
you've drawn a pyramid of height three

13741
08:38:11,920 --> 08:38:15,920
draw an extra row so I at least have to

13742
08:38:14,238 --> 08:38:18,318
bite off that part of the problem myself

13743
08:38:15,920 --> 08:38:21,478
so let me just do for in I gets zero I

13744
08:38:18,318 --> 08:38:24,120
is less than n i++ and let me the

13745
08:38:21,478 --> 08:38:26,280
programmer of this function print out my

13746
08:38:24,120 --> 08:38:28,200
hashes and then at the very bottom print

13747
08:38:26,280 --> 08:38:30,638
out a new line so the cursor moves to

13748
08:38:28,200 --> 08:38:33,680
the next line but this is kind of

13749
08:38:30,638 --> 08:38:35,520
elegant now I dare say in that draw is

13750
08:38:33,680 --> 08:38:37,760
recursive because I'm literally

13751
08:38:35,520 --> 08:38:39,558
translating from English to code this

13752
08:38:37,760 --> 08:38:41,199
idea that a pyramid of height four is

13753
08:38:39,558 --> 08:38:44,080
really just a pyramid of height three so

13754
08:38:41,200 --> 08:38:46,280
I do that first and I'm sort of trusting

13755
08:38:44,080 --> 08:38:48,360
that this will work then I just have to

13756
08:38:46,280 --> 08:38:50,079
lay one more layer of bricks four of

13757
08:38:48,360 --> 08:38:52,238
them so if n is four this is just a

13758
08:38:50,080 --> 08:38:54,920
simple for Loop Allah week one that will

13759
08:38:52,238 --> 08:38:56,840
print out an additional layer but this

13760
08:38:54,920 --> 08:39:00,679
of course is going to be problematic

13761
08:38:56,840 --> 08:39:03,558
eventually why it's not done yet this

13762
08:39:00,680 --> 08:39:06,360
program how many times will draw call

13763
08:39:03,558 --> 08:39:06,360
itself in this

13764
08:39:06,638 --> 08:39:10,718
model infinitely many times

13765
08:39:12,238 --> 08:39:16,398
why yeah there's no there's no

13766
08:39:14,360 --> 08:39:18,680
equivalent of quit like if you've

13767
08:39:16,398 --> 08:39:20,318
printed enough already then quit well

13768
08:39:18,680 --> 08:39:22,160
how do we capture that well I don't

13769
08:39:20,318 --> 08:39:23,600
think we want this to go negative right

13770
08:39:22,160 --> 08:39:26,280
it would make no sense to draw a

13771
08:39:23,600 --> 08:39:28,958
negative height pyramid so I think we

13772
08:39:26,280 --> 08:39:32,039
can just pluck off as the programmer a

13773
08:39:28,958 --> 08:39:33,717
an easy case an easy answer a so-called

13774
08:39:32,040 --> 08:39:35,840
base case and I'm just going to do this

13775
08:39:33,718 --> 08:39:39,398
at the top of my draw function let me

13776
08:39:35,840 --> 08:39:42,318
just say if n is less than or heck less

13777
08:39:39,398 --> 08:39:44,440
than or equal to zero that's it go ahead

13778
08:39:42,318 --> 08:39:47,440
and just return there's nothing more to

13779
08:39:44,440 --> 08:39:50,557
do and that simple condition technically

13780
08:39:47,440 --> 08:39:52,958
known as a base case will ensure that

13781
08:39:50,558 --> 08:39:55,440
the code doesn't run forever why well

13782
08:39:52,958 --> 08:39:57,760
suppose that draw uh is called with an

13783
08:39:55,440 --> 08:39:59,760
argument of four four is of course not

13784
08:39:57,760 --> 08:40:01,557
less than zero so we don't return but we

13785
08:39:59,760 --> 08:40:02,600
do draw a pyramid of height three and

13786
08:40:01,558 --> 08:40:04,558
here's where things get a little

13787
08:40:02,600 --> 08:40:07,359
mentally tricky you don't move on to

13788
08:40:04,558 --> 08:40:09,238
line 20 until draw has been called so

13789
08:40:07,360 --> 08:40:11,478
when draw is called with an argument of

13790
08:40:09,238 --> 08:40:13,160
three it's as though you're executing

13791
08:40:11,478 --> 08:40:14,680
from the top of this function again

13792
08:40:13,160 --> 08:40:18,000
three is not less than zero so what do

13793
08:40:14,680 --> 08:40:19,958
you do you draw two okay how do you draw

13794
08:40:18,000 --> 08:40:22,318
two well two is not less than zero so

13795
08:40:19,958 --> 08:40:25,039
you don't return so you draw one got to

13796
08:40:22,318 --> 08:40:26,360
be careful here draw one and now we go

13797
08:40:25,040 --> 08:40:28,280
ahead back to the beginning how do you

13798
08:40:26,360 --> 08:40:32,200
draw One well one is not less than zero

13799
08:40:28,280 --> 08:40:33,638
so you don't return you draw height zero

13800
08:40:32,200 --> 08:40:36,600
how do you draw height zero wait a

13801
08:40:33,638 --> 08:40:39,120
minute 0o is less than or equal to zero

13802
08:40:36,600 --> 08:40:41,079
and you return and so it's kind of like

13803
08:40:39,120 --> 08:40:43,237
this mental stack this to-do list you

13804
08:40:41,080 --> 08:40:45,120
keep postponing executing these lower

13805
08:40:43,238 --> 08:40:46,878
lines of code because you keep

13806
08:40:45,120 --> 08:40:49,798
restarting restarting restarting the

13807
08:40:46,878 --> 08:40:51,440
draw function until finally one of those

13808
08:40:49,798 --> 08:40:53,878
function calls says there's nothing to

13809
08:40:51,440 --> 08:40:56,039
do return and now the whole thing starts

13810
08:40:53,878 --> 08:40:57,638
to unravel if you will and you pick back

13811
08:40:56,040 --> 08:40:59,600
up where you left off and this is

13812
08:40:57,638 --> 08:41:00,958
perhaps the best uh scenario we won't do

13813
08:40:59,600 --> 08:41:03,318
it in class but if you'd like to wrestle

13814
08:41:00,958 --> 08:41:05,717
through this on your own using debug 50

13815
08:41:03,318 --> 08:41:07,680
to keep stepping into step into step

13816
08:41:05,718 --> 08:41:09,638
into each of those lines logically

13817
08:41:07,680 --> 08:41:11,520
you'll see exactly what's actually

13818
08:41:09,638 --> 08:41:14,039
happening so let me go to my terminal

13819
08:41:11,520 --> 08:41:15,920
and do make recursion which is now this

13820
08:41:14,040 --> 08:41:18,200
correct version of the code do/

13821
08:41:15,920 --> 08:41:21,000
recursion let's type in a height of four

13822
08:41:18,200 --> 08:41:23,798
and voila now we have that same pyramid

13823
08:41:21,000 --> 08:41:25,360
not using iteration per se though

13824
08:41:23,798 --> 08:41:27,520
admittedly we're using iteration to

13825
08:41:25,360 --> 08:41:31,120
print the additional layer we're now

13826
08:41:27,520 --> 08:41:32,760
using draw recursively to print all of

13827
08:41:31,120 --> 08:41:35,079
the smaller pyramids that need come

13828
08:41:32,760 --> 08:41:35,079
before

13829
08:41:36,318 --> 08:41:40,478
it no question is can you only use

13830
08:41:38,638 --> 08:41:42,638
recursion with a void function no not at

13831
08:41:40,478 --> 08:41:44,160
all in fact it's very common to have a

13832
08:41:42,638 --> 08:41:46,478
return value like an integer or

13833
08:41:44,160 --> 08:41:48,360
something else so that uh you can

13834
08:41:46,478 --> 08:41:50,878
actually do something constructively

13835
08:41:48,360 --> 08:41:53,160
with that actual value other questions

13836
08:41:50,878 --> 08:41:53,160
on

13837
08:41:53,200 --> 08:41:56,718
this say a little

13838
08:41:56,760 --> 08:42:03,519
lad when is line 21 getting executed so

13839
08:42:00,200 --> 08:42:04,718
if you continue to UNR let me uh scroll

13840
08:42:03,520 --> 08:42:09,680
down a bit more so you can see the top

13841
08:42:04,718 --> 08:42:14,360
of the code so line 21 will be executed

13842
08:42:09,680 --> 08:42:16,878
once line 19 is done executing itself

13843
08:42:14,360 --> 08:42:20,520
now in the story I told we kept calling

13844
08:42:16,878 --> 08:42:22,600
draw again again again but as soon as

13845
08:42:20,520 --> 08:42:25,318
one of those function calls where n

13846
08:42:22,600 --> 08:42:27,557
equals z returns immediately then we

13847
08:42:25,318 --> 08:42:28,798
don't keep drawing again and again so

13848
08:42:27,558 --> 08:42:31,638
now if you kind of think of the process

13849
08:42:28,798 --> 08:42:35,717
as reversing then you continue to line

13850
08:42:31,638 --> 08:42:38,760
21 then a line 21 again then line 21

13851
08:42:35,718 --> 08:42:39,878
again and as the sort of logic unravels

13852
08:42:38,760 --> 08:42:41,160
and next week we'll actually paint a

13853
08:42:39,878 --> 08:42:43,920
picture of what's actually happening in

13854
08:42:41,160 --> 08:42:45,718
the computer's memory but for now it's

13855
08:42:43,920 --> 08:42:47,039
just it's very similar to the pseudo

13856
08:42:45,718 --> 08:42:48,798
code for the phone book you're just

13857
08:42:47,040 --> 08:42:51,040
searching again and again but you're

13858
08:42:48,798 --> 08:42:54,079
waiting until the very end to get back

13859
08:42:51,040 --> 08:42:55,558
the final result uh can Google Now whom

13860
08:42:54,080 --> 08:42:57,840
I keep mentioning by coincidence today

13861
08:42:55,558 --> 08:43:01,280
is full of programmers of course um

13862
08:42:57,840 --> 08:43:03,280
here's a fun exercise let me uh go back

13863
08:43:01,280 --> 08:43:04,958
to a browser I'm going to go ahead and

13864
08:43:03,280 --> 08:43:06,760
search for recursion because I want to

13865
08:43:04,958 --> 08:43:08,760
learn a little something about recursion

13866
08:43:06,760 --> 08:43:11,440
uh here is kind of an internet meme or

13867
08:43:08,760 --> 08:43:16,519
joke if I zoom in here the engineers at

13868
08:43:11,440 --> 08:43:16,520
Google are kind of funny funny see

13869
08:43:17,280 --> 08:43:22,600
why ah there we go yes yes this is

13870
08:43:21,280 --> 08:43:24,237
recursion and there's going to be so

13871
08:43:22,600 --> 08:43:25,877
many memes you'll come across now where

13872
08:43:24,238 --> 08:43:27,718
recursion like if you've ever pointed a

13873
08:43:25,878 --> 08:43:29,120
camera at the TV that's showing the

13874
08:43:27,718 --> 08:43:30,680
camera and you sort of see yourself for

13875
08:43:29,120 --> 08:43:32,958
the image again and again that's really

13876
08:43:30,680 --> 08:43:34,398
recursion and in that case it only stops

13877
08:43:32,958 --> 08:43:37,120
once you hit the base case of a single

13878
08:43:34,398 --> 08:43:38,878
Pixel um but this is a very funny joke

13879
08:43:37,120 --> 08:43:41,557
in some circles uh when it comes to

13880
08:43:38,878 --> 08:43:43,798
recursion uh and Google so how can we

13881
08:43:41,558 --> 08:43:47,000
actually use Google or rather how can we

13882
08:43:43,798 --> 08:43:49,680
actually use recursion constructively

13883
08:43:47,000 --> 08:43:51,398
well let me propose that we actually

13884
08:43:49,680 --> 08:43:53,840
introduce a third and final algorithm

13885
08:43:51,398 --> 08:43:56,360
for sorting that hopefully does better

13886
08:43:53,840 --> 08:43:58,798
than the two sorts thus far we've done

13887
08:43:56,360 --> 08:44:00,160
selection sort and bubble sort bubble

13888
08:43:58,798 --> 08:44:02,000
sort we liked a little better at least

13889
08:44:00,160 --> 08:44:03,600
in so far is in the best case where the

13890
08:44:02,000 --> 08:44:04,878
list is already sorted bubble sort is at

13891
08:44:03,600 --> 08:44:07,280
least smarter and it will actually

13892
08:44:04,878 --> 08:44:09,600
terminate early giving us a better lower

13893
08:44:07,280 --> 08:44:11,717
Bound in terms of our Omega notation but

13894
08:44:09,600 --> 08:44:13,717
it turns out that recursion and this is

13895
08:44:11,718 --> 08:44:15,280
not necessarily a feature of recursion

13896
08:44:13,718 --> 08:44:17,080
but something we can now leverage it

13897
08:44:15,280 --> 08:44:18,478
turns out using recursion we can take a

13898
08:44:17,080 --> 08:44:21,280
fundamentally different approach to

13899
08:44:18,478 --> 08:44:24,237
sorting a whole bunch of numbers in such

13900
08:44:21,280 --> 08:44:26,680
a way that we can do far fewer

13901
08:44:24,238 --> 08:44:29,520
comparisons and ideally speed up our

13902
08:44:26,680 --> 08:44:31,360
final results so here is the pseudo code

13903
08:44:29,520 --> 08:44:33,360
for what we're about to see for

13904
08:44:31,360 --> 08:44:36,478
something called merge sort and it

13905
08:44:33,360 --> 08:44:39,558
really is this tur sort the left half of

13906
08:44:36,478 --> 08:44:42,040
numbers sort the right half of numbers

13907
08:44:39,558 --> 08:44:44,798
merge the sorted halves right this is

13908
08:44:42,040 --> 08:44:46,440
almost sort of non sensical because I uh

13909
08:44:44,798 --> 08:44:48,440
if you're asked for an algorithm to sort

13910
08:44:46,440 --> 08:44:50,079
and you respond with well sort the left

13911
08:44:48,440 --> 08:44:51,680
half sort the right half like that's

13912
08:44:50,080 --> 08:44:53,080
being sort of difficult because well I'm

13913
08:44:51,680 --> 08:44:54,440
asking you for a sorting algorithm

13914
08:44:53,080 --> 08:44:56,600
you're just telling me to sort the left

13915
08:44:54,440 --> 08:44:58,958
half and the right half but implicit in

13916
08:44:56,600 --> 08:45:01,000
that last line merging is a pretty

13917
08:44:58,958 --> 08:45:03,000
powerful feature of this sort now we do

13918
08:45:01,000 --> 08:45:04,920
need another base case at the top so let

13919
08:45:03,000 --> 08:45:07,280
me add this if we find ourselves with a

13920
08:45:04,920 --> 08:45:08,920
list an array of size one well that

13921
08:45:07,280 --> 08:45:10,478
array is obviously sorted if there's

13922
08:45:08,920 --> 08:45:12,079
only one element in it there's no work

13923
08:45:10,478 --> 08:45:14,318
to be done so that's going to be our

13924
08:45:12,080 --> 08:45:17,160
base case but allowing us now in just

13925
08:45:14,318 --> 08:45:19,840
these what uh four six lines of pseudo

13926
08:45:17,160 --> 08:45:21,760
code to actually sort some elements but

13927
08:45:19,840 --> 08:45:23,718
let's focus first on just a subset of

13928
08:45:21,760 --> 08:45:25,958
this let's consider for a moment what it

13929
08:45:23,718 --> 08:45:27,398
means to merge sorted have so Carter has

13930
08:45:25,958 --> 08:45:29,318
wonderfully come up to volunteer here

13931
08:45:27,398 --> 08:45:31,718
just to help us reset these numbers

13932
08:45:29,318 --> 08:45:34,440
suppose that in the middle of the story

13933
08:45:31,718 --> 08:45:36,398
we're about to tell we have two sorted

13934
08:45:34,440 --> 08:45:38,717
halves I've already sorted the left half

13935
08:45:36,398 --> 08:45:40,840
of these numbers and indeed 2 4 57 is

13936
08:45:38,718 --> 08:45:43,040
sorted from smallest to largest and the

13937
08:45:40,840 --> 08:45:46,318
right half appears to be already sorted

13938
08:45:43,040 --> 08:45:48,238
0136 already sorted so in my pseudo code

13939
08:45:46,318 --> 08:45:49,958
we're already done sorting the left half

13940
08:45:48,238 --> 08:45:52,478
and the right half somehow but we'll see

13941
08:45:49,958 --> 08:45:54,557
how in a moment well how do I go about

13942
08:45:52,478 --> 08:45:56,360
merging these two halves well because

13943
08:45:54,558 --> 08:45:58,638
they're sorted already and you want to

13944
08:45:56,360 --> 08:46:01,878
merge them in order I think we can flip

13945
08:45:58,638 --> 08:46:04,318
down we can hide all but the first

13946
08:46:01,878 --> 08:46:07,360
numbers in each of these subl lists so

13947
08:46:04,318 --> 08:46:08,600
here we have a half that starts with two

13948
08:46:07,360 --> 08:46:09,920
and I don't really care what the other

13949
08:46:08,600 --> 08:46:12,280
numbers are because they're clearly

13950
08:46:09,920 --> 08:46:15,000
larger than two I can focus only on Two

13951
08:46:12,280 --> 08:46:16,360
And Z too zero also we know that zero is

13952
08:46:15,000 --> 08:46:17,760
the smallest there so let's just ignore

13953
08:46:16,360 --> 08:46:21,120
the numbers that Carter kindly flipped

13954
08:46:17,760 --> 08:46:23,717
down so how do I merge these two lists

13955
08:46:21,120 --> 08:46:26,397
into a new sorted larger list well I

13956
08:46:23,718 --> 08:46:28,600
compare the two on my left with the zero

13957
08:46:26,398 --> 08:46:30,878
on my right obviously which comes first

13958
08:46:28,600 --> 08:46:32,120
the zero so let me put this down here

13959
08:46:30,878 --> 08:46:34,398
and Carter if you want to give us the

13960
08:46:32,120 --> 08:46:36,557
next element now I have two sorted

13961
08:46:34,398 --> 08:46:38,958
halves but I've already plucked one off

13962
08:46:36,558 --> 08:46:40,878
so now I compare the two against the one

13963
08:46:38,958 --> 08:46:43,397
one obviously comes next so I'm going to

13964
08:46:40,878 --> 08:46:45,040
take out the one and put it in place

13965
08:46:43,398 --> 08:46:46,718
here now I'm going to compare the two

13966
08:46:45,040 --> 08:46:49,718
halves again two and three which do I

13967
08:46:46,718 --> 08:46:51,878
merge first obviously the two comes next

13968
08:46:49,718 --> 08:46:53,680
and now notice each time I do this my

13969
08:46:51,878 --> 08:46:55,440
hands are theoretically making forward

13970
08:46:53,680 --> 08:46:57,360
progress I'm not doubling back like I

13971
08:46:55,440 --> 08:46:59,397
kept doing with selection sort or bubble

13972
08:46:57,360 --> 08:47:01,798
sort back and forth back and forth my

13973
08:46:59,398 --> 08:47:03,360
fingers are constantly advancing forward

13974
08:47:01,798 --> 08:47:06,557
and that's going to be a key detail so I

13975
08:47:03,360 --> 08:47:09,120
compare four and three three obviously I

13976
08:47:06,558 --> 08:47:12,840
compare three and uh I compare four and

13977
08:47:09,120 --> 08:47:16,237
six four obviously I compare five five

13978
08:47:12,840 --> 08:47:20,040
and six five obviously and then I

13979
08:47:16,238 --> 08:47:21,600
compare seven and six six of course and

13980
08:47:20,040 --> 08:47:23,160
then lastly we have just one element

13981
08:47:21,600 --> 08:47:25,237
left and even though I'm kind of moving

13982
08:47:23,160 --> 08:47:26,798
awkwardly as a human my hands

13983
08:47:25,238 --> 08:47:28,718
technically were only moving to the

13984
08:47:26,798 --> 08:47:30,280
right I was never looping back doing

13985
08:47:28,718 --> 08:47:32,120
something again and again and that's

13986
08:47:30,280 --> 08:47:34,557
perhaps the intuition and just enough

13987
08:47:32,120 --> 08:47:37,280
room for the seven so that then is how

13988
08:47:34,558 --> 08:47:39,120
you would merge two sorted halves we

13989
08:47:37,280 --> 08:47:40,840
started with left half sorted right half

13990
08:47:39,120 --> 08:47:42,160
sorted and merging is just like what you

13991
08:47:40,840 --> 08:47:43,920
would do as a human and Carter just

13992
08:47:42,160 --> 08:47:47,680
flips the numbers down so our Focus was

13993
08:47:43,920 --> 08:47:50,318
only on the smallest elements in each

13994
08:47:47,680 --> 08:47:54,958
any questions before we Forge ahead with

13995
08:47:50,318 --> 08:47:58,040
what it means then to be merged in this

13996
08:47:54,958 --> 08:47:59,478
way so now here is an original list we

13997
08:47:58,040 --> 08:48:00,920
deliberately put it at the top because

13998
08:47:59,478 --> 08:48:03,200
there's one detail of Mer sort that's

13999
08:48:00,920 --> 08:48:04,839
key mer sort is technically going to use

14000
08:48:03,200 --> 08:48:06,238
a little more space and so whereas

14001
08:48:04,840 --> 08:48:08,238
previously we just kept moving our

14002
08:48:06,238 --> 08:48:09,680
humans around and swapping people and

14003
08:48:08,238 --> 08:48:12,040
making sure they stayed ultimately in

14004
08:48:09,680 --> 08:48:13,798
the original positions with mer sort

14005
08:48:12,040 --> 08:48:16,280
pretend ends that here's our original

14006
08:48:13,798 --> 08:48:17,958
array of uh memory I'm going to need at

14007
08:48:16,280 --> 08:48:19,199
least one other array of memory and I'm

14008
08:48:17,958 --> 08:48:21,160
going to cheat and I'm going to use even

14009
08:48:19,200 --> 08:48:22,840
more memory but technically I could

14010
08:48:21,160 --> 08:48:24,840
actually go back and forth between one

14011
08:48:22,840 --> 08:48:26,558
array and a secondary array but it isn't

14012
08:48:24,840 --> 08:48:29,798
going to it is going to take me more

14013
08:48:26,558 --> 08:48:32,840
space so how do I go about implementing

14014
08:48:29,798 --> 08:48:35,079
merge sort on this Al on this code well

14015
08:48:32,840 --> 08:48:37,238
let's consider this here's a array of

14016
08:48:35,080 --> 08:48:38,878
size eight if only one number quit

14017
08:48:37,238 --> 08:48:40,920
obviously not applicable so let's focus

14018
08:48:38,878 --> 08:48:42,680
on the juicy part there sort the left

14019
08:48:40,920 --> 08:48:44,039
half of the numbers all right how do I

14020
08:48:42,680 --> 08:48:45,558
sort the left half of the numbers I'm

14021
08:48:44,040 --> 08:48:48,520
going to just nudge them over just to be

14022
08:48:45,558 --> 08:48:51,280
clear which is the left half how here is

14023
08:48:48,520 --> 08:48:52,840
now a sub list of size four how do I

14024
08:48:51,280 --> 08:48:55,478
sort the left

14025
08:48:52,840 --> 08:48:57,718
half well do I have an algorithm for

14026
08:48:55,478 --> 08:48:59,280
sorting yeah what do I do here's a list

14027
08:48:57,718 --> 08:49:02,680
of size four how do I sort it what's

14028
08:48:59,280 --> 08:49:04,638
step one sort the left half so I now

14029
08:49:02,680 --> 08:49:07,958
sort of conceptually in my mind take

14030
08:49:04,638 --> 08:49:10,397
this sublist of size four and I sort it

14031
08:49:07,958 --> 08:49:11,798
by first sorting the left half focusing

14032
08:49:10,398 --> 08:49:14,120
now on the seven and two all right

14033
08:49:11,798 --> 08:49:16,717
here's a list of size two how do I sort

14034
08:49:14,120 --> 08:49:20,520
a list of size

14035
08:49:16,718 --> 08:49:22,680
two sorry I think we just keep following

14036
08:49:20,520 --> 08:49:24,958
our instruction sort the left half all

14037
08:49:22,680 --> 08:49:27,798
right here is a list of size one how do

14038
08:49:24,958 --> 08:49:30,680
I sort a list of size

14039
08:49:27,798 --> 08:49:33,160
one I'm done like it's done so I leave

14040
08:49:30,680 --> 08:49:35,280
this alone what was the next step in the

14041
08:49:33,160 --> 08:49:37,360
story I've just sorted the left half of

14042
08:49:35,280 --> 08:49:40,478
the left half of the left half what

14043
08:49:37,360 --> 08:49:43,120
comes next I sort the right half of the

14044
08:49:40,478 --> 08:49:45,680
left half of the left half and I'm done

14045
08:49:43,120 --> 08:49:49,600
cuz it's just a list of size one what

14046
08:49:45,680 --> 08:49:50,878
comes after this merge so this is where

14047
08:49:49,600 --> 08:49:52,717
it gets a little trippy because you have

14048
08:49:50,878 --> 08:49:54,638
to remember where we're pausing the

14049
08:49:52,718 --> 08:49:56,318
story to do things recursively again and

14050
08:49:54,638 --> 08:49:58,160
again but if I've just sorted the left

14051
08:49:56,318 --> 08:50:00,200
half and I've just sorted the right half

14052
08:49:58,160 --> 08:50:02,318
now I merge them together this is a

14053
08:50:00,200 --> 08:50:04,398
super short list so we don't need um uh

14054
08:50:02,318 --> 08:50:06,680
Carter's help here as before but I think

14055
08:50:04,398 --> 08:50:07,840
the first number I take here is the two

14056
08:50:06,680 --> 08:50:09,878
and then the second number I take

14057
08:50:07,840 --> 08:50:12,360
because it's the only option is the

14058
08:50:09,878 --> 08:50:15,000
seven but what's nice now is that notice

14059
08:50:12,360 --> 08:50:17,558
the left half of the left half is indeed

14060
08:50:15,000 --> 08:50:19,160
sorted because I trivially sorted the

14061
08:50:17,558 --> 08:50:20,760
left half of it and the right half of it

14062
08:50:19,160 --> 08:50:23,000
but then merging is really where the

14063
08:50:20,760 --> 08:50:24,877
magic happens all right again if you rem

14064
08:50:23,000 --> 08:50:27,238
if you rewind now in your mind if I've

14065
08:50:24,878 --> 08:50:29,360
just sorted the left half of the left

14066
08:50:27,238 --> 08:50:33,200
half what happens

14067
08:50:29,360 --> 08:50:35,680
next sort the right half of the left

14068
08:50:33,200 --> 08:50:37,760
half so again you kind of rewind in time

14069
08:50:35,680 --> 08:50:39,798
so how do I do this I've got a list of

14070
08:50:37,760 --> 08:50:42,600
size two I sort the left half the just

14071
08:50:39,798 --> 08:50:45,360
the five done sort the right half four

14072
08:50:42,600 --> 08:50:48,160
done now the interesting part I merge

14073
08:50:45,360 --> 08:50:50,878
the left half and the right half of the

14074
08:50:48,160 --> 08:50:54,398
right half of the left half so what do I

14075
08:50:50,878 --> 08:50:56,238
do four comes down here five comes down

14076
08:50:54,398 --> 08:50:59,680
here and

14077
08:50:56,238 --> 08:51:02,238
now notice what I have left half is

14078
08:50:59,680 --> 08:51:04,680
sorted right half is sorted if you

14079
08:51:02,238 --> 08:51:07,040
rewind in time where is my next step

14080
08:51:04,680 --> 08:51:08,760
three merge the two halves and so this

14081
08:51:07,040 --> 08:51:10,238
is what Carter helped me do before let's

14082
08:51:08,760 --> 08:51:11,920
focus only on the smallest elements just

14083
08:51:10,238 --> 08:51:13,878
so there's less distraction I compare

14084
08:51:11,920 --> 08:51:16,160
the two and the four two comes first so

14085
08:51:13,878 --> 08:51:18,478
let's obviously put that here now I

14086
08:51:16,160 --> 08:51:20,478
compare the new beginning of this list

14087
08:51:18,478 --> 08:51:23,558
and the old beginning of this list four

14088
08:51:20,478 --> 08:51:25,237
obviously comes next and now I compare

14089
08:51:23,558 --> 08:51:27,040
the seven against the five five

14090
08:51:25,238 --> 08:51:29,080
obviously comes next and now lastly I'm

14091
08:51:27,040 --> 08:51:31,160
left with one number so now I'm down to

14092
08:51:29,080 --> 08:51:32,920
the seven so even if you've kind of lost

14093
08:51:31,160 --> 08:51:34,680
track of some of the nuances here if you

14094
08:51:32,920 --> 08:51:36,440
just kind of take a step back we have

14095
08:51:34,680 --> 08:51:38,798
the original right half here still

14096
08:51:36,440 --> 08:51:42,478
untouched but the left half of the

14097
08:51:38,798 --> 08:51:44,557
original input is now indeed sorted all

14098
08:51:42,478 --> 08:51:46,397
by way of doing sorting left half right

14099
08:51:44,558 --> 08:51:48,558
half left half right half but with those

14100
08:51:46,398 --> 08:51:51,680
merges in between all right so if we've

14101
08:51:48,558 --> 08:51:53,478
just sorted the left half we rewind all

14102
08:51:51,680 --> 08:51:56,360
the way to the beginning what do I now

14103
08:51:53,478 --> 08:51:58,200
do all right so sort the right half so

14104
08:51:56,360 --> 08:52:00,160
sort the right half how do I sort a list

14105
08:51:58,200 --> 08:52:02,280
of size four well I first sort the left

14106
08:52:00,160 --> 08:52:04,798
half the one and the six how do I sort a

14107
08:52:02,280 --> 08:52:06,397
list of size two you sort the left half

14108
08:52:04,798 --> 08:52:08,717
just the number one obviously there's no

14109
08:52:06,398 --> 08:52:12,398
work to be done done sorting the left

14110
08:52:08,718 --> 08:52:17,440
half six done sorting the right half now

14111
08:52:12,398 --> 08:52:20,080
what do I do I merge the left half here

14112
08:52:17,440 --> 08:52:21,798
with the right half here and that one's

14113
08:52:20,080 --> 08:52:24,200
pretty straightforward now what do I do

14114
08:52:21,798 --> 08:52:25,680
I've just merged so now I sorted I've

14115
08:52:24,200 --> 08:52:27,600
just sorted the left half of the right

14116
08:52:25,680 --> 08:52:30,558
half so now I sort the right half of the

14117
08:52:27,600 --> 08:52:32,840
right half so I consider the zero done I

14118
08:52:30,558 --> 08:52:35,000
consider the three done I now merge

14119
08:52:32,840 --> 08:52:37,840
these two together zero of course comes

14120
08:52:35,000 --> 08:52:39,600
first then comes the three and now I'm

14121
08:52:37,840 --> 08:52:42,040
at the point of the story where I've

14122
08:52:39,600 --> 08:52:44,359
sorted the left half of the right half

14123
08:52:42,040 --> 08:52:47,080
and the right half of the right half so

14124
08:52:44,360 --> 08:52:48,798
step three is merge and I'll do it again

14125
08:52:47,080 --> 08:52:51,398
like we did with Carter all right one

14126
08:52:48,798 --> 08:52:53,280
and zero obviously the zero comes first

14127
08:52:51,398 --> 08:52:55,360
now compare the one and the three

14128
08:52:53,280 --> 08:52:56,958
obviously the one comes first compare

14129
08:52:55,360 --> 08:52:59,920
the six and the three obviously the

14130
08:52:56,958 --> 08:53:03,237
three and then lastly the sixth so now

14131
08:52:59,920 --> 08:53:04,958
where are we we've taken the left half

14132
08:53:03,238 --> 08:53:06,920
of the whole thing and sorted the left

14133
08:53:04,958 --> 08:53:09,199
and sorted it we then took the right

14134
08:53:06,920 --> 08:53:11,717
half of the whole thing and sorted it so

14135
08:53:09,200 --> 08:53:14,718
now we're at lastly step three for the

14136
08:53:11,718 --> 08:53:16,718
last last time what do we do merge and

14137
08:53:14,718 --> 08:53:19,440
so just to be consistent let me push

14138
08:53:16,718 --> 08:53:21,040
these down and let's compare left hand

14139
08:53:19,440 --> 08:53:22,717
to right hand noticing that they only

14140
08:53:21,040 --> 08:53:25,120
make forward progress none of this back

14141
08:53:22,718 --> 08:53:27,160
and forth comparisons two and zero of

14142
08:53:25,120 --> 08:53:30,120
course the zero so we'll put that in

14143
08:53:27,160 --> 08:53:33,318
place two and one of course the one so

14144
08:53:30,120 --> 08:53:35,958
we put that in place two and three we

14145
08:53:33,318 --> 08:53:38,638
merge in of course the two in this case

14146
08:53:35,958 --> 08:53:42,160
four and three we now merge in the three

14147
08:53:38,638 --> 08:53:45,360
in this case four and six we now merge

14148
08:53:42,160 --> 08:53:49,238
of course the four in place and now we

14149
08:53:45,360 --> 08:53:49,238
compare five and six we keep the

14150
08:53:50,558 --> 08:53:57,160
five

14151
08:53:53,360 --> 08:54:01,280
bug okay well pretend that the five is

14152
08:53:57,160 --> 08:54:04,478
on uh oh this is why all right so now we

14153
08:54:01,280 --> 08:54:07,920
compare the seven and the six sixth is

14154
08:54:04,478 --> 08:54:10,120
gone and lastly seven is the last one in

14155
08:54:07,920 --> 08:54:11,478
place and even though I grant that of

14156
08:54:10,120 --> 08:54:13,478
all the algorithms this is probably the

14157
08:54:11,478 --> 08:54:15,840
hardest one to stay on top of especially

14158
08:54:13,478 --> 08:54:18,318
when I'm doing it as a voiceover realize

14159
08:54:15,840 --> 08:54:20,360
that what we've just done is only those

14160
08:54:18,318 --> 08:54:22,200
three steps recursively we started with

14161
08:54:20,360 --> 08:54:23,958
a list of size eight we sorted the left

14162
08:54:22,200 --> 08:54:25,680
half we sorted the right half and then

14163
08:54:23,958 --> 08:54:27,440
we merged the two together but if you go

14164
08:54:25,680 --> 08:54:29,760
down each of those rabbit holes so to

14165
08:54:27,440 --> 08:54:31,237
speak sorting the left half involves

14166
08:54:29,760 --> 08:54:33,120
sorting the left half of the left half

14167
08:54:31,238 --> 08:54:35,558
and the right half of the left half and

14168
08:54:33,120 --> 08:54:37,478
so forth but this germ of an idea of

14169
08:54:35,558 --> 08:54:39,638
really dividing and conquering the

14170
08:54:37,478 --> 08:54:41,397
problem not such that you're having the

14171
08:54:39,638 --> 08:54:44,039
problem and only dealing with one half

14172
08:54:41,398 --> 08:54:45,760
clearly we're sorting one half and the

14173
08:54:44,040 --> 08:54:48,200
other half and merging them together

14174
08:54:45,760 --> 08:54:50,877
ultimately it does still lead us to the

14175
08:54:48,200 --> 08:54:53,040
same solution and if we visualize the

14176
08:54:50,878 --> 08:54:55,760
remnants of this now if I depict this as

14177
08:54:53,040 --> 08:54:57,318
follows where on the screen here you see

14178
08:54:55,760 --> 08:54:59,478
where the numbers originally started in

14179
08:54:57,318 --> 08:55:01,360
the top row from left to right

14180
08:54:59,478 --> 08:55:03,520
essentially even though this is in a

14181
08:55:01,360 --> 08:55:06,680
different order I divided that list of

14182
08:55:03,520 --> 08:55:08,718
size eight ultimately into eight lists

14183
08:55:06,680 --> 08:55:10,360
of size one and that's where the base

14184
08:55:08,718 --> 08:55:12,520
case kicked in and just said okay we're

14185
08:55:10,360 --> 08:55:15,318
done sorting that and after that

14186
08:55:12,520 --> 08:55:17,478
logically I then sorted I merged two

14187
08:55:15,318 --> 08:55:19,280
lists of size one into many lists of

14188
08:55:17,478 --> 08:55:21,440
size two and those lists of size two

14189
08:55:19,280 --> 08:55:23,760
into lists of size four and then finally

14190
08:55:21,440 --> 08:55:27,359
the list of size four into one big list

14191
08:55:23,760 --> 08:55:28,877
sorted of size eight and so I put forth

14192
08:55:27,360 --> 08:55:31,360
this picture with the little line

14193
08:55:28,878 --> 08:55:34,798
indicators here because how many times

14194
08:55:31,360 --> 08:55:36,958
did I divide divide divide in half or

14195
08:55:34,798 --> 08:55:40,039
really double double double so exponent

14196
08:55:36,958 --> 08:55:43,318
is the opposite oh spoiler uh how many

14197
08:55:40,040 --> 08:55:45,000
times did I divide so three concretely

14198
08:55:43,318 --> 08:55:48,200
but if there's eight elements total and

14199
08:55:45,000 --> 08:55:50,680
there's N More generally it really is a

14200
08:55:48,200 --> 08:55:52,398
matter of dividing and conquering login

14201
08:55:50,680 --> 08:55:54,280
times you start this and you can divide

14202
08:55:52,398 --> 08:55:55,920
one two three times login times or

14203
08:55:54,280 --> 08:55:58,318
conversely you can start here and

14204
08:55:55,920 --> 08:56:01,120
exponentially uh double double double

14205
08:55:58,318 --> 08:56:04,000
three times which is log n but on every

14206
08:56:01,120 --> 08:56:06,318
row every shelf literally I made a fuss

14207
08:56:04,000 --> 08:56:08,238
about pointing my hands only from the

14208
08:56:06,318 --> 08:56:09,600
left to the right constantly advancing

14209
08:56:08,238 --> 08:56:12,398
them such that every time I did those

14210
08:56:09,600 --> 08:56:14,237
merges I touched every element once and

14211
08:56:12,398 --> 08:56:16,920
only once there was none of this back

14212
08:56:14,238 --> 08:56:21,318
and forth back and forth on stage so if

14213
08:56:16,920 --> 08:56:25,519
I'm doing something log n times if I'm

14214
08:56:21,318 --> 08:56:28,718
doing rather N Things log n times what

14215
08:56:25,520 --> 08:56:30,200
would be our Big O formula perhaps N

14216
08:56:28,718 --> 08:56:33,440
Things log n

14217
08:56:30,200 --> 08:56:35,318
times yeah so n log n the order of n log

14218
08:56:33,440 --> 08:56:38,079
n is indeed how we would describe the

14219
08:56:35,318 --> 08:56:40,878
running time of merge sort and so of all

14220
08:56:38,080 --> 08:56:44,120
of the sorts thus far we've seen that

14221
08:56:40,878 --> 08:56:45,878
merge sort here actually is n log n

14222
08:56:44,120 --> 08:56:47,760
which is strictly better than n squ

14223
08:56:45,878 --> 08:56:49,718
which is where both merge uh both

14224
08:56:47,760 --> 08:56:52,440
selection sort and bubble sort landed

14225
08:56:49,718 --> 08:56:54,040
but it's also slower than linear search

14226
08:56:52,440 --> 08:56:55,760
for instance but you would rather expect

14227
08:56:54,040 --> 08:56:58,478
that if you have to do a lot of work up

14228
08:56:55,760 --> 08:56:59,519
front sorting some elements versus just

14229
08:56:58,478 --> 08:57:01,160
searching them you're going to have to

14230
08:56:59,520 --> 08:57:02,680
put in more effort and so the question

14231
08:57:01,160 --> 08:57:04,398
of whether or not you should just search

14232
08:57:02,680 --> 08:57:06,478
something blindly with linear search and

14233
08:57:04,398 --> 08:57:08,680
not bother sorting it really boils down

14234
08:57:06,478 --> 08:57:10,120
to can you afford to spend this amount

14235
08:57:08,680 --> 08:57:11,638
of time and if you're the Googles of the

14236
08:57:10,120 --> 08:57:13,680
world odds are you don't want to be

14237
08:57:11,638 --> 08:57:16,600
searching their database linearly every

14238
08:57:13,680 --> 08:57:18,760
time why because you can sort it once

14239
08:57:16,600 --> 08:57:20,760
and then benefit millions billions of

14240
08:57:18,760 --> 08:57:22,397
people subsequently using something like

14241
08:57:20,760 --> 08:57:24,440
binary search or frankly in practice

14242
08:57:22,398 --> 08:57:26,080
something even fancier and faster than

14243
08:57:24,440 --> 08:57:28,160
binary search but there's always going

14244
08:57:26,080 --> 08:57:30,238
to be this tradeoff you can achieve

14245
08:57:28,160 --> 08:57:32,520
binary search only if the elements are

14246
08:57:30,238 --> 08:57:34,120
sorted how much does it cost you to sort

14247
08:57:32,520 --> 08:57:36,120
them well maybe N squared if you use

14248
08:57:34,120 --> 08:57:39,840
some of the earlier algorithms but it

14249
08:57:36,120 --> 08:57:42,079
turns out n log n is pretty fast as well

14250
08:57:39,840 --> 08:57:45,080
so at the end of the day

14251
08:57:42,080 --> 08:57:47,080
these running times involve tradeoffs

14252
08:57:45,080 --> 08:57:48,840
and indeed in merge sort 2 I should note

14253
08:57:47,080 --> 08:57:51,280
that the lower bound on merge sort is

14254
08:57:48,840 --> 08:57:52,638
also going to be Omega of n log n as

14255
08:57:51,280 --> 08:57:54,280
such we can describe it in terms of our

14256
08:57:52,638 --> 08:57:57,200
Theta notation saying that merge short

14257
08:57:54,280 --> 08:57:59,478
is indeed in Theta of n log n so

14258
08:57:57,200 --> 08:58:01,120
generally speaking probably better to

14259
08:57:59,478 --> 08:58:03,237
use something like merge sort or some

14260
08:58:01,120 --> 08:58:04,920
other algorithm that's in N log n in

14261
08:58:03,238 --> 08:58:06,680
practice most programmers are not

14262
08:58:04,920 --> 08:58:07,877
implementing these sorting algorithms

14263
08:58:06,680 --> 08:58:10,238
themselves odds are they're using a

14264
08:58:07,878 --> 08:58:11,798
library off the shelf that themselves

14265
08:58:10,238 --> 08:58:13,840
have made the decision as to which of

14266
08:58:11,798 --> 08:58:15,079
these algorithms to do but generally

14267
08:58:13,840 --> 08:58:17,398
speaking and we're seeing now this for

14268
08:58:15,080 --> 08:58:19,798
the first time if you want to improve

14269
08:58:17,398 --> 08:58:21,920
time like use less time write faster

14270
08:58:19,798 --> 08:58:24,000
code you got to pay a price and that

14271
08:58:21,920 --> 08:58:25,557
might be your human time just takes you

14272
08:58:24,000 --> 08:58:27,200
more time to code up something more

14273
08:58:25,558 --> 08:58:29,760
sophisticated more difficult to

14274
08:58:27,200 --> 08:58:32,398
implement or you need to spend something

14275
08:58:29,760 --> 08:58:33,877
like space and as these shelves suggest

14276
08:58:32,398 --> 08:58:35,638
that too is one of the key details of

14277
08:58:33,878 --> 08:58:38,040
merge sort you can't just have the

14278
08:58:35,638 --> 08:58:40,478
elements swapping in place you need at

14279
08:58:38,040 --> 08:58:42,280
least an auxiliary array so that when

14280
08:58:40,478 --> 08:58:44,040
you do the merging you have a place to

14281
08:58:42,280 --> 08:58:45,878
put them and this is excessive this

14282
08:58:44,040 --> 08:58:47,360
amount of memory I could have just gone

14283
08:58:45,878 --> 08:58:48,520
back and forth between top shelf and

14284
08:58:47,360 --> 08:58:50,520
bottom shelf but it's a little more

14285
08:58:48,520 --> 08:58:52,878
interesting to go top down but you do

14286
08:58:50,520 --> 08:58:54,878
need more space back in the day decades

14287
08:58:52,878 --> 08:58:56,318
ago space was really expensive and so

14288
08:58:54,878 --> 08:58:59,040
you know what it might have been better

14289
08:58:56,318 --> 08:59:00,958
to not use merge sort use bubble sort or

14290
08:58:59,040 --> 08:59:03,080
uh selection sort even or some other

14291
08:59:00,958 --> 08:59:04,798
algorithm alog together nowadays space

14292
08:59:03,080 --> 08:59:06,318
is relatively cheap and so these are

14293
08:59:04,798 --> 08:59:08,920
more acceptable trade-offs but it

14294
08:59:06,318 --> 08:59:10,398
totally depends on the application the

14295
08:59:08,920 --> 08:59:12,000
very last thing we thought we'd do is

14296
08:59:10,398 --> 08:59:13,478
show you an actual compar comparison of

14297
08:59:12,000 --> 08:59:15,000
some of these sorting algorithms it's

14298
08:59:13,478 --> 08:59:18,160
about 60 seconds long and it will

14299
08:59:15,000 --> 08:59:21,080
compare for you uh selection sort bubble

14300
08:59:18,160 --> 08:59:23,238
sort and merge sort in parallel

14301
08:59:21,080 --> 08:59:25,120
simultaneously uh with some fun sorting

14302
08:59:23,238 --> 08:59:27,878
music showing you ultimately what it

14303
08:59:25,120 --> 08:59:30,798
really means to be an O of n s or better

14304
08:59:27,878 --> 08:59:35,878
yet Big O of n

14305
08:59:30,798 --> 08:59:38,649
Logan selection on the top bubble on the

14306
08:59:35,878 --> 08:59:40,360
bottom merge in the

14307
08:59:38,650 --> 08:59:42,500
[Music]

14308
08:59:40,360 --> 08:59:49,160
middle

14309
08:59:42,500 --> 08:59:49,160
[Music]

14310
09:00:10,780 --> 09:00:14,168
[Applause]

14311
09:00:16,570 --> 09:00:23,509
[Music]

14312
09:00:32,558 --> 09:00:37,160
all right that's it for cs50 we'll see

14313
09:00:34,798 --> 09:00:37,160
you next

14314
09:00:38,260 --> 09:00:42,440
[Music]

14315
09:00:40,238 --> 09:00:46,349
time

14316
09:00:42,440 --> 09:00:46,349
[Music]

14317
09:00:52,340 --> 09:01:00,669
[Music]

14318
09:01:16,950 --> 09:01:35,589
[Music]

14319
09:01:40,160 --> 09:01:43,160
e

14320
09:01:49,440 --> 09:01:52,550
[Music]

14321
09:01:59,370 --> 09:02:10,889
[Music]

14322
09:02:18,830 --> 09:02:30,520
[Music]

14323
09:02:27,600 --> 09:02:32,440
all right this is cs50 and this is week

14324
09:02:30,520 --> 09:02:34,200
four and if you think back a few weeks

14325
09:02:32,440 --> 09:02:35,600
ago already in week zero we started

14326
09:02:34,200 --> 09:02:37,958
talking about like what images are and

14327
09:02:35,600 --> 09:02:40,359
we talked about representation of images

14328
09:02:37,958 --> 09:02:41,877
as this grid of pixels and each pixel

14329
09:02:40,360 --> 09:02:43,558
has like some pattern of bits that

14330
09:02:41,878 --> 09:02:45,000
defines its color well it turns out

14331
09:02:43,558 --> 09:02:46,760
today we'll take a deeper look

14332
09:02:45,000 --> 09:02:49,160
underneath the hood at how things like

14333
09:02:46,760 --> 09:02:50,798
images and so much more is actually

14334
09:02:49,160 --> 09:02:53,878
implemented using just these zeros and

14335
09:02:50,798 --> 09:02:55,478
ones and how now as a programmer you can

14336
09:02:53,878 --> 09:02:57,680
actually harness that for better for

14337
09:02:55,478 --> 09:02:59,397
worse to better understand and better

14338
09:02:57,680 --> 09:03:01,080
manipulate what's going on inside of a

14339
09:02:59,398 --> 09:03:03,280
computer's memory using a language like

14340
09:03:01,080 --> 09:03:04,520
C in fact even this bowl of stress balls

14341
09:03:03,280 --> 09:03:06,160
that we keep happening is just a

14342
09:03:04,520 --> 09:03:08,200
photograph of course but if you think

14343
09:03:06,160 --> 09:03:10,238
back to week zero if you sort of enhance

14344
09:03:08,200 --> 09:03:12,040
enhance enhance this image like they do

14345
09:03:10,238 --> 09:03:13,798
in the movies it actually doesn't work

14346
09:03:12,040 --> 09:03:16,080
out the way you would think from

14347
09:03:13,798 --> 09:03:18,638
Hollywood as I keep continue to zoom in

14348
09:03:16,080 --> 09:03:20,360
and zoom in and zoom in on a screen like

14349
09:03:18,638 --> 09:03:22,360
this you'll see that yes it gets bigger

14350
09:03:20,360 --> 09:03:24,558
but if it gets too big what do you start

14351
09:03:22,360 --> 09:03:26,558
to notice the so-called pixelation and

14352
09:03:24,558 --> 09:03:29,120
indeed you can see the individual dots

14353
09:03:26,558 --> 09:03:31,680
so next time you watch some uh show or

14354
09:03:29,120 --> 09:03:33,397
movie on uh TV that has this sort of

14355
09:03:31,680 --> 09:03:34,840
notion of enhancing you know there's

14356
09:03:33,398 --> 09:03:36,718
actually a finite limit there you can

14357
09:03:34,840 --> 09:03:38,478
only enhance so far as there's actually

14358
09:03:36,718 --> 09:03:40,478
information there but once you zoom in

14359
09:03:38,478 --> 09:03:42,079
to a certain level like this like that's

14360
09:03:40,478 --> 09:03:43,958
all that there you're not going to see

14361
09:03:42,080 --> 09:03:46,000
the glint of the suspect in some crime

14362
09:03:43,958 --> 09:03:47,840
drama in their eye just because you've

14363
09:03:46,000 --> 09:03:50,360
enhanced the image there's only a finite

14364
09:03:47,840 --> 09:03:52,798
amount of information actually there but

14365
09:03:50,360 --> 09:03:54,000
we'll see today too that by

14366
09:03:52,798 --> 09:03:55,397
understanding what's going on inside of

14367
09:03:54,000 --> 09:03:57,280
a computer's memory we can start to

14368
09:03:55,398 --> 09:03:59,558
represent and even create and code more

14369
09:03:57,280 --> 09:04:02,199
interesting things so for instance here

14370
09:03:59,558 --> 09:04:05,160
is a bit map if you will which is a term

14371
09:04:02,200 --> 09:04:06,760
of art a bit map is a type of image and

14372
09:04:05,160 --> 09:04:08,360
it's a map of bits in the sense that you

14373
09:04:06,760 --> 09:04:10,199
have this coordinate system of up top

14374
09:04:08,360 --> 09:04:12,558
down left right at least in this artist

14375
09:04:10,200 --> 09:04:15,520
representation here and suppose that

14376
09:04:12,558 --> 09:04:18,080
maybe we all defi decide as a as as the

14377
09:04:15,520 --> 09:04:20,280
world that one shall represent the color

14378
09:04:18,080 --> 09:04:23,360
white and zero shall represent the color

14379
09:04:20,280 --> 09:04:27,120
black what might this map of bits this

14380
09:04:23,360 --> 09:04:31,280
bit map actually be can you see through

14381
09:04:27,120 --> 09:04:33,039
it yeah it is indeed a smiley face so an

14382
09:04:31,280 --> 09:04:35,397
amazing eye if I actually turn all of

14383
09:04:33,040 --> 09:04:36,958
the ones to White just to visualize this

14384
09:04:35,398 --> 09:04:38,200
you'll see indeed this is what was

14385
09:04:36,958 --> 09:04:40,079
embedded there but of course on our

14386
09:04:38,200 --> 09:04:41,718
computer monitors and phones we have

14387
09:04:40,080 --> 09:04:44,040
this grid of square is this grid of

14388
09:04:41,718 --> 09:04:45,840
pixels so indeed if you were to actually

14389
09:04:44,040 --> 09:04:47,558
see on your screen a smiley face like a

14390
09:04:45,840 --> 09:04:49,000
black and white one at that what's

14391
09:04:47,558 --> 09:04:50,680
probably going on underneath the hood is

14392
09:04:49,000 --> 09:04:53,200
just some pattern of zeros and ones and

14393
09:04:50,680 --> 09:04:55,558
maybe single bits one bit color if you

14394
09:04:53,200 --> 09:04:58,120
will where one here represents white and

14395
09:04:55,558 --> 09:04:59,840
zero represents black so if you kind of

14396
09:04:58,120 --> 09:05:01,840
like this thing it turns out you can do

14397
09:04:59,840 --> 09:05:03,558
pretty uh pretty beautiful pretty

14398
09:05:01,840 --> 09:05:05,318
interesting pretty artistically inclined

14399
09:05:03,558 --> 09:05:08,200
things if you go to this URL at your

14400
09:05:05,318 --> 09:05:09,718
leisure cs50. lart it'll actually

14401
09:05:08,200 --> 09:05:11,120
redirect you to a Google spreadsheet

14402
09:05:09,718 --> 09:05:12,958
that we've made in advance and we've

14403
09:05:11,120 --> 09:05:15,520
kind of Shrunk the rows and columns to

14404
09:05:12,958 --> 09:05:16,958
resemble a grid of pixels tiny little

14405
09:05:15,520 --> 09:05:20,160
squares all of which are white by

14406
09:05:16,958 --> 09:05:21,840
default not unlike this easel here that

14407
09:05:20,160 --> 09:05:23,200
we have a couple of volunteers working

14408
09:05:21,840 --> 09:05:24,478
away at in fact would you guys like to

14409
09:05:23,200 --> 09:05:27,000
come forward for a moment and say a

14410
09:05:24,478 --> 09:05:29,079
quick hello before we come back to you

14411
09:05:27,000 --> 09:05:31,440
uh hello my name is Daniel I'm from

14412
09:05:29,080 --> 09:05:33,958
Chicago welcome to Daniel and hi

14413
09:05:31,440 --> 09:05:36,280
everyone I'm Adam and I'm from chindon

14414
09:05:33,958 --> 09:05:38,237
Tobago nice well welcome to you both

14415
09:05:36,280 --> 09:05:40,280
thank you you'll see that in their hands

14416
09:05:38,238 --> 09:05:41,680
are actually a whole bunch of pixels uh

14417
09:05:40,280 --> 09:05:42,840
Post-it notes that we've handed them in

14418
09:05:41,680 --> 09:05:44,238
in advance so if you don't mind we'll

14419
09:05:42,840 --> 09:05:45,760
come back to you in a couple of minutes

14420
09:05:44,238 --> 09:05:48,280
and see what they've created if you will

14421
09:05:45,760 --> 09:05:49,359
on this grid of white paper much like

14422
09:05:48,280 --> 09:05:51,000
you could create on this Google

14423
09:05:49,360 --> 09:05:53,280
spreadsheet in fact feel free to send us

14424
09:05:51,000 --> 09:05:57,200
your Creations if so inclined uh via the

14425
09:05:53,280 --> 09:05:59,000
URL you'll get at cs50. lart now let's

14426
09:05:57,200 --> 09:06:00,360
come back to week zero where we Define

14427
09:05:59,000 --> 09:06:02,318
some of the building blocks for images

14428
09:06:00,360 --> 09:06:04,160
we talked about RGB which is just red

14429
09:06:02,318 --> 09:06:05,958
green blue and it's just one of the

14430
09:06:04,160 --> 09:06:07,878
systems a popular system via which you

14431
09:06:05,958 --> 09:06:11,159
can represent any color of the rainbow

14432
09:06:07,878 --> 09:06:13,040
using some combination of red and green

14433
09:06:11,160 --> 09:06:14,960
and blue and if any of you are

14434
09:06:13,040 --> 09:06:17,557
artistically inclined or have used

14435
09:06:14,960 --> 09:06:19,557
Photoshop or similar programs you might

14436
09:06:17,557 --> 09:06:21,877
typically have some means of selecting a

14437
09:06:19,557 --> 09:06:23,917
color by some grid like this but down

14438
09:06:21,877 --> 09:06:27,121
here notice there's explicit mentions of

14439
09:06:23,917 --> 09:06:30,237
the types of color systems in use R GB

14440
09:06:27,122 --> 09:06:32,398
and in fact here you see 0000 0 and up

14441
09:06:30,237 --> 09:06:33,839
here under new you see the color black

14442
09:06:32,398 --> 09:06:35,960
and that implies that if you have no red

14443
09:06:33,839 --> 09:06:38,359
no green no blue well that indeed would

14444
09:06:35,960 --> 09:06:40,040
represent by convention the color black

14445
09:06:38,360 --> 09:06:42,800
by contrast if we play around with

14446
09:06:40,040 --> 09:06:45,000
Photoshop or similar program if you have

14447
09:06:42,800 --> 09:06:48,680
a lot of red a lot of green and a lot of

14448
09:06:45,000 --> 09:06:50,960
blue for instance 255 255 255 like

14449
09:06:48,680 --> 09:06:53,122
really crank it up to the max value you

14450
09:06:50,960 --> 09:06:55,398
can represent with eight bits per week

14451
09:06:53,122 --> 09:06:57,320
zero well then it turns out you get the

14452
09:06:55,398 --> 09:06:59,800
color white here and we can play with

14453
09:06:57,320 --> 09:07:03,320
these numbers endlessly for instance if

14454
09:06:59,800 --> 09:07:06,000
we use 255 of red but zero green and

14455
09:07:03,320 --> 09:07:07,680
zero blue not surprisingly the square at

14456
09:07:06,000 --> 09:07:09,877
the top of the screen Becomes Of course

14457
09:07:07,680 --> 09:07:12,160
red entirely because it's all red and no

14458
09:07:09,877 --> 09:07:15,199
green no blue if we change it instead to

14459
09:07:12,160 --> 09:07:17,122
255 for green but zero for red and blue

14460
09:07:15,199 --> 09:07:19,199
of course we get green and then lastly

14461
09:07:17,122 --> 09:07:21,438
if we crank up the blue but leave red

14462
09:07:19,199 --> 09:07:23,680
and green as zero we of course get blue

14463
09:07:21,438 --> 09:07:25,000
but all this while down here highlighted

14464
09:07:23,680 --> 09:07:27,078
is something that maybe some of you have

14465
09:07:25,000 --> 09:07:28,680
seen before like some combination of

14466
09:07:27,078 --> 09:07:31,122
numbers and letters if any of you have

14467
09:07:28,680 --> 09:07:32,718
made personal web pages or use programs

14468
09:07:31,122 --> 09:07:34,960
like Photoshop you might have used these

14469
09:07:32,718 --> 09:07:37,398
so-called color codes so indeed the

14470
09:07:34,960 --> 09:07:40,199
world has this convention whereby using

14471
09:07:37,398 --> 09:07:42,160
six digits or sometimes three you can

14472
09:07:40,199 --> 09:07:45,039
represent a little more succinctly some

14473
09:07:42,160 --> 09:07:48,800
amount of red green blue and you'll see

14474
09:07:45,040 --> 09:07:51,718
here maybe by inference that if RGB is0

14475
09:07:48,800 --> 09:07:53,640
0 255 respectively perhaps where we're

14476
09:07:51,718 --> 09:07:56,640
going with this is that

14477
09:07:53,640 --> 09:07:58,800
0000 FF is just an alternative way of

14478
09:07:56,640 --> 09:08:02,078
expressing the exact same idea no red no

14479
09:07:58,800 --> 09:08:03,640
green and a lot of blue but why is that

14480
09:08:02,078 --> 09:08:05,598
and in fact we'll come full circle here

14481
09:08:03,640 --> 09:08:06,917
to introducing something that we could

14482
09:08:05,598 --> 09:08:08,960
have done in week zero but it doesn't

14483
09:08:06,917 --> 09:08:11,278
really solve a problem then but today as

14484
09:08:08,960 --> 09:08:13,159
we focus more on images and on memory

14485
09:08:11,278 --> 09:08:15,237
itself turns out understanding these

14486
09:08:13,160 --> 09:08:16,718
patterns is pretty useful so back in

14487
09:08:15,237 --> 09:08:19,159
week zero we talked of course about

14488
09:08:16,718 --> 09:08:21,800
binary and binary by implying two only

14489
09:08:19,160 --> 09:08:23,640
gives you two digits zero and one you

14490
09:08:21,800 --> 09:08:25,598
and I as humans almost always use the

14491
09:08:23,640 --> 09:08:28,438
decimal system in normal conversation

14492
09:08:25,598 --> 09:08:30,960
deck meaning 10 so we have 0 through n

14493
09:08:28,438 --> 09:08:34,598
instead if a human like us wants to

14494
09:08:30,960 --> 09:08:36,799
count up as high as 10 or 11 or 12 we

14495
09:08:34,598 --> 09:08:39,758
don't have a digit per se for 10 11 and

14496
09:08:36,800 --> 09:08:43,360
12 we start reusing digits so it's 1 0 1

14497
09:08:39,758 --> 09:08:45,878
1 1 2 and so forth but in other systems

14498
09:08:43,360 --> 09:08:49,360
not binary not decimal but systems

14499
09:08:45,877 --> 09:08:51,557
called heximal hex implying 16 there are

14500
09:08:49,360 --> 09:08:53,640
actually more digits than these which

14501
09:08:51,557 --> 09:08:55,960
might come as a surprise um it's not

14502
09:08:53,640 --> 09:08:57,557
pairs of digits like in decimal single

14503
09:08:55,960 --> 09:08:58,960
digits and frankly it doesn't really

14504
09:08:57,557 --> 09:08:59,917
matter what the digits are because at

14505
09:08:58,960 --> 09:09:01,360
the end of the day these are just

14506
09:08:59,917 --> 09:09:03,278
symbols that you and I immediately

14507
09:09:01,360 --> 09:09:05,360
associate with some notion of math but

14508
09:09:03,278 --> 09:09:07,680
just Strokes on the screen that

14509
09:09:05,360 --> 09:09:10,078
represent some have represent some

14510
09:09:07,680 --> 09:09:11,040
actual value so it turns out that by

14511
09:09:10,078 --> 09:09:13,800
convention

14512
09:09:11,040 --> 09:09:15,800
when you want more than n 10 digits 0

14513
09:09:13,800 --> 09:09:20,320
through 9 you start using letters of the

14514
09:09:15,800 --> 09:09:21,878
English alphabet A B C D E and F and you

14515
09:09:20,320 --> 09:09:23,360
can represent them in lower case it's

14516
09:09:21,877 --> 09:09:24,717
case insensitive so it doesn't really

14517
09:09:23,360 --> 09:09:26,680
matter you might see it in upper case or

14518
09:09:24,718 --> 09:09:29,278
lower case but this is how you can count

14519
09:09:26,680 --> 09:09:31,480
Beyond N9 not using decimal but using

14520
09:09:29,278 --> 09:09:33,278
indeed something called hexadecimal if

14521
09:09:31,480 --> 09:09:35,438
we get really technical this is also

14522
09:09:33,278 --> 09:09:37,237
known as base 16 and it's the same idea

14523
09:09:35,438 --> 09:09:40,918
as week zero where instead of using base

14524
09:09:37,237 --> 09:09:43,598
2 for binary base 10 for decimal use 16

14525
09:09:40,917 --> 09:09:45,640
as the base for heximal and so if we run

14526
09:09:43,598 --> 09:09:48,278
through just some simple examples here

14527
09:09:45,640 --> 09:09:51,640
in the world of heximal your columns are

14528
09:09:48,278 --> 09:09:54,640
just powers of 16 16 to the 0er 16 to

14529
09:09:51,640 --> 09:09:56,917
the 1 16 to the 2 and so forth but in

14530
09:09:54,640 --> 09:09:58,479
the world of hex we usually at least

14531
09:09:56,917 --> 09:10:00,877
thus far and today we'll see just pairs

14532
09:09:58,480 --> 09:10:03,160
of digits like this so here for instance

14533
09:10:00,877 --> 09:10:05,237
is the ones column and the 16's column

14534
09:10:03,160 --> 09:10:06,960
if we multiply that out so if you wanted

14535
09:10:05,237 --> 09:10:09,757
to represent the number you and I know

14536
09:10:06,960 --> 09:10:12,758
in in uh the real world as zero in

14537
09:10:09,758 --> 09:10:14,558
heximal it would just be 0 0 if you want

14538
09:10:12,758 --> 09:10:19,122
to represent the number one it would be

14539
09:10:14,557 --> 09:10:23,519
01 and from there we get 02 03 04 0 five

14540
09:10:19,122 --> 09:10:25,000
06 07 08 09 now things get potentially

14541
09:10:23,519 --> 09:10:27,717
interesting in decimal it would

14542
09:10:25,000 --> 09:10:31,877
obviously become 10 but in heximal it

14543
09:10:27,718 --> 09:10:34,438
just becomes 0 a and then 0 B which is

14544
09:10:31,877 --> 09:10:37,320
to say if I rewind after nine comes in

14545
09:10:34,438 --> 09:10:39,238
heximal if I pronounce it in in decimal

14546
09:10:37,320 --> 09:10:43,159
this is how you'd represent 10 this is

14547
09:10:39,237 --> 09:10:46,799
how you'd represent 11 12 13 14 and then

14548
09:10:43,160 --> 09:10:49,040
lastly in heximal the 16th value is f

14549
09:10:46,800 --> 09:10:52,160
which is just always going to represent

14550
09:10:49,040 --> 09:10:53,917
15 so where to how do we connect this to

14551
09:10:52,160 --> 09:10:57,078
some of the past math well once you get

14552
09:10:53,917 --> 09:10:59,557
to Zer F in heximal if f is the highest

14553
09:10:57,078 --> 09:11:02,360
you can count just like in decimal nine

14554
09:10:59,557 --> 09:11:05,199
is the highest you can count what comes

14555
09:11:02,360 --> 09:11:07,520
next if this is 15 I claim how do I

14556
09:11:05,199 --> 09:11:09,360
represent 16 in heximal with what

14557
09:11:07,519 --> 09:11:12,039
pattern of

14558
09:11:09,360 --> 09:11:15,960
symbols what pattern of symbols for

14559
09:11:12,040 --> 09:11:17,598
heximal yeah so one Z not 10 even though

14560
09:11:15,960 --> 09:11:20,640
you might read it like that as a typical

14561
09:11:17,598 --> 09:11:22,121
human but one zero because why well even

14562
09:11:20,640 --> 09:11:23,877
if this is completely new to you the

14563
09:11:22,122 --> 09:11:25,800
whole column system the places are

14564
09:11:23,877 --> 09:11:28,519
exactly the same intuitively so you need

14565
09:11:25,800 --> 09:11:30,122
a one in the 16's place and a zero in

14566
09:11:28,519 --> 09:11:32,237
the ones place and we won't count all

14567
09:11:30,122 --> 09:11:34,918
the way up to 255 but we count if we

14568
09:11:32,237 --> 09:11:38,121
count a little higher this would be 1 Z

14569
09:11:34,917 --> 09:11:43,199
AKA 16 in decimal this would be 1 one

14570
09:11:38,122 --> 09:11:45,238
AKA 17 in decimal and then 18 19 20 and

14571
09:11:43,199 --> 09:11:48,039
so forth dot dot dot and we can count

14572
09:11:45,237 --> 09:11:50,839
all the way up to FF CU if f is the

14573
09:11:48,040 --> 09:11:52,878
biggest digit in hexadecimal FF is

14574
09:11:50,839 --> 09:11:55,121
indeed as high as we can count and if

14575
09:11:52,877 --> 09:11:58,799
each F represents 15 well let's just do

14576
09:11:55,122 --> 09:12:01,398
the math like in week zero so 16 * F + 1

14577
09:11:58,800 --> 09:12:03,320
* f is how all of us learned to do uh

14578
09:12:01,398 --> 09:12:07,878
math in grade school even though not in

14579
09:12:03,320 --> 09:12:11,839
heximal that's of course 16 * 15 + 1 *

14580
09:12:07,877 --> 09:12:14,839
15 multiply that out you get 240 plus 15

14581
09:12:11,839 --> 09:12:19,320
and air go you can count as high as

14582
09:12:14,839 --> 09:12:20,679
255 using two heximal digits now this is

14583
09:12:19,320 --> 09:12:22,159
not the kind of thing where like this is

14584
09:12:20,680 --> 09:12:23,917
going to be an interesting exercise

14585
09:12:22,160 --> 09:12:25,398
mentally to ever convert in your head

14586
09:12:23,917 --> 09:12:27,718
generally you'll get used to the fact

14587
09:12:25,398 --> 09:12:29,598
that after nine comes a and the biggest

14588
09:12:27,718 --> 09:12:30,800
digit is f and you'll just start to see

14589
09:12:29,598 --> 09:12:32,960
patterns like this in the worlds of

14590
09:12:30,800 --> 09:12:36,520
Photoshop web pages in a few weeks and

14591
09:12:32,960 --> 09:12:39,000
Beyond but like why is heximal useful

14592
09:12:36,519 --> 09:12:41,121
like why are we complicating the world

14593
09:12:39,000 --> 09:12:42,800
and adding on top of decimal something

14594
09:12:41,122 --> 09:12:45,040
else well it turns out that a single

14595
09:12:42,800 --> 09:12:47,840
decimal digit like f the biggest one for

14596
09:12:45,040 --> 09:12:49,960
instance is 15 and here let me just

14597
09:12:47,839 --> 09:12:53,479
propose a bit of Mental Math how many

14598
09:12:49,960 --> 09:12:56,000
bits do you need to represent the number

14599
09:12:53,480 --> 09:12:59,598
15 in binary if you've got the ones

14600
09:12:56,000 --> 09:13:01,122
place two's Place fours and so forth how

14601
09:12:59,598 --> 09:13:03,960
many bits

14602
09:13:01,122 --> 09:13:06,718
total so fewer than five to count this

14603
09:13:03,960 --> 09:13:09,159
highest 15 I think but

14604
09:13:06,718 --> 09:13:13,398
close someone

14605
09:13:09,160 --> 09:13:15,078
else sing in hand yeah so four bits I

14606
09:13:13,398 --> 09:13:18,200
think suffice because if you want to

14607
09:13:15,078 --> 09:13:20,640
count as high as F that is to say 15 I

14608
09:13:18,199 --> 09:13:22,360
think if you have four bits you can do

14609
09:13:20,640 --> 09:13:24,479
that because if over here is the one's

14610
09:13:22,360 --> 09:13:26,557
place from week zero for binary this is

14611
09:13:24,480 --> 09:13:28,360
the two's place this is The Four's place

14612
09:13:26,557 --> 09:13:33,199
this is the e place do out some quick

14613
09:13:28,360 --> 09:13:35,598
math so 8 + 4 is 12 + 2 is 14 + 1 is 15

14614
09:13:33,199 --> 09:13:37,717
so it turns out that by convenience

14615
09:13:35,598 --> 09:13:40,519
heximal digits can just be represented

14616
09:13:37,718 --> 09:13:43,040
consistently with four bits or fewer but

14617
09:13:40,519 --> 09:13:44,717
four and four of course is half of eight

14618
09:13:43,040 --> 09:13:46,320
and eight is like everywhere like eight

14619
09:13:44,718 --> 09:13:48,360
bits is a bite which is again just a

14620
09:13:46,320 --> 09:13:50,078
convention we've seen and so the reason

14621
09:13:48,360 --> 09:13:52,840
that you see hexad desmal in the world

14622
09:13:50,078 --> 09:13:55,398
of Photoshop and eventually web pages is

14623
09:13:52,839 --> 09:13:57,237
it actually just Maps really nicely to

14624
09:13:55,398 --> 09:13:59,640
expressing binary numbers more

14625
09:13:57,237 --> 09:14:03,237
succinctly with a fixed number of digits

14626
09:13:59,640 --> 09:14:06,877
so for instance anytime you see 11 one

14627
09:14:03,237 --> 09:14:08,237
one one 1111 in the world as binary you

14628
09:14:06,877 --> 09:14:10,598
know what that's a little tedious to

14629
09:14:08,237 --> 09:14:12,598
both say and write you can represent

14630
09:14:10,598 --> 09:14:15,680
more succinctly

14631
09:14:12,598 --> 09:14:20,121
any uh group of four one bits more

14632
09:14:15,680 --> 09:14:23,320
succinctly in heximal as just F so 111

14633
09:14:20,122 --> 09:14:25,160
1111 in binary more succinctly and more

14634
09:14:23,320 --> 09:14:27,122
commonly now in the world of Photoshop

14635
09:14:25,160 --> 09:14:29,040
memory images and the like is

14636
09:14:27,122 --> 09:14:30,598
represented more succinctly as FF and

14637
09:14:29,040 --> 09:14:32,840
that's why because it just Maps really

14638
09:14:30,598 --> 09:14:36,199
nicely to four bits and so we can be a

14639
09:14:32,839 --> 09:14:38,397
little more succinct so any questions on

14640
09:14:36,199 --> 09:14:40,397
heximal which is just another way of

14641
09:14:38,398 --> 09:14:43,078
representing information but using the

14642
09:14:40,398 --> 09:14:45,398
same grade school approach yeah good

14643
09:14:43,078 --> 09:14:48,360
question if you represent 15 with f it

14644
09:14:45,398 --> 09:14:50,558
would use four bits so base systems are

14645
09:14:48,360 --> 09:14:52,758
really just a way for us humans on paper

14646
09:14:50,557 --> 09:14:55,159
or on screens to represent information

14647
09:14:52,758 --> 09:14:57,278
if F represents the decimal number 15

14648
09:14:55,160 --> 09:15:00,320
the computer underneath the hood has to

14649
09:14:57,278 --> 09:15:02,680
use four bits to represent it so one

14650
09:15:00,320 --> 09:15:05,557
heximal digit by convention always

14651
09:15:02,680 --> 09:15:07,718
implies four bits underneath the hood so

14652
09:15:05,557 --> 09:15:10,680
therefore if you have two heximal digits

14653
09:15:07,718 --> 09:15:12,718
like 0 0 that means eight zero bits

14654
09:15:10,680 --> 09:15:15,398
underneath the hood like for red or for

14655
09:15:12,718 --> 09:15:17,360
green if you see FF now we know that's

14656
09:15:15,398 --> 09:15:19,758
four one bits and another four one Bits

14657
09:15:17,360 --> 09:15:22,199
And if we do out the math that's 255

14658
09:15:19,758 --> 09:15:26,680
that's why in Photoshop

14659
09:15:22,199 --> 09:15:29,077
000000 FF means no red no green and

14660
09:15:26,680 --> 09:15:30,680
255 of blue and it's just way more

14661
09:15:29,078 --> 09:15:33,438
succinct than writing out like what 8

14662
09:15:30,680 --> 09:15:35,519
plus 8 plus 8 24 zeros and ones and it's

14663
09:15:33,438 --> 09:15:37,320
just cleaner than even using decimal

14664
09:15:35,519 --> 09:15:39,437
when you're using units of eight which

14665
09:15:37,320 --> 09:15:40,680
again computers just use everywhere so

14666
09:15:39,438 --> 09:15:42,640
it's just another system it's not one

14667
09:15:40,680 --> 09:15:44,917
you need to dwell on very much but again

14668
09:15:42,640 --> 09:15:46,718
it's fundamentally no different from

14669
09:15:44,917 --> 09:15:49,479
binary or decimal we're just using a

14670
09:15:46,718 --> 09:15:52,122
slightly different base no all right

14671
09:15:49,480 --> 09:15:54,122
well we had this blank canvas here and I

14672
09:15:52,122 --> 09:15:55,960
think uh are you two perhaps ready to

14673
09:15:54,122 --> 09:15:57,078
reveal for the world what you've created

14674
09:15:55,960 --> 09:15:59,718
do you want to go ahead and I'll I'll

14675
09:15:57,078 --> 09:16:03,000
swivel it around for you all right here

14676
09:15:59,718 --> 09:16:07,278
we go big reveal and today's pixel

14677
09:16:03,000 --> 09:16:09,917
art a round of applause if we

14678
09:16:07,278 --> 09:16:11,121
could very nicely done well thank you

14679
09:16:09,917 --> 09:16:12,640
both if you want to come up after and

14680
09:16:11,122 --> 09:16:14,122
tear this off and bring it home you're

14681
09:16:12,640 --> 09:16:15,680
welcome to and keep the Post-it notes

14682
09:16:14,122 --> 09:16:18,878
too well thank you to our volunteers

14683
09:16:15,680 --> 09:16:20,160
there let's now translate this to really

14684
09:16:18,877 --> 09:16:21,917
more technical worlds where we're going

14685
09:16:20,160 --> 09:16:23,598
to see and consider it more often

14686
09:16:21,917 --> 09:16:25,121
because in fact sometimes when you've

14687
09:16:23,598 --> 09:16:27,278
had error messages over the past few

14688
09:16:25,122 --> 09:16:29,480
weeks from clang the compiler you might

14689
09:16:27,278 --> 09:16:31,000
have even seen evidence of heximal we

14690
09:16:29,480 --> 09:16:32,878
didn't call it out it wasn't useful to

14691
09:16:31,000 --> 09:16:36,199
know at the time but it turns out a lot

14692
09:16:32,877 --> 09:16:39,320
of programs use and a lot of code uses

14693
09:16:36,199 --> 09:16:41,598
heximal for those reasons of more prec

14694
09:16:39,320 --> 09:16:43,278
more representation so for instance

14695
09:16:41,598 --> 09:16:44,960
where else might we see it well here's

14696
09:16:43,278 --> 09:16:46,640
that picture we keep pulling up of our

14697
09:16:44,960 --> 09:16:48,758
computer's memory and each of these

14698
09:16:46,640 --> 09:16:50,398
squares in this grid represents a bite

14699
09:16:48,758 --> 09:16:52,160
sort of top left to bottom right in the

14700
09:16:50,398 --> 09:16:54,480
computer's memory but again just an

14701
09:16:52,160 --> 09:16:56,438
artist's representation a few weeks ago

14702
09:16:54,480 --> 09:16:58,238
I claimed that each of these bytes can

14703
09:16:56,438 --> 09:17:00,438
be numbered of course like this is bite

14704
09:16:58,237 --> 09:17:02,077
zero at top left then bite one then bite

14705
09:17:00,438 --> 09:17:04,558
two then bite two billion if you have

14706
09:17:02,078 --> 09:17:07,640
two gigabytes of memory and so we could

14707
09:17:04,557 --> 09:17:11,159
just number them like this 0 through 15

14708
09:17:07,640 --> 09:17:13,479
on up 16 17 18 and so forth but per the

14709
09:17:11,160 --> 09:17:15,680
reasons earlier it's just more common in

14710
09:17:13,480 --> 09:17:17,398
computer systems and in software to

14711
09:17:15,680 --> 09:17:19,800
actually use hexadecimal just to

14712
09:17:17,398 --> 09:17:22,680
describe the locations of the addresses

14713
09:17:19,800 --> 09:17:24,160
of things in memory so instead a typical

14714
09:17:22,680 --> 09:17:27,320
programmer or computer scientist would

14715
09:17:24,160 --> 09:17:29,040
call these first 16 bytes 0 through F

14716
09:17:27,320 --> 09:17:32,078
just because but that's because it's a

14717
09:17:29,040 --> 09:17:34,398
predictable number of bits so if we keep

14718
09:17:32,078 --> 09:17:39,160
going beyond that you would get not 10

14719
09:17:34,398 --> 09:17:40,878
not 11 not 12 but in heximal 1 0 1 1 1 2

14720
09:17:39,160 --> 09:17:43,878
and so forth all the way down on the

14721
09:17:40,877 --> 09:17:45,557
screen to 1 F and if I you know shrunk

14722
09:17:43,877 --> 09:17:48,397
this down or had a bigger monitor we

14723
09:17:45,557 --> 09:17:51,839
would see eventually 255 bytes later

14724
09:17:48,398 --> 09:17:53,360
from the start 255 as well but there's a

14725
09:17:51,839 --> 09:17:55,839
potential problem here with using

14726
09:17:53,360 --> 09:17:58,360
heximal in this way there's an

14727
09:17:55,839 --> 09:18:01,679
ambiguity can anyone imagine like what

14728
09:17:58,360 --> 09:18:06,199
can go wrong if we use hex to just

14729
09:18:01,680 --> 09:18:08,557
simply describe locations in memory like

14730
09:18:06,199 --> 09:18:11,159
this

14731
09:18:08,557 --> 09:18:13,437
yeah yeah yeah like one zero might also

14732
09:18:11,160 --> 09:18:14,918
be 10 and you know maybe if you're you

14733
09:18:13,438 --> 09:18:17,000
know really thorough okay wait a minute

14734
09:18:14,917 --> 09:18:18,680
it can't be 10 cuz here's F over here so

14735
09:18:17,000 --> 09:18:20,160
it's obviously not decimal but why

14736
09:18:18,680 --> 09:18:21,278
create potential confusion especially

14737
09:18:20,160 --> 09:18:22,840
when you're collaborating building

14738
09:18:21,278 --> 09:18:24,479
something with someone we want to avoid

14739
09:18:22,839 --> 09:18:27,199
that ambiguity and so the convention

14740
09:18:24,480 --> 09:18:28,800
humans decided on years ago is that if

14741
09:18:27,199 --> 09:18:31,640
you want to make clear that a number is

14742
09:18:28,800 --> 09:18:35,040
in hexadecimal just by convention you

14743
09:18:31,640 --> 09:18:37,237
prefix all of the digits with Zer X the

14744
09:18:35,040 --> 09:18:39,360
X is not like another character it's not

14745
09:18:37,237 --> 09:18:40,320
like a 17th character it's just a human

14746
09:18:39,360 --> 09:18:42,917
conven

14747
09:18:40,320 --> 09:18:45,640
of putting 0x to imply here comes

14748
09:18:42,917 --> 09:18:48,799
heximal and now it's unambiguous so now

14749
09:18:45,640 --> 09:18:50,640
we see 0x10 obviously is not 10 as we

14750
09:18:48,800 --> 09:18:53,160
know it in decimal but rather it's the

14751
09:18:50,640 --> 09:18:55,839
number that comes after a single F so

14752
09:18:53,160 --> 09:18:57,758
it's really the number in decimal 16 so

14753
09:18:55,839 --> 09:19:00,839
0x anytime you see it that's just a

14754
09:18:57,758 --> 09:19:04,640
visual cue that what is ahead is

14755
09:19:00,839 --> 09:19:06,437
actually heximal so let's now start

14756
09:19:04,640 --> 09:19:07,960
playing around with this information so

14757
09:19:06,438 --> 09:19:09,758
here's a super simple line of code from

14758
09:19:07,960 --> 09:19:12,199
like week one where I'm just declaring

14759
09:19:09,758 --> 09:19:14,122
ing a variable n and I'm defining it to

14760
09:19:12,199 --> 09:19:15,719
be the value 50 and this is out of

14761
09:19:14,122 --> 09:19:17,720
context we probably need a main function

14762
09:19:15,720 --> 09:19:19,520
and all of that but let's just rewind to

14763
09:19:17,720 --> 09:19:21,520
week one where we actually saw code like

14764
09:19:19,520 --> 09:19:23,276
this and do something useful with a line

14765
09:19:21,520 --> 09:19:25,916
of code like this so let me go over here

14766
09:19:23,276 --> 09:19:28,360
to VSS code and in vs code I'll create a

14767
09:19:25,916 --> 09:19:30,799
program called how about addresses since

14768
09:19:28,360 --> 09:19:32,960
the goal of this uh the goal here is to

14769
09:19:30,800 --> 09:19:35,120
just play around ultimately with a

14770
09:19:32,960 --> 09:19:37,520
variable like n and let me go ahead and

14771
09:19:35,120 --> 09:19:40,756
do this I'll include how about standard

14772
09:19:37,520 --> 09:19:44,359
i.h I'll do int main void so no command

14773
09:19:40,756 --> 09:19:46,120
line Arguments for now in N gets 50 and

14774
09:19:44,360 --> 09:19:48,240
now so that we can do something mildly

14775
09:19:46,120 --> 09:19:50,640
useful with it let's just go use print F

14776
09:19:48,240 --> 09:19:53,119
and print out with percent I and then a

14777
09:19:50,640 --> 09:19:54,560
new line whatever that value of n is so

14778
09:19:53,120 --> 09:19:56,560
this is not going to be interesting per

14779
09:19:54,560 --> 09:19:58,596
se it's just week one stuff where I'm

14780
09:19:56,560 --> 09:20:00,360
defining a variable and printing it out

14781
09:19:58,596 --> 09:20:02,479
to the screen so let me go down to my

14782
09:20:00,360 --> 09:20:05,040
terminal window and do make

14783
09:20:02,480 --> 09:20:07,240
addresses no errors so that's good I'll

14784
09:20:05,040 --> 09:20:10,160
do do/ addresses and of course I should

14785
09:20:07,240 --> 09:20:12,119
see the number 50 here now what's going

14786
09:20:10,160 --> 09:20:15,436
on underneath the hood let's translate

14787
09:20:12,120 --> 09:20:16,756
now code to really what's going on under

14788
09:20:15,436 --> 09:20:18,520
under underneath the hood of the

14789
09:20:16,756 --> 09:20:20,520
computer so if this is our grid of

14790
09:20:18,520 --> 09:20:21,880
memory I don't necessarily know as the

14791
09:20:20,520 --> 09:20:23,560
programmer and I definitely don't care

14792
09:20:21,880 --> 09:20:24,680
as the programmer where exactly it's

14793
09:20:23,560 --> 09:20:26,200
ending up in memory that's the whole

14794
09:20:24,680 --> 09:20:27,756
point of using Code let the computer

14795
09:20:26,200 --> 09:20:30,000
figure this out but at least

14796
09:20:27,756 --> 09:20:32,480
conceptually I know that by declaring a

14797
09:20:30,000 --> 09:20:34,400
line of code like that the number 50

14798
09:20:32,480 --> 09:20:37,680
ends up somewhere in the computer's

14799
09:20:34,400 --> 09:20:40,040
memory and it's assigned the name n a

14800
09:20:37,680 --> 09:20:42,596
symbol n via which I the programmer can

14801
09:20:40,040 --> 09:20:46,880
refer to it and I very deliberately used

14802
09:20:42,596 --> 09:20:48,756
four of these squares for what

14803
09:20:46,880 --> 09:20:52,200
reason what might be the reason for

14804
09:20:48,756 --> 09:20:53,680
using four squares specifically yeah

14805
09:20:52,200 --> 09:20:55,399
yeah so an integer is four bytes at

14806
09:20:53,680 --> 09:20:57,360
least most of the time on Modern systems

14807
09:20:55,400 --> 09:20:59,200
an integer is four bytes on an older

14808
09:20:57,360 --> 09:21:02,080
computer it might just use one or maybe

14809
09:20:59,200 --> 09:21:03,276
even uh two bytes But Here by convention

14810
09:21:02,080 --> 09:21:04,560
we're almost always going to see four

14811
09:21:03,276 --> 09:21:06,520
bytes I don't know if it's going to end

14812
09:21:04,560 --> 09:21:08,320
up here it might end up over here but

14813
09:21:06,520 --> 09:21:10,359
for now who cares I just know that the

14814
09:21:08,320 --> 09:21:13,000
computer can store the the information

14815
09:21:10,360 --> 09:21:15,596
in this way underneath the hood so let's

14816
09:21:13,000 --> 09:21:18,000
now introduce another feature of C that

14817
09:21:15,596 --> 09:21:20,079
we haven't had occasion to use just yet

14818
09:21:18,000 --> 09:21:21,800
that's going to allow us to start poking

14819
09:21:20,080 --> 09:21:23,436
around the computer's memory For Better

14820
09:21:21,800 --> 09:21:25,436
or For Worse and this is one of those

14821
09:21:23,436 --> 09:21:27,840
situations where you're about to learn

14822
09:21:25,436 --> 09:21:29,680
acquire a a skill a power that can

14823
09:21:27,840 --> 09:21:31,200
actually come back to bite you because

14824
09:21:29,680 --> 09:21:33,080
once you know how to start poking around

14825
09:21:31,200 --> 09:21:34,596
a computer's memory you can do very

14826
09:21:33,080 --> 09:21:36,360
powerful things and next week we'll see

14827
09:21:34,596 --> 09:21:38,159
what you can build in a computer's

14828
09:21:36,360 --> 09:21:39,640
memory but you can also screw up pretty

14829
09:21:38,160 --> 09:21:41,160
easily and cause more of those

14830
09:21:39,640 --> 09:21:43,596
segmentation faults that a few of you

14831
09:21:41,160 --> 09:21:45,320
have already suffered so with that said

14832
09:21:43,596 --> 09:21:47,680
let's just stipulate that you know what

14833
09:21:45,320 --> 09:21:49,960
I don't care necessarily where the 50 is

14834
09:21:47,680 --> 09:21:52,000
in memory but I know it exists at some

14835
09:21:49,960 --> 09:21:53,720
address in memory and just so I have an

14836
09:21:52,000 --> 09:21:56,520
easy address to pronounce let's just

14837
09:21:53,720 --> 09:21:58,520
suppose it lives at ox123 so that's the

14838
09:21:56,520 --> 09:22:00,276
address in memory in heximal by

14839
09:21:58,520 --> 09:22:01,680
convention and that just happens to be

14840
09:22:00,276 --> 09:22:05,079
where it ends up when I write that line

14841
09:22:01,680 --> 09:22:06,960
of code but it turns out C has some

14842
09:22:05,080 --> 09:22:09,000
other operators we can use when we've

14843
09:22:06,960 --> 09:22:10,840
seen the asterisk before the star and

14844
09:22:09,000 --> 09:22:11,916
we've used it for multiplication but

14845
09:22:10,840 --> 09:22:13,399
today we're going to use it for

14846
09:22:11,916 --> 09:22:15,200
something more powerful and we're also

14847
09:22:13,400 --> 09:22:17,320
going to introduce an Amper sand which

14848
09:22:15,200 --> 09:22:20,200
allows us to do something as well the

14849
09:22:17,320 --> 09:22:23,840
Amper sand operator is going to allow us

14850
09:22:20,200 --> 09:22:25,840
to get the address of a piece of data in

14851
09:22:23,840 --> 09:22:28,039
memory like by literally putting

14852
09:22:25,840 --> 09:22:31,159
Ampersand before the name of a variable

14853
09:22:28,040 --> 09:22:33,400
C will tell us tell you what address

14854
09:22:31,160 --> 09:22:35,596
that variable lives at maybe it's ox123

14855
09:22:33,400 --> 09:22:38,360
maybe it's Ox 456 who knows but that

14856
09:22:35,596 --> 09:22:40,276
will give you back the answer the Star

14857
09:22:38,360 --> 09:22:42,276
does the opposite it's sort of means go

14858
09:22:40,276 --> 09:22:44,520
there so using the star otherwise known

14859
09:22:42,276 --> 09:22:46,560
as the D reference operator I can

14860
09:22:44,520 --> 09:22:48,479
actually go to a specific address if I

14861
09:22:46,560 --> 09:22:52,399
want and we'll see what this means in

14862
09:22:48,480 --> 09:22:54,080
code so how can I leverage this in some

14863
09:22:52,400 --> 09:22:55,840
mildly interesting way to start poking

14864
09:22:54,080 --> 09:22:58,000
around but eventually we'll use this

14865
09:22:55,840 --> 09:23:00,916
primitive to build more interesting

14866
09:22:58,000 --> 09:23:03,240
things so let me go back to save vs code

14867
09:23:00,916 --> 09:23:05,276
here and let me go ahead and do this

14868
09:23:03,240 --> 09:23:06,960
I'll clear my terminal to start fresh

14869
09:23:05,276 --> 09:23:10,400
and I'll introduce another format code

14870
09:23:06,960 --> 09:23:13,040
for printf percent p and for now just

14871
09:23:10,400 --> 09:23:15,200
take on faith that this it is percent P

14872
09:23:13,040 --> 09:23:18,400
because but percent p is going to allow

14873
09:23:15,200 --> 09:23:21,399
me to print the address of a variable if

14874
09:23:18,400 --> 09:23:24,360
I additionally tell C get the address of

14875
09:23:21,400 --> 09:23:25,840
n so I'm changing percent I to percent p

14876
09:23:24,360 --> 09:23:28,276
and that's just something you have to do

14877
09:23:25,840 --> 09:23:30,359
when printing addresses for now but I

14878
09:23:28,276 --> 09:23:32,119
need to change an ampersand in front of

14879
09:23:30,360 --> 09:23:34,720
the variable name so I don't print in

14880
09:23:32,120 --> 09:23:36,596
the number 50 I print out something like

14881
09:23:34,720 --> 09:23:37,800
ox123 and it's not going to be as simple

14882
09:23:36,596 --> 09:23:39,720
as that we'll see on the screen though

14883
09:23:37,800 --> 09:23:43,080
where it actually ended up in my code

14884
09:23:39,720 --> 09:23:45,520
spaces memory so here we go uh dot uh

14885
09:23:43,080 --> 09:23:49,200
down in my terminal make addresses again

14886
09:23:45,520 --> 09:23:51,960
to recompile and now dot SL addresses

14887
09:23:49,200 --> 09:23:55,916
should reveal not the value of 50 but

14888
09:23:51,960 --> 09:23:57,916
the address of 50 and there it is it's

14889
09:23:55,916 --> 09:23:59,916
pretty long it's not quite as simple and

14890
09:23:57,916 --> 09:24:01,960
pretty as ox123 but there's the ox

14891
09:23:59,916 --> 09:24:06,916
meaning here's a hexadecimal address and

14892
09:24:01,960 --> 09:24:08,436
it's 7f FC c784 a04 C suffice it to say

14893
09:24:06,916 --> 09:24:10,960
your codes space and even your Macs and

14894
09:24:08,436 --> 09:24:13,520
PCs nowadays have a lot of memory that's

14895
09:24:10,960 --> 09:24:16,520
why in part this address is so big not

14896
09:24:13,520 --> 09:24:19,880
as small as the thing on my slide so

14897
09:24:16,520 --> 09:24:21,799
this at the moment isn't that useful yet

14898
09:24:19,880 --> 09:24:24,719
but it introduces us to a concept that

14899
09:24:21,800 --> 09:24:27,276
we'll Now call pointers and pointers are

14900
09:24:24,720 --> 09:24:29,840
admittedly one of the more challenging

14901
09:24:27,276 --> 09:24:31,880
aspects of c and if in future life you

14902
09:24:29,840 --> 09:24:33,640
tell friends that oh I took a class

14903
09:24:31,880 --> 09:24:35,079
called cs50 and we learned C like you'll

14904
09:24:33,640 --> 09:24:37,360
probably get kind of a look at people

14905
09:24:35,080 --> 09:24:40,080
like why did you learn C or like oh c

14906
09:24:37,360 --> 09:24:42,596
was hard and it's largely because of

14907
09:24:40,080 --> 09:24:45,160
this topic which isn't to say that it's

14908
09:24:42,596 --> 09:24:46,520
that hard to wrap your mind around but

14909
09:24:45,160 --> 09:24:48,840
it's definitely very different and it's

14910
09:24:46,520 --> 09:24:50,596
not a feature that you can harness in

14911
09:24:48,840 --> 09:24:53,320
higher level languages that we'll see in

14912
09:24:50,596 --> 09:24:55,276
class two like Python and Java and the

14913
09:24:53,320 --> 09:24:56,916
like C is about as close to the

14914
09:24:55,276 --> 09:24:59,240
computer's Hardware so to speak that you

14915
09:24:56,916 --> 09:25:00,960
can get before things get actually scary

14916
09:24:59,240 --> 09:25:02,840
the so-called Assembly Language we saw

14917
09:25:00,960 --> 09:25:04,680
in week two when I had a link and

14918
09:25:02,840 --> 09:25:06,240
compile and assemble and all of that

14919
09:25:04,680 --> 09:25:07,756
like that gets really lowlevel and you

14920
09:25:06,240 --> 09:25:09,880
really have to be an expert with the

14921
09:25:07,756 --> 09:25:12,276
computer's CPU or brain to understand

14922
09:25:09,880 --> 09:25:13,960
that but with C you can actually poke

14923
09:25:12,276 --> 09:25:15,799
around the computer's memory and do

14924
09:25:13,960 --> 09:25:17,640
powerful things with that but again with

14925
09:25:15,800 --> 09:25:20,360
great power comes responsibility it's

14926
09:25:17,640 --> 09:25:22,159
very easy to break programs by misusing

14927
09:25:20,360 --> 09:25:25,320
memory or just having a bug that touches

14928
09:25:22,160 --> 09:25:28,916
memory in some way that you don't intend

14929
09:25:25,320 --> 09:25:31,320
so pointers at the end of the day are

14930
09:25:28,916 --> 09:25:33,880
pretty much what we just saw a pointer

14931
09:25:31,320 --> 09:25:37,720
is really just a variable that contains

14932
09:25:33,880 --> 09:25:39,159
the address of some value a pointer is a

14933
09:25:37,720 --> 09:25:41,120
variable that contains the address of

14934
09:25:39,160 --> 09:25:42,800
some value or more simply it's fine to

14935
09:25:41,120 --> 09:25:44,436
think of it as an address a pointer is

14936
09:25:42,800 --> 09:25:46,916
an address of something in the

14937
09:25:44,436 --> 09:25:50,120
computer's memory now what might we do

14938
09:25:46,916 --> 09:25:52,560
to uh to uh actualize this well here's

14939
09:25:50,120 --> 09:25:54,756
two lines of code it turns out by using

14940
09:25:52,560 --> 09:25:57,560
our two new operators today I can

14941
09:25:54,756 --> 09:26:00,240
declare an INT call it n and assign it a

14942
09:25:57,560 --> 09:26:03,276
value like 50 just like before if I want

14943
09:26:00,240 --> 09:26:04,880
to store the address of n in a variable

14944
09:26:03,276 --> 09:26:07,320
and not just print it immediately via

14945
09:26:04,880 --> 09:26:09,079
printf I can declare a variable for

14946
09:26:07,320 --> 09:26:11,120
instance called P but I could call it

14947
09:26:09,080 --> 09:26:14,040
anything I want like any variable but

14948
09:26:11,120 --> 09:26:17,480
because it's an address it's not int P

14949
09:26:14,040 --> 09:26:19,720
it has to be int star P so to speak and

14950
09:26:17,480 --> 09:26:21,960
the star here on the left hand side of

14951
09:26:19,720 --> 09:26:25,200
the equal sign is just a clue to C that

14952
09:26:21,960 --> 09:26:27,720
means p is going to be a pointer that is

14953
09:26:25,200 --> 09:26:30,119
p is going to be the address of what the

14954
09:26:27,720 --> 09:26:31,480
address of an integer now technically

14955
09:26:30,120 --> 09:26:33,040
it's still an integer itself right

14956
09:26:31,480 --> 09:26:35,680
because an address is just a number

14957
09:26:33,040 --> 09:26:38,160
whether it's 1 2 3 or ox123 so this is

14958
09:26:35,680 --> 09:26:40,120
really just a semantic difference so in

14959
09:26:38,160 --> 09:26:42,640
Star p just means that this variable

14960
09:26:40,120 --> 09:26:44,840
doesn't contain any old number like 50

14961
09:26:42,640 --> 09:26:46,800
it specifically contains a number that

14962
09:26:44,840 --> 09:26:49,719
is the address of something

14963
09:26:46,800 --> 09:26:52,120
else so how can I now use this well let

14964
09:26:49,720 --> 09:26:55,320
me go back to VSS code and let me

14965
09:26:52,120 --> 09:26:56,800
propose that we add a line of code like

14966
09:26:55,320 --> 09:26:58,640
that so instead of just directly

14967
09:26:56,800 --> 09:27:01,160
printing out that value let's go ahead

14968
09:26:58,640 --> 09:27:04,479
and Define a second variable called uh P

14969
09:27:01,160 --> 09:27:08,040
that's of type in Star P set it equal to

14970
09:27:04,480 --> 09:27:09,720
Ampersand n and then this time let's not

14971
09:27:08,040 --> 09:27:11,916
just print out Amper sand n let's

14972
09:27:09,720 --> 09:27:13,800
actually print out the value of P so the

14973
09:27:11,916 --> 09:27:16,360
only two new things here if I zoom in

14974
09:27:13,800 --> 09:27:18,480
are I've used not only the Amper sand on

14975
09:27:16,360 --> 09:27:21,200
the right to get the address of n I'm

14976
09:27:18,480 --> 09:27:23,596
now using the star on the Left To Tell C

14977
09:27:21,200 --> 09:27:26,039
that P is still a still a variable as

14978
09:27:23,596 --> 09:27:29,000
always but it's a pointer it is the

14979
09:27:26,040 --> 09:27:30,080
address of some other value like this

14980
09:27:29,000 --> 09:27:31,720
and I'm still going to print it with the

14981
09:27:30,080 --> 09:27:33,360
same format code percent P so that

14982
09:27:31,720 --> 09:27:37,840
doesn't change so let me go ahead and

14983
09:27:33,360 --> 09:27:40,680
zoom out and do make addresses and slash

14984
09:27:37,840 --> 09:27:43,399
addresses and there it is exactly the

14985
09:27:40,680 --> 09:27:46,120
same thing now in and of itself not that

14986
09:27:43,400 --> 09:27:48,360
useful yet but the fact that you can now

14987
09:27:46,120 --> 09:27:50,756
access the addresses of things in memory

14988
09:27:48,360 --> 09:27:52,720
means that we'll be able to build things

14989
09:27:50,756 --> 09:27:55,080
and construct things and Link things

14990
09:27:52,720 --> 09:27:57,756
together by knowing where they live so

14991
09:27:55,080 --> 09:27:58,950
to speak so any questions on this

14992
09:27:57,756 --> 09:28:02,050
technique thus far

14993
09:27:58,950 --> 09:28:02,049
[Music]

14994
09:28:02,360 --> 09:28:07,880
yeah a good question on line six must it

14995
09:28:05,040 --> 09:28:10,160
be starp and Ampersand and in this case

14996
09:28:07,880 --> 09:28:11,596
yes because what am I doing on the left

14997
09:28:10,160 --> 09:28:14,400
and I'll get rid of the equal sign for

14998
09:28:11,596 --> 09:28:16,960
now this would give me a variable called

14999
09:28:14,400 --> 09:28:18,840
P that's not an integer per se but

15000
09:28:16,960 --> 09:28:20,560
that's the address of an integer but

15001
09:28:18,840 --> 09:28:22,799
without the equal sign I'm not storing

15002
09:28:20,560 --> 09:28:27,240
anything in that variable so by adding

15003
09:28:22,800 --> 09:28:29,436
the equal sign and then Ampersand N I am

15004
09:28:27,240 --> 09:28:31,276
explicitly figuring out with Ampersand

15005
09:28:29,436 --> 09:28:34,080
what the address of n is which already

15006
09:28:31,276 --> 09:28:36,276
exists per line five and tucking it away

15007
09:28:34,080 --> 09:28:40,240
in this new variable called

15008
09:28:36,276 --> 09:28:42,520
P other questions yeah every time you

15009
09:28:40,240 --> 09:28:44,079
run good question every time I run the

15010
09:28:42,520 --> 09:28:46,596
program it uses up a different piece of

15011
09:28:44,080 --> 09:28:47,880
memory short answer yes computers though

15012
09:28:46,596 --> 09:28:49,720
long story short also have something

15013
09:28:47,880 --> 09:28:51,000
called virtual memory so if you run it

15014
09:28:49,720 --> 09:28:53,240
again and again you might actually see

15015
09:28:51,000 --> 09:28:55,560
the same addresses on the same Mac or PC

15016
09:28:53,240 --> 09:28:58,119
or cloud-based server but we'll see in a

15017
09:28:55,560 --> 09:29:00,560
bit where uh at a high level it's laid

15018
09:28:58,120 --> 09:29:05,000
out but it will always exist at some

15019
09:29:00,560 --> 09:29:07,916
address good question yeah some correct

15020
09:29:05,000 --> 09:29:09,320
Ampersand n is the address of N and in

15021
09:29:07,916 --> 09:29:13,040
Star p

15022
09:29:09,320 --> 09:29:15,756
is a pointer called p and honestly in an

15023
09:29:13,040 --> 09:29:17,560
Ideal World if C were made today and not

15024
09:29:15,756 --> 09:29:19,840
decades ago when humans were first

15025
09:29:17,560 --> 09:29:21,560
creating languages you know ideally we

15026
09:29:19,840 --> 09:29:23,276
would just have a data type called

15027
09:29:21,560 --> 09:29:24,960
pointer and then this would be a little

15028
09:29:23,276 --> 09:29:26,479
less complicated because it would

15029
09:29:24,960 --> 09:29:28,159
literally be what it says you know the

15030
09:29:26,480 --> 09:29:30,240
humans who invented SE didn't do this

15031
09:29:28,160 --> 09:29:32,560
but this is the idea so pointer is not a

15032
09:29:30,240 --> 09:29:34,916
legitimate word in the code it is a term

15033
09:29:32,560 --> 09:29:37,079
of Art in English but this is really

15034
09:29:34,916 --> 09:29:39,719
just the idea but the way you express

15035
09:29:37,080 --> 09:29:43,680
pointer as a data type type is a little

15036
09:29:39,720 --> 09:29:47,756
more cryptic as int star P here but

15037
09:29:43,680 --> 09:29:49,160
notice in line seven when I print out p

15038
09:29:47,756 --> 09:29:50,916
i don't use a star I don't use an

15039
09:29:49,160 --> 09:29:52,320
ampersand y I literally just want to

15040
09:29:50,916 --> 09:29:53,719
print the value of p and we've been

15041
09:29:52,320 --> 09:29:55,480
doing that since week one if you want to

15042
09:29:53,720 --> 09:29:58,560
print a variable just describe the

15043
09:29:55,480 --> 09:30:01,000
variable by its name no special syntax

15044
09:29:58,560 --> 09:30:03,640
any other questions on this thus

15045
09:30:01,000 --> 09:30:06,200
far uh what's the advantage of using

15046
09:30:03,640 --> 09:30:08,320
pointers with pointers we'll see today

15047
09:30:06,200 --> 09:30:09,840
some applications of them really the

15048
09:30:08,320 --> 09:30:11,276
idea is going to come to fruition next

15049
09:30:09,840 --> 09:30:13,399
week when we're going to create what are

15050
09:30:11,276 --> 09:30:15,520
called uh data structures in memory

15051
09:30:13,400 --> 09:30:17,520
where we can build not just uh for

15052
09:30:15,520 --> 09:30:19,359
instance uh one-dimensional data

15053
09:30:17,520 --> 09:30:20,359
structures like an array we'll see next

15054
09:30:19,360 --> 09:30:22,000
week we can actually create the

15055
09:30:20,360 --> 09:30:23,596
equivalent of two-dimensional data

15056
09:30:22,000 --> 09:30:25,756
structures or even threedimensional data

15057
09:30:23,596 --> 09:30:27,276
structures by using these addresses and

15058
09:30:25,756 --> 09:30:28,480
sort of linking things together and

15059
09:30:27,276 --> 09:30:30,880
we'll see the beginnings of that this

15060
09:30:28,480 --> 09:30:32,640
week but for now focus at least for now

15061
09:30:30,880 --> 09:30:34,755
on just really the syntax and what these

15062
09:30:32,640 --> 09:30:39,159
building blocks can do for us um does

15063
09:30:34,756 --> 09:30:41,276
the poin have to be does the p uh in

15064
09:30:39,160 --> 09:30:42,800
does the pop pointer have to be an point

15065
09:30:41,276 --> 09:30:44,276
to an integer short answer no and we'll

15066
09:30:42,800 --> 09:30:45,520
come back to this for now for the sake

15067
09:30:44,276 --> 09:30:47,560
of discussion we're only dealing with

15068
09:30:45,520 --> 09:30:49,399
integers like the number 50 uh you

15069
09:30:47,560 --> 09:30:51,960
mentioned strings or characters

15070
09:30:49,400 --> 09:30:53,880
absolutely we're about to go there soon

15071
09:30:51,960 --> 09:30:55,720
so you can use the address of anything

15072
09:30:53,880 --> 09:30:57,880
you want in the computer's memory so in

15073
09:30:55,720 --> 09:30:59,200
fact let's translate this now to just

15074
09:30:57,880 --> 09:31:00,755
the same picture just to help you wrap

15075
09:30:59,200 --> 09:31:03,000
your minds around what these two lines

15076
09:31:00,756 --> 09:31:04,960
of code really fundamentally are doing

15077
09:31:03,000 --> 09:31:07,520
so if I come back to my grid of memory

15078
09:31:04,960 --> 09:31:09,120
here let's plop the number 50 in the

15079
09:31:07,520 --> 09:31:10,840
variable n at the bottom right like it

15080
09:31:09,120 --> 09:31:13,276
was before so this is that first line of

15081
09:31:10,840 --> 09:31:16,240
code as before but with the new second

15082
09:31:13,276 --> 09:31:19,560
line of code as soon as I create P what

15083
09:31:16,240 --> 09:31:21,240
do I do well first remember that n lives

15084
09:31:19,560 --> 09:31:22,799
somewhere in the computer's memory

15085
09:31:21,240 --> 09:31:24,240
usually I don't care precisely where it

15086
09:31:22,800 --> 09:31:26,596
is but for the sake of discussion let's

15087
09:31:24,240 --> 09:31:28,756
suppose it's at ox123 which is easier to

15088
09:31:26,596 --> 09:31:30,840
say than where it actually ended up and

15089
09:31:28,756 --> 09:31:32,800
now what is p well p is just another

15090
09:31:30,840 --> 09:31:35,119
variable and variables live in memory

15091
09:31:32,800 --> 09:31:39,120
too so let me just hypothesize that P

15092
09:31:35,120 --> 09:31:41,160
lives up here and it turns out that P

15093
09:31:39,120 --> 09:31:44,320
once you assign it the value of

15094
09:31:41,160 --> 09:31:46,916
Ampersand N means that c will take a

15095
09:31:44,320 --> 09:31:49,720
look at the variable n realize oh it

15096
09:31:46,916 --> 09:31:52,640
lives at ox123 and what goes in the

15097
09:31:49,720 --> 09:31:55,240
value of p is literally

15098
09:31:52,640 --> 09:31:57,120
ox123 so again it's still an integer

15099
09:31:55,240 --> 09:31:59,880
which is confusing but it's technically

15100
09:31:57,120 --> 09:32:02,596
an integer being used as an address and

15101
09:31:59,880 --> 09:32:04,040
now just a a prompt here notice that

15102
09:32:02,596 --> 09:32:06,435
this pointer is pretty darn big it's

15103
09:32:04,040 --> 09:32:07,800
like eight squares what's the

15104
09:32:06,436 --> 09:32:09,080
implication of that because I did that

15105
09:32:07,800 --> 09:32:11,240
deliberately

15106
09:32:09,080 --> 09:32:14,200
how big must a pointer apparently be in

15107
09:32:11,240 --> 09:32:15,479
most modern systems would you say okay

15108
09:32:14,200 --> 09:32:17,240
good computers today are very big you

15109
09:32:15,480 --> 09:32:18,720
have gigabytes of RAM in your computer

15110
09:32:17,240 --> 09:32:20,079
you therefore need big pointers to be

15111
09:32:18,720 --> 09:32:21,840
able to point at memory that's

15112
09:32:20,080 --> 09:32:23,320
conceptually pretty far away so to be

15113
09:32:21,840 --> 09:32:25,596
clear how many bytes does a pointer

15114
09:32:23,320 --> 09:32:27,840
apparently take up well it seems to take

15115
09:32:25,596 --> 09:32:29,840
up eight in total integers by convention

15116
09:32:27,840 --> 09:32:32,079
nowadays are usually four pointers

15117
09:32:29,840 --> 09:32:33,560
though nowadays are typically eight in

15118
09:32:32,080 --> 09:32:34,960
this case so I'm drawing it in a manner

15119
09:32:33,560 --> 09:32:36,560
consistent with the reality even though

15120
09:32:34,960 --> 09:32:38,479
at the end of the day it's not really

15121
09:32:36,560 --> 09:32:41,079
that interesting what values are in here

15122
09:32:38,480 --> 09:32:42,560
in fact let's emerge from these weeds I

15123
09:32:41,080 --> 09:32:44,240
don't really care what else is going on

15124
09:32:42,560 --> 09:32:45,596
in my computer's memory at the moment

15125
09:32:44,240 --> 09:32:48,640
because I've only got those two lines of

15126
09:32:45,596 --> 09:32:50,596
Juicy code defining n and defining P so

15127
09:32:48,640 --> 09:32:52,360
let's hide all of the other squares and

15128
09:32:50,596 --> 09:32:55,756
honestly I mean it when I say that

15129
09:32:52,360 --> 09:32:57,720
programmers need to know that a variable

15130
09:32:55,756 --> 09:32:59,680
exists somewhere in memory and needs to

15131
09:32:57,720 --> 09:33:01,596
be able to get that address using like

15132
09:32:59,680 --> 09:33:04,080
the Ampersand but you're never going to

15133
09:33:01,596 --> 09:33:06,200
print F like I did the actual address

15134
09:33:04,080 --> 09:33:07,800
like it's not generally interesting

15135
09:33:06,200 --> 09:33:09,079
unless you're debugging your code but

15136
09:33:07,800 --> 09:33:11,276
you're not going to like start typing

15137
09:33:09,080 --> 09:33:13,040
out crazy Ox numbers in your code to

15138
09:33:11,276 --> 09:33:15,040
move things around you just need to know

15139
09:33:13,040 --> 09:33:17,756
that the computer can figure out where

15140
09:33:15,040 --> 09:33:20,200
things are so frankly by that logic who

15141
09:33:17,756 --> 09:33:23,160
cares that it's ox123 right tomorrow it

15142
09:33:20,200 --> 09:33:25,479
could be Ox 456 or something else so one

15143
09:33:23,160 --> 09:33:28,596
of the ways to think of a pointer is

15144
09:33:25,480 --> 09:33:32,040
literally as a variable that points at

15145
09:33:28,596 --> 09:33:33,840
something else and indeed in this case P

15146
09:33:32,040 --> 09:33:36,080
yeah technically it has an address and

15147
09:33:33,840 --> 09:33:37,640
yeah technically it's ox123 in the story

15148
09:33:36,080 --> 09:33:41,560
but honestly who cares I just need to

15149
09:33:37,640 --> 09:33:44,240
know that you using p i can get to the

15150
09:33:41,560 --> 09:33:45,520
value n and so what are these addresses

15151
09:33:44,240 --> 09:33:47,799
and in fact if Carter wouldn't mind

15152
09:33:45,520 --> 09:33:49,039
joining me up here for a moment what are

15153
09:33:47,800 --> 09:33:50,840
these addresses well just like in our

15154
09:33:49,040 --> 09:33:51,720
human world we have mailboxes even

15155
09:33:50,840 --> 09:33:53,320
though you might not check it very

15156
09:33:51,720 --> 09:33:55,916
frequently nowadays but to get physical

15157
09:33:53,320 --> 09:33:58,040
mail every uh home every business has a

15158
09:33:55,916 --> 09:34:00,159
unique address the uh science and

15159
09:33:58,040 --> 09:34:03,840
engineering complex is 150 Western

15160
09:34:00,160 --> 09:34:05,320
Avenue Austin Massachusetts 02134 USA

15161
09:34:03,840 --> 09:34:07,840
and theoretically that uniquely

15162
09:34:05,320 --> 09:34:10,240
identifies that building in the world

15163
09:34:07,840 --> 09:34:13,240
well here we we have two mailboxes um

15164
09:34:10,240 --> 09:34:16,079
over here we have a value n that happens

15165
09:34:13,240 --> 09:34:18,680
to live I'll claim it address ox123 and

15166
09:34:16,080 --> 09:34:21,596
then over here I claim there's another

15167
09:34:18,680 --> 09:34:23,116
address uh called by name p i don't

15168
09:34:21,596 --> 09:34:24,399
actually care where it is even though it

15169
09:34:23,116 --> 09:34:26,680
definitely exists somewhere in the

15170
09:34:24,400 --> 09:34:29,240
computer's memory but if this is p which

15171
09:34:26,680 --> 09:34:31,480
is a variable and that's n another

15172
09:34:29,240 --> 09:34:33,200
variable ideally this mailbox would be

15173
09:34:31,480 --> 09:34:34,720
twice as big because of the number of

15174
09:34:33,200 --> 09:34:36,960
btes using but Home Depot only had

15175
09:34:34,720 --> 09:34:39,000
identical size mailboxes but here is p

15176
09:34:36,960 --> 09:34:43,040
one variable there is in another

15177
09:34:39,000 --> 09:34:45,400
variable if I open up this mailbox what

15178
09:34:43,040 --> 09:34:48,160
should I find inside of it based on our

15179
09:34:45,400 --> 09:34:50,116
story thus far like what value will I

15180
09:34:48,160 --> 09:34:54,436
pull out dramatically in just a

15181
09:34:50,116 --> 09:34:55,596
moment yeah I think ox1 123 Now using

15182
09:34:54,436 --> 09:34:57,720
this you can kind of think of this as

15183
09:34:55,596 --> 09:34:59,399
like x marks the spot no pun intended

15184
09:34:57,720 --> 09:35:02,276
where I can now like walk around the

15185
09:34:59,400 --> 09:35:03,680
computer's memory and find my way to

15186
09:35:02,276 --> 09:35:05,079
that location by sort of following the

15187
09:35:03,680 --> 09:35:07,080
treasure map or if I want it more

15188
09:35:05,080 --> 09:35:08,880
dramatically uh thanks to our little

15189
09:35:07,080 --> 09:35:10,800
Yale foam finger here here you can think

15190
09:35:08,880 --> 09:35:13,115
of it more abstractly as p is just

15191
09:35:10,800 --> 09:35:14,596
pointing at n okay that's not going over

15192
09:35:13,116 --> 09:35:17,880
well so let's switch over to the Harvard

15193
09:35:14,596 --> 09:35:17,880
one so p is

15194
09:35:19,000 --> 09:35:24,160
pointing so p is pointing at n and so it

15195
09:35:22,240 --> 09:35:26,436
turns out we will be able to write code

15196
09:35:24,160 --> 09:35:28,436
now that will do the equivalent of me

15197
09:35:26,436 --> 09:35:29,916
walking over to n but for now Carter if

15198
09:35:28,436 --> 09:35:33,436
you want to reveal what's in the mailbox

15199
09:35:29,916 --> 09:35:35,159
we should see indeed the number 50 so

15200
09:35:33,436 --> 09:35:36,756
that's really all that's oh I feel

15201
09:35:35,160 --> 09:35:40,116
Carter's waiting for Applause so like

15202
09:35:36,756 --> 09:35:40,116
really well nicely done

15203
09:35:42,320 --> 09:35:46,276
thank you so that's just like a physical

15204
09:35:44,160 --> 09:35:47,960
metaphor of what's going on here in one

15205
09:35:46,276 --> 09:35:49,400
variable we have an address and that

15206
09:35:47,960 --> 09:35:51,560
variable by convention is called a

15207
09:35:49,400 --> 09:35:54,320
pointer in the other variable per week

15208
09:35:51,560 --> 09:35:57,079
one we just have a value like n and you

15209
09:35:54,320 --> 09:35:58,436
can yes follow the map and walk yourself

15210
09:35:57,080 --> 09:36:00,560
to that particular address and we'll see

15211
09:35:58,436 --> 09:36:02,160
how to do that in code but what's really

15212
09:36:00,560 --> 09:36:04,079
interesting is this abstraction that

15213
09:36:02,160 --> 09:36:07,200
pointers literally or really I guess

15214
09:36:04,080 --> 09:36:09,960
figuratively point at some other value

15215
09:36:07,200 --> 09:36:11,916
in memory all right questions then on

15216
09:36:09,960 --> 09:36:13,560
pointers in this form pointers point to

15217
09:36:11,916 --> 09:36:15,560
each other can pointers point to each

15218
09:36:13,560 --> 09:36:17,159
other so yes there's things called

15219
09:36:15,560 --> 09:36:19,756
double pointers we're not going to see

15220
09:36:17,160 --> 09:36:22,240
them anytime soon but using star star

15221
09:36:19,756 --> 09:36:24,596
you can express an address of an address

15222
09:36:22,240 --> 09:36:27,079
um but we won't see that just yet other

15223
09:36:24,596 --> 09:36:30,435
questions on

15224
09:36:27,080 --> 09:36:30,436
pointers yeah in

15225
09:36:31,560 --> 09:36:37,040
front our array so to summarize our

15226
09:36:34,520 --> 09:36:38,359
arrays then pointers so short answer

15227
09:36:37,040 --> 09:36:40,040
there's a relationship and we'll come

15228
09:36:38,360 --> 09:36:42,080
back to that in a little bit but arrays

15229
09:36:40,040 --> 09:36:43,436
are technically different from pointers

15230
09:36:42,080 --> 09:36:45,200
but we we're going to be able to blur

15231
09:36:43,436 --> 09:36:46,680
the lines a little bit by using one like

15232
09:36:45,200 --> 09:36:49,079
the other but let me come back to that

15233
09:36:46,680 --> 09:36:52,240
in just a bit of time all right so if we

15234
09:36:49,080 --> 09:36:54,960
have now this mental model if you will

15235
09:36:52,240 --> 09:36:57,596
of like what a pointer is in memory I

15236
09:36:54,960 --> 09:36:59,360
think we can start to peel back a layer

15237
09:36:57,596 --> 09:37:00,960
of uh simplification that we've been

15238
09:36:59,360 --> 09:37:03,720
assuming for the past few weeks since

15239
09:37:00,960 --> 09:37:05,200
week one so a string recall is a

15240
09:37:03,720 --> 09:37:07,080
sequence of characters and so if you

15241
09:37:05,200 --> 09:37:08,916
want to create a string that says Hi in

15242
09:37:07,080 --> 09:37:11,400
all caps and an next exclamation point

15243
09:37:08,916 --> 09:37:12,840
we do string s equals quote unquote high

15244
09:37:11,400 --> 09:37:14,640
and we can hard code it like this or we

15245
09:37:12,840 --> 09:37:16,359
could use get string but for now just

15246
09:37:14,640 --> 09:37:19,159
assume that I hardcoded it into my code

15247
09:37:16,360 --> 09:37:20,880
to always say hi in all caps with an

15248
09:37:19,160 --> 09:37:22,680
exclamation point well what does that

15249
09:37:20,880 --> 09:37:24,560
look like in the computer's memory well

15250
09:37:22,680 --> 09:37:26,080
let's stop looking at the entire memory

15251
09:37:24,560 --> 09:37:29,916
let's just focus on really what's going

15252
09:37:26,080 --> 09:37:32,640
on once you create a string called s and

15253
09:37:29,916 --> 09:37:35,399
store in it hi you know that a couple of

15254
09:37:32,640 --> 09:37:36,960
things are happening H and I and the

15255
09:37:35,400 --> 09:37:39,916
exclamation point are ending up in the

15256
09:37:36,960 --> 09:37:41,916
computer's memory we know from week two

15257
09:37:39,916 --> 09:37:45,479
that this thing the so-called null

15258
09:37:41,916 --> 09:37:47,320
character n AKA back slz is also being

15259
09:37:45,480 --> 09:37:48,916
added for you and it's somewhere in

15260
09:37:47,320 --> 09:37:50,480
memory at the moment I don't really care

15261
09:37:48,916 --> 09:37:51,960
where I drew it at the bottom right yes

15262
09:37:50,480 --> 09:37:53,960
it has an address but for now it just

15263
09:37:51,960 --> 09:37:57,560
ends up somewhere and in fact here's a

15264
09:37:53,960 --> 09:38:00,116
little visual cue as to how this happens

15265
09:37:57,560 --> 09:38:02,479
in C anytime you use double quotes to

15266
09:38:00,116 --> 09:38:04,800
give you a string you can imagine that

15267
09:38:02,480 --> 09:38:07,320
the double quotes are like a a clue to

15268
09:38:04,800 --> 09:38:09,320
not only store Hi exclamation point but

15269
09:38:07,320 --> 09:38:11,240
also put the null character there for

15270
09:38:09,320 --> 09:38:13,400
you and this is in contrast to what

15271
09:38:11,240 --> 09:38:15,276
chars if you want individual characters

15272
09:38:13,400 --> 09:38:17,756
what syntax did we use

15273
09:38:15,276 --> 09:38:20,276
instead so single quotes single quotes

15274
09:38:17,756 --> 09:38:22,116
do not add magically a back SL zero they

15275
09:38:20,276 --> 09:38:23,479
literally just store one character so

15276
09:38:22,116 --> 09:38:25,720
again strings have always been a little

15277
09:38:23,480 --> 09:38:27,800
special you get some extra an extra bite

15278
09:38:25,720 --> 09:38:29,360
for free so that you know where the

15279
09:38:27,800 --> 09:38:31,436
string ends and functions like stir

15280
09:38:29,360 --> 09:38:33,720
compare can then find their way there so

15281
09:38:31,436 --> 09:38:36,960
in memory it might indeed look a little

15282
09:38:33,720 --> 09:38:38,756
like this and if we assume that there's

15283
09:38:36,960 --> 09:38:39,640
going to be somewhere in memory these

15284
09:38:38,756 --> 09:38:41,960
things are going to be somewhere in

15285
09:38:39,640 --> 09:38:43,436
memory we can address them per week two

15286
09:38:41,960 --> 09:38:45,720
by way of the name of the variable so if

15287
09:38:43,436 --> 09:38:46,880
s is the name of the variable S braet 0

15288
09:38:45,720 --> 09:38:48,756
is how you would refer to the first

15289
09:38:46,880 --> 09:38:50,719
letter s bracket 1 s braet two and if

15290
09:38:48,756 --> 09:38:53,560
you really want s bracket 3 would get

15291
09:38:50,720 --> 09:38:57,160
you at the uh null character at the very

15292
09:38:53,560 --> 09:38:59,640
end but what is s so technically in this

15293
09:38:57,160 --> 09:39:02,320
line of code here not only is the

15294
09:38:59,640 --> 09:39:05,840
computer giving you memory for h i

15295
09:39:02,320 --> 09:39:07,916
exclamation point back sl0 we turns out

15296
09:39:05,840 --> 09:39:09,479
that s itself must take up some amount

15297
09:39:07,916 --> 09:39:10,560
of space right because s is the variable

15298
09:39:09,480 --> 09:39:11,916
and every time we' talked about

15299
09:39:10,560 --> 09:39:13,680
variables thus far I've given you a

15300
09:39:11,916 --> 09:39:16,079
rectangle on the screen in which to

15301
09:39:13,680 --> 09:39:18,800
store its value so let's assume for the

15302
09:39:16,080 --> 09:39:22,240
sake of discussion that the H is at

15303
09:39:18,800 --> 09:39:24,160
ox123 and I is at o x124 exclamation

15304
09:39:22,240 --> 09:39:28,520
points at o x125 and the null characters

15305
09:39:24,160 --> 09:39:30,116
at ox1 126 well what then is s well s is

15306
09:39:28,520 --> 09:39:31,799
just going to be some other variable and

15307
09:39:30,116 --> 09:39:33,880
I'll draw it somewhat abstractly without

15308
09:39:31,800 --> 09:39:35,360
all the other boxes up here and I'll

15309
09:39:33,880 --> 09:39:39,040
claim that the name of this variable is

15310
09:39:35,360 --> 09:39:42,040
s but it turns out what is s really how

15311
09:39:39,040 --> 09:39:44,960
do strings Really Work Well s is a

15312
09:39:42,040 --> 09:39:46,360
variable and has been since week one but

15313
09:39:44,960 --> 09:39:48,200
when you define it what the computer is

15314
09:39:46,360 --> 09:39:50,596
doing for you automatically is when it

15315
09:39:48,200 --> 09:39:52,520
knows you want to store Hi exclamation

15316
09:39:50,596 --> 09:39:54,360
point it puts that somewhere in memory

15317
09:39:52,520 --> 09:39:56,039
the computer then figures out for you

15318
09:39:54,360 --> 09:39:59,040
what's the address of the very first

15319
09:39:56,040 --> 09:40:01,160
character and it stores that address and

15320
09:39:59,040 --> 09:40:03,080
only that address in the variable you

15321
09:40:01,160 --> 09:40:05,360
created on the left hand side of the

15322
09:40:03,080 --> 09:40:07,360
equal sign and that's enough like to

15323
09:40:05,360 --> 09:40:09,276
represent a string with three letters of

15324
09:40:07,360 --> 09:40:12,080
the alph alphabet or punctuation you

15325
09:40:09,276 --> 09:40:14,560
don't need three variables you just need

15326
09:40:12,080 --> 09:40:17,680
one you just need to know the beginning

15327
09:40:14,560 --> 09:40:19,799
of the string why why is it sufficient

15328
09:40:17,680 --> 09:40:24,116
for a variable to Only Store the first

15329
09:40:19,800 --> 09:40:24,116
byes address and not all of the bytes

15330
09:40:24,756 --> 09:40:30,400
addresses exactly because of the design

15331
09:40:27,276 --> 09:40:32,560
of strings per week two we always null

15332
09:40:30,400 --> 09:40:34,240
terminate them so it suffices to only

15333
09:40:32,560 --> 09:40:35,720
remember the first bites address because

15334
09:40:34,240 --> 09:40:37,756
from there you can sort of follow the

15335
09:40:35,720 --> 09:40:40,116
breadcrumbs bite after bite after bite

15336
09:40:37,756 --> 09:40:41,916
and until you see the new line Sorry the

15337
09:40:40,116 --> 09:40:44,000
the null character you know that all of

15338
09:40:41,916 --> 09:40:46,159
those characters are apparently part of

15339
09:40:44,000 --> 09:40:48,116
the same string so this is what's been

15340
09:40:46,160 --> 09:40:50,116
going on in the me computer's memory all

15341
09:40:48,116 --> 09:40:52,200
since week one and in fact if we

15342
09:40:50,116 --> 09:40:56,640
abstract this away you can really think

15343
09:40:52,200 --> 09:40:59,596
of s as being just this really a pointer

15344
09:40:56,640 --> 09:41:02,000
to that chunk of memory so in fact what

15345
09:40:59,596 --> 09:41:04,320
do we have here well in the left to

15346
09:41:02,000 --> 09:41:06,480
recap on the code here on the left hand

15347
09:41:04,320 --> 09:41:08,436
side string that's what ensures that

15348
09:41:06,480 --> 09:41:10,400
we'll actually be able to store a string

15349
09:41:08,436 --> 09:41:12,840
in a variable called s we're going to

15350
09:41:10,400 --> 09:41:14,240
have on the uh right hand side though

15351
09:41:12,840 --> 09:41:16,240
the actual value so let me switch back

15352
09:41:14,240 --> 09:41:18,560
to VSS code here and let me change my

15353
09:41:16,240 --> 09:41:22,840
code to no longer involve integers alone

15354
09:41:18,560 --> 09:41:24,596
so I'm going to add the uh cs50 Library

15355
09:41:22,840 --> 09:41:26,916
just so that I can use some shortcuts in

15356
09:41:24,596 --> 09:41:28,115
there cs50.h and then in my main

15357
09:41:26,916 --> 09:41:30,399
function I'm going to go ahead and do

15358
09:41:28,116 --> 09:41:32,360
this string s equals quote unquote high

15359
09:41:30,400 --> 09:41:33,436
in all caps exclamation point and then

15360
09:41:32,360 --> 09:41:36,480
I'm going to go ahead and print out

15361
09:41:33,436 --> 09:41:38,436
using percent S as always back sln the

15362
09:41:36,480 --> 09:41:40,000
value of s so this program at the moment

15363
09:41:38,436 --> 09:41:42,680
not interesting at all it's just week

15364
09:41:40,000 --> 09:41:46,240
one stuff again/ addresses indeed prints

15365
09:41:42,680 --> 09:41:48,640
out high but it turns out that now that

15366
09:41:46,240 --> 09:41:50,756
I know this what's really been going on

15367
09:41:48,640 --> 09:41:52,596
underneath the hood all this time well

15368
09:41:50,756 --> 09:41:55,116
here's that same line of code that

15369
09:41:52,596 --> 09:41:57,240
defines the variable called s and it

15370
09:41:55,116 --> 09:41:59,916
turns out anyone want to guess what

15371
09:41:57,240 --> 09:42:02,596
string is actually a synonym

15372
09:41:59,916 --> 09:42:04,240
for string it turns out is kind of a

15373
09:42:02,596 --> 09:42:06,756
white lie we've been telling since week

15374
09:42:04,240 --> 09:42:10,000
one there is no such thing as string as

15375
09:42:06,756 --> 09:42:11,960
a keyword in in C it's technically a

15376
09:42:10,000 --> 09:42:15,000
cs50 thing

15377
09:42:11,960 --> 09:42:16,720
yeah it's a pointer to a character so

15378
09:42:15,000 --> 09:42:18,800
really all this time we've kind of been

15379
09:42:16,720 --> 09:42:21,720
lying to you there is no string quote

15380
09:42:18,800 --> 09:42:25,000
unquote it's actually Char star and if I

15381
09:42:21,720 --> 09:42:27,960
may it dramatically here go the training

15382
09:42:25,000 --> 09:42:30,520
wheels like okay that didn't land very

15383
09:42:27,960 --> 09:42:32,240
well so uh what have we been doing well

15384
09:42:30,520 --> 09:42:33,596
it turns out that string is a much

15385
09:42:32,240 --> 09:42:35,159
easier way conceptually to think about

15386
09:42:33,596 --> 09:42:36,520
what a string of characters is like my

15387
09:42:35,160 --> 09:42:38,040
God if we had to start in week one by

15388
09:42:36,520 --> 09:42:39,479
having you type char

15389
09:42:38,040 --> 09:42:41,200
like yeah you might get past it but like

15390
09:42:39,480 --> 09:42:42,880
this is just way too much ugly syntax

15391
09:42:41,200 --> 09:42:45,000
not intellectually interesting at all so

15392
09:42:42,880 --> 09:42:47,680
we abstract it away what a Char star was

15393
09:42:45,000 --> 09:42:49,596
in the first week of C by telling you

15394
09:42:47,680 --> 09:42:51,276
it's actually called string now string

15395
09:42:49,596 --> 09:42:52,640
is a term of art like C programmers

15396
09:42:51,276 --> 09:42:54,560
programmers are in any language we'll

15397
09:42:52,640 --> 09:42:56,596
use the word string to mean a sequence

15398
09:42:54,560 --> 09:42:59,720
of characters but in C it's not

15399
09:42:56,596 --> 09:43:01,640
technically a word unto itself it's

15400
09:42:59,720 --> 09:43:04,200
rather a synonym that we ourselves

15401
09:43:01,640 --> 09:43:06,000
created in some form so in fact how did

15402
09:43:04,200 --> 09:43:08,200
we do this well think back to just last

15403
09:43:06,000 --> 09:43:10,880
week last week I proposed that it'd be

15404
09:43:08,200 --> 09:43:12,719
really nice if we had a person data type

15405
09:43:10,880 --> 09:43:14,360
which the creators of C did not think of

15406
09:43:12,720 --> 09:43:16,880
decades ago but that's okay we can

15407
09:43:14,360 --> 09:43:20,040
Define it ourselves what did we do here

15408
09:43:16,880 --> 09:43:22,640
well using syntax like this recall that

15409
09:43:20,040 --> 09:43:24,960
we defined a person to be what to be

15410
09:43:22,640 --> 09:43:27,436
this structure this structure using the

15411
09:43:24,960 --> 09:43:29,159
new keyword last week struct means that

15412
09:43:27,436 --> 09:43:30,240
a person is just a name and a number and

15413
09:43:29,160 --> 09:43:34,320
it could have been other things we just

15414
09:43:30,240 --> 09:43:36,916
kept it simple but how did I associate

15415
09:43:34,320 --> 09:43:39,320
person with that structure well we

15416
09:43:36,916 --> 09:43:41,755
claimed that it was this value here type

15417
09:43:39,320 --> 09:43:45,080
def which as you might expect defines a

15418
09:43:41,756 --> 09:43:48,320
data type so what did we do as cs50 back

15419
09:43:45,080 --> 09:43:50,800
in week one without telling you well we

15420
09:43:48,320 --> 09:43:52,756
could have done something like this like

15421
09:43:50,800 --> 09:43:53,916
int itself is a little cryptic and maybe

15422
09:43:52,756 --> 09:43:55,840
we should have to keep things even

15423
09:43:53,916 --> 09:43:57,719
simpler said hey everyone turns out you

15424
09:43:55,840 --> 09:43:59,276
can Define integers in C and if you

15425
09:43:57,720 --> 09:44:01,116
wanted to do this well if you want to

15426
09:43:59,276 --> 09:44:04,079
create the keyword integer as a data

15427
09:44:01,116 --> 09:44:06,520
type you can just typ def it to int so

15428
09:44:04,080 --> 09:44:09,436
typed def creates the word on the far

15429
09:44:06,520 --> 09:44:11,719
right integer and U creates a synonym

15430
09:44:09,436 --> 09:44:14,116
for it in this case called int so what

15431
09:44:11,720 --> 09:44:16,680
did we do in week one without telling

15432
09:44:14,116 --> 09:44:20,040
you we have a line of code like this in

15433
09:44:16,680 --> 09:44:23,480
the cs-50 library that Associates quote

15434
09:44:20,040 --> 09:44:26,240
unquote string with more cryptically

15435
09:44:23,480 --> 09:44:29,160
charar and this is why in week one

15436
09:44:26,240 --> 09:44:31,115
onward anytime you use the cs50 library

15437
09:44:29,160 --> 09:44:33,360
you can write the word string as though

15438
09:44:31,116 --> 09:44:34,276
it's a real C data type and that's just

15439
09:44:33,360 --> 09:44:35,756
because we wanted to have this

15440
09:44:34,276 --> 09:44:37,400
abstraction these training wheels on for

15441
09:44:35,756 --> 09:44:39,276
the first weeks so we don't have to get

15442
09:44:37,400 --> 09:44:40,756
weeds of all this crazy memory stuff we

15443
09:44:39,276 --> 09:44:43,040
can sort of talk about strings at a

15444
09:44:40,756 --> 09:44:45,200
higher level but that's all they are

15445
09:44:43,040 --> 09:44:48,840
strings are the address of the first

15446
09:44:45,200 --> 09:44:52,360
character in that sequence of characters

15447
09:44:48,840 --> 09:44:55,079
questions now on any of these details

15448
09:44:52,360 --> 09:44:56,916
yeah strings

15449
09:44:55,080 --> 09:44:59,880
liar good question what about the

15450
09:44:56,916 --> 09:45:01,880
strings Library which we have used um

15451
09:44:59,880 --> 09:45:03,799
unrelated so it does not define the word

15452
09:45:01,880 --> 09:45:06,200
string everything in there actually

15453
09:45:03,800 --> 09:45:08,040
relates to char stars and so in fact if

15454
09:45:06,200 --> 09:45:10,399
you've used the CS5

15455
09:45:08,040 --> 09:45:12,276
uh manual uh which is just our

15456
09:45:10,400 --> 09:45:14,800
userfriendly version of the actual

15457
09:45:12,276 --> 09:45:16,115
manual pages for the official language C

15458
09:45:14,800 --> 09:45:17,960
you'll see throughout that now if you

15459
09:45:16,116 --> 09:45:19,720
start poking around or turning off less

15460
09:45:17,960 --> 09:45:21,436
comfortable mode you'll actually see

15461
09:45:19,720 --> 09:45:23,916
that we've changed any mentions of

15462
09:45:21,436 --> 09:45:25,840
charar in the official documentation for

15463
09:45:23,916 --> 09:45:27,916
these first weeks to just string to

15464
09:45:25,840 --> 09:45:30,596
simplify it but underneath the hood C

15465
09:45:27,916 --> 09:45:32,640
does not know the word string per se as

15466
09:45:30,596 --> 09:45:34,320
a keyword but it's absolutely a concept

15467
09:45:32,640 --> 09:45:36,116
that like every program in the world

15468
09:45:34,320 --> 09:45:37,720
knows about and in fact in other

15469
09:45:36,116 --> 09:45:39,916
languages in Python for instance there

15470
09:45:37,720 --> 09:45:40,916
will actually be a proper string

15471
09:45:39,916 --> 09:45:42,520
although it's not going to be called

15472
09:45:40,916 --> 09:45:46,399
string it's going to be called stir St

15473
09:45:42,520 --> 09:45:48,840
Str for short questions on these strings

15474
09:45:46,400 --> 09:45:50,880
here well let me propose there's one

15475
09:45:48,840 --> 09:45:53,880
other feature of this syntax that we can

15476
09:45:50,880 --> 09:45:55,916
now leverage as follows let me propose

15477
09:45:53,880 --> 09:45:58,435
that if we go back to the previous

15478
09:45:55,916 --> 09:46:00,640
version of my code here wherein let me

15479
09:45:58,436 --> 09:46:02,916
switch back to vs code in just a moment

15480
09:46:00,640 --> 09:46:05,756
I'm going to rewind in vs code to the

15481
09:46:02,916 --> 09:46:07,680
integer version of my code from before

15482
09:46:05,756 --> 09:46:09,480
and most recently it looked looked like

15483
09:46:07,680 --> 09:46:12,756
this before when we were using integers

15484
09:46:09,480 --> 09:46:14,400
only and not in fact strings at all let

15485
09:46:12,756 --> 09:46:16,400
me propose that there's this other

15486
09:46:14,400 --> 09:46:18,276
feature of C that we can use that

15487
09:46:16,400 --> 09:46:20,000
actually allows us to go to an address

15488
09:46:18,276 --> 09:46:21,680
so at the moment let me just rewind and

15489
09:46:20,000 --> 09:46:23,680
do make addresses to remind you what

15490
09:46:21,680 --> 09:46:26,200
this program do did when it was using

15491
09:46:23,680 --> 09:46:28,720
integers alone and there's that address

15492
09:46:26,200 --> 09:46:31,276
why because on line seven notice I'm

15493
09:46:28,720 --> 09:46:32,720
printing out the value of P which is a

15494
09:46:31,276 --> 09:46:35,276
pointer so of course it's going to look

15495
09:46:32,720 --> 09:46:37,596
like an address but let me zoom out now

15496
09:46:35,276 --> 09:46:40,360
and make one change and instead of

15497
09:46:37,596 --> 09:46:42,560
printing out P how can I use today's

15498
09:46:40,360 --> 09:46:45,160
second new operator not the Ampersand

15499
09:46:42,560 --> 09:46:47,799
but the star to actually go to that

15500
09:46:45,160 --> 09:46:49,596
address well what I can actually do on

15501
09:46:47,800 --> 09:46:51,960
this line of code is this if I want to

15502
09:46:49,596 --> 09:46:54,799
print out the actual integer 50 that's

15503
09:46:51,960 --> 09:46:58,116
in that variable or equivalently at that

15504
09:46:54,800 --> 09:46:59,480
address I can go to P here and not print

15505
09:46:58,116 --> 09:47:03,960
P literally because that's just an

15506
09:46:59,480 --> 09:47:05,916
address I can now say star p and star p

15507
09:47:03,960 --> 09:47:08,276
means go there more technically

15508
09:47:05,916 --> 09:47:09,680
dreference p that is follow the treasure

15509
09:47:08,276 --> 09:47:12,276
map to the actual address and do what

15510
09:47:09,680 --> 09:47:14,080
Carter did open the mailbox and print

15511
09:47:12,276 --> 09:47:17,276
whatever was in the mailbox which recall

15512
09:47:14,080 --> 09:47:21,160
was the actual number 50 so let me try

15513
09:47:17,276 --> 09:47:23,159
this let me recompile the code so make

15514
09:47:21,160 --> 09:47:24,840
addresses okay let me clear my terminal

15515
09:47:23,160 --> 09:47:26,880
window do/ addresses this time I

15516
09:47:24,840 --> 09:47:30,719
shouldn't see the ox anything I should

15517
09:47:26,880 --> 09:47:33,159
see just the number 50 in this case and

15518
09:47:30,720 --> 09:47:34,840
here to is kind of a unfortunate design

15519
09:47:33,160 --> 09:47:38,276
decision certainly pedagogically I would

15520
09:47:34,840 --> 09:47:39,880
say in C if I zoom in on this code star

15521
09:47:38,276 --> 09:47:41,360
is unfortunately being used in two

15522
09:47:39,880 --> 09:47:42,840
different ways in an Ideal World they

15523
09:47:41,360 --> 09:47:44,680
would have used three different symbols

15524
09:47:42,840 --> 09:47:46,840
to make this more semantically clear but

15525
09:47:44,680 --> 09:47:49,640
this is what we're stuck with so in line

15526
09:47:46,840 --> 09:47:51,560
six when you declare a pointer that is a

15527
09:47:49,640 --> 09:47:53,520
variable that stores an address you put

15528
09:47:51,560 --> 09:47:55,840
the type of variable that you want to

15529
09:47:53,520 --> 09:47:57,596
point at then a star just because and

15530
09:47:55,840 --> 09:47:59,079
then the name of the variable and on the

15531
09:47:57,596 --> 09:48:01,799
right hand side you actually get the

15532
09:47:59,080 --> 09:48:04,116
address of whatever using Ampersand but

15533
09:48:01,800 --> 09:48:06,116
when you want to go to an address you

15534
09:48:04,116 --> 09:48:08,436
want to dreference a pointer you don't

15535
09:48:06,116 --> 09:48:09,720
use int again and we've never done that

15536
09:48:08,436 --> 09:48:11,240
right once you declare a variable you

15537
09:48:09,720 --> 09:48:12,720
never again mention the data type but in

15538
09:48:11,240 --> 09:48:15,360
the world of pointers now if you want to

15539
09:48:12,720 --> 09:48:19,116
not print out P but go to whatever

15540
09:48:15,360 --> 09:48:21,320
address p is storing you use star P here

15541
09:48:19,116 --> 09:48:23,480
so a good visual indicator would be when

15542
09:48:21,320 --> 09:48:25,756
you declare a pointer that is make it

15543
09:48:23,480 --> 09:48:28,080
exist in your program you have to

15544
09:48:25,756 --> 09:48:30,160
declare the data type with the star but

15545
09:48:28,080 --> 09:48:32,040
when you use a pointer you just use the

15546
09:48:30,160 --> 09:48:33,720
star in an Ideal World this would be a

15547
09:48:32,040 --> 09:48:36,200
completely different symbol but again

15548
09:48:33,720 --> 09:48:38,840
this is what we have questions now on

15549
09:48:36,200 --> 09:48:40,880
that syntax

15550
09:48:38,840 --> 09:48:43,840
[Music]

15551
09:48:40,880 --> 09:48:45,640
yeah uh why can't we just do the Amper

15552
09:48:43,840 --> 09:48:47,560
sand here are you saying it was still a

15553
09:48:45,640 --> 09:48:49,240
little quiet so strictly speaking we do

15554
09:48:47,560 --> 09:48:52,680
not need line six so this is really for

15555
09:48:49,240 --> 09:48:54,916
pedagogical sake that I am um defining a

15556
09:48:52,680 --> 09:48:56,436
separate variable p and then printing it

15557
09:48:54,916 --> 09:48:58,435
out at this point though I'm just kind

15558
09:48:56,436 --> 09:49:00,276
of you know going in circles if you will

15559
09:48:58,436 --> 09:49:02,000
because more simple would have been what

15560
09:49:00,276 --> 09:49:04,360
I would have done in week one which

15561
09:49:02,000 --> 09:49:06,680
would be get rid of P alt together get

15562
09:49:04,360 --> 09:49:08,320
rid of P here and just print out n right

15563
09:49:06,680 --> 09:49:11,116
but today we're just giving you this new

15564
09:49:08,320 --> 09:49:12,640
building block these this new syntax via

15565
09:49:11,116 --> 09:49:14,360
which you can figure out the address of

15566
09:49:12,640 --> 09:49:17,320
something and then reverse the process

15567
09:49:14,360 --> 09:49:19,916
later and actually go to it as

15568
09:49:17,320 --> 09:49:21,360
well other questions on what we've done

15569
09:49:19,916 --> 09:49:23,360
here with these

15570
09:49:21,360 --> 09:49:25,640
pointers all right well let's context

15571
09:49:23,360 --> 09:49:28,160
switch back to the string now and see

15572
09:49:25,640 --> 09:49:31,960
what more we can do with this here in

15573
09:49:28,160 --> 09:49:34,960
the case of our strings here let me uh

15574
09:49:31,960 --> 09:49:37,200
refine this to zoom out let me delete

15575
09:49:34,960 --> 09:49:39,596
the integer related code here let me do

15576
09:49:37,200 --> 09:49:41,960
string s equals quote unquote high in

15577
09:49:39,596 --> 09:49:45,159
all caps let me go ahead and for the

15578
09:49:41,960 --> 09:49:48,276
moment include cs50.h at the top so that

15579
09:49:45,160 --> 09:49:50,756
indeed I can use the keyword s or string

15580
09:49:48,276 --> 09:49:52,560
rather and let me go ahead now and do

15581
09:49:50,756 --> 09:49:55,640
something more than I did last time last

15582
09:49:52,560 --> 09:49:57,479
time I did print F of percent s back sln

15583
09:49:55,640 --> 09:49:59,596
and then I printed out s and again I'll

15584
09:49:57,480 --> 09:50:01,480
recompile this just for clarity make

15585
09:49:59,596 --> 09:50:03,720
addresses addresses that just prints out

15586
09:50:01,480 --> 09:50:05,320
high so that's again week one stuff but

15587
09:50:03,720 --> 09:50:08,240
now that we have this other bit of

15588
09:50:05,320 --> 09:50:10,680
syntax we can do some interesting things

15589
09:50:08,240 --> 09:50:12,916
too so for instance suppose I want to

15590
09:50:10,680 --> 09:50:15,040
print out not s itself but what if I

15591
09:50:12,916 --> 09:50:17,640
want to print out the address of s like

15592
09:50:15,040 --> 09:50:19,720
at what memory location is s well I can

15593
09:50:17,640 --> 09:50:21,840
change my percent s to percent P which

15594
09:50:19,720 --> 09:50:24,116
now we know P is for pointer so percent

15595
09:50:21,840 --> 09:50:26,880
p means print out the value of a pointer

15596
09:50:24,116 --> 09:50:29,960
that is an address and here I can

15597
09:50:26,880 --> 09:50:33,200
actually print out s itself but why that

15598
09:50:29,960 --> 09:50:36,040
is we'll see in a moment let me do this

15599
09:50:33,200 --> 09:50:37,596
here go the training wheels string does

15600
09:50:36,040 --> 09:50:39,840
not technically EX exist but it does if

15601
09:50:37,596 --> 09:50:41,680
I'm using the cs-50 library but if I get

15602
09:50:39,840 --> 09:50:43,079
rid of the cs50 library as I'm

15603
09:50:41,680 --> 09:50:44,880
metaphorically doing by taking off the

15604
09:50:43,080 --> 09:50:46,320
training wheels I can't use the word

15605
09:50:44,880 --> 09:50:48,000
string anymore and in fact let me make

15606
09:50:46,320 --> 09:50:50,159
this mistake deliberately as you might

15607
09:50:48,000 --> 09:50:52,480
have accidentally in past weeks here is

15608
09:50:50,160 --> 09:50:55,116
the error message I get if I forget the

15609
09:50:52,480 --> 09:50:57,320
cs50 library use of Undeclared

15610
09:50:55,116 --> 09:50:58,880
identifier string did you mean standard

15611
09:50:57,320 --> 09:51:00,640
in it's trying to be helpful but it's

15612
09:50:58,880 --> 09:51:02,560
not because I didn't mean standard in so

15613
09:51:00,640 --> 09:51:05,000
indeed this is confirmation that c does

15614
09:51:02,560 --> 09:51:07,200
not know the word string exists at least

15615
09:51:05,000 --> 09:51:10,276
as a keyword exists as a concept but not

15616
09:51:07,200 --> 09:51:12,000
a keyword so I could fix this by adding

15617
09:51:10,276 --> 09:51:13,680
back the cs50 library but that's kind of

15618
09:51:12,000 --> 09:51:15,560
a step backwards educationally is

15619
09:51:13,680 --> 09:51:17,840
instead of a step forward what could I

15620
09:51:15,560 --> 09:51:22,040
do instead to fix this now if the

15621
09:51:17,840 --> 09:51:22,039
training wheels are now off

15622
09:51:22,720 --> 09:51:27,916
yeah exactly replace string quote

15623
09:51:25,360 --> 09:51:29,116
unquote with Char star instead so I'm

15624
09:51:27,916 --> 09:51:31,596
going to go ahead and change this to

15625
09:51:29,116 --> 09:51:34,040
char technically you can put the literal

15626
09:51:31,596 --> 09:51:35,520
star here the asterisk or you can put it

15627
09:51:34,040 --> 09:51:37,240
there or you can put it here by

15628
09:51:35,520 --> 09:51:39,276
convention is to do what I done from the

15629
09:51:37,240 --> 09:51:41,276
beginning put the star next to the name

15630
09:51:39,276 --> 09:51:44,400
of the variable as opposed to anywhere

15631
09:51:41,276 --> 09:51:45,799
else uh let me go ahead now and or sorry

15632
09:51:44,400 --> 09:51:47,200
I meant to add the spaces there you

15633
09:51:45,800 --> 09:51:49,276
could do this too but this would be the

15634
09:51:47,200 --> 09:51:52,479
most normal convention so now let's do

15635
09:51:49,276 --> 09:51:55,159
this make addresses compile is okay now

15636
09:51:52,480 --> 09:51:59,000
do slash addresses what should I see

15637
09:51:55,160 --> 09:52:00,160
high or something else feel free to just

15638
09:51:59,000 --> 09:52:03,520
call it

15639
09:52:00,160 --> 09:52:06,276
out so still high you say someone

15640
09:52:03,520 --> 09:52:07,880
else memory location a memory location

15641
09:52:06,276 --> 09:52:09,115
all right so could be one of the two

15642
09:52:07,880 --> 09:52:10,960
options right either I'm going to see

15643
09:52:09,116 --> 09:52:12,960
the string or I'm going to see a memory

15644
09:52:10,960 --> 09:52:14,200
address though I do in fact see a memory

15645
09:52:12,960 --> 09:52:16,436
address and this one's quite different

15646
09:52:14,200 --> 09:52:19,200
from the integer one but does anyone now

15647
09:52:16,436 --> 09:52:21,596
want to explain why you were correct why

15648
09:52:19,200 --> 09:52:25,719
am I seeing the address down here and

15649
09:52:21,596 --> 09:52:25,720
not hi it's subtle

15650
09:52:25,960 --> 09:52:30,880
yeah exactly because I left my percent P

15651
09:52:29,080 --> 09:52:32,756
there which means hey print F show me a

15652
09:52:30,880 --> 09:52:35,079
pointer but this is where printf is

15653
09:52:32,756 --> 09:52:38,116
smart and has been smart since week zero

15654
09:52:35,080 --> 09:52:40,320
humans who invented printf decades ago

15655
09:52:38,116 --> 09:52:42,596
uh wrote code that notices that okay

15656
09:52:40,320 --> 09:52:45,320
percent s means to treat the following

15657
09:52:42,596 --> 09:52:47,596
value not as just an address per se that

15658
09:52:45,320 --> 09:52:49,240
gets printed literally but printed as

15659
09:52:47,596 --> 09:52:51,799
with the mailbox demo is sort of a

15660
09:52:49,240 --> 09:52:54,115
treasure map that leads you to the

15661
09:52:51,800 --> 09:52:55,960
address of a character so simply by

15662
09:52:54,116 --> 09:52:58,000
changing one character percent P to

15663
09:52:55,960 --> 09:53:00,680
percent s and if I now do make addresses

15664
09:52:58,000 --> 09:53:02,960
again and slash addresses this now is

15665
09:53:00,680 --> 09:53:05,596
identical to week one but hopefully

15666
09:53:02,960 --> 09:53:08,436
makes sense because percent s is just a

15667
09:53:05,596 --> 09:53:11,880
clue to print f that means go to this

15668
09:53:08,436 --> 09:53:14,916
address in s print out every character

15669
09:53:11,880 --> 09:53:16,755
there and thereafter until you see what

15670
09:53:14,916 --> 09:53:18,680
the null character and then stop

15671
09:53:16,756 --> 09:53:21,596
printing anything more and this is why

15672
09:53:18,680 --> 09:53:24,040
hi has printed since week one today we

15673
09:53:21,596 --> 09:53:25,479
can see the address percent P but this

15674
09:53:24,040 --> 09:53:28,360
combination of having access to

15675
09:53:25,480 --> 09:53:30,000
addresses and the null Terminator is all

15676
09:53:28,360 --> 09:53:32,040
the information printf needs to actually

15677
09:53:30,000 --> 09:53:34,276
do something more useful by like

15678
09:53:32,040 --> 09:53:37,200
printing the actual

15679
09:53:34,276 --> 09:53:42,596
strings any questions now on this

15680
09:53:37,200 --> 09:53:45,479
approach to percent s yeah in

15681
09:53:42,596 --> 09:53:46,960
back oh so why is it traditionally being

15682
09:53:45,480 --> 09:53:48,680
used in this way honestly like the word

15683
09:53:46,960 --> 09:53:50,520
string has been around for decades it's

15684
09:53:48,680 --> 09:53:52,320
not a keyword you should be able to type

15685
09:53:50,520 --> 09:53:54,680
in C unless you're using a library like

15686
09:53:52,320 --> 09:53:56,400
cs50 um and so percent s just means

15687
09:53:54,680 --> 09:53:59,116
string so even though it doesn't exist

15688
09:53:56,400 --> 09:54:01,116
as a keyword percent s connotes string

15689
09:53:59,116 --> 09:54:02,320
and humans decades ago like today just

15690
09:54:01,116 --> 09:54:03,520
kind of know what that means so they

15691
09:54:02,320 --> 09:54:05,520
could have chosen any letter of the

15692
09:54:03,520 --> 09:54:09,799
alphabet but s sort of makes the most

15693
09:54:05,520 --> 09:54:11,960
sense all right well let's in back other

15694
09:54:09,800 --> 09:54:14,640
question good question before let me

15695
09:54:11,960 --> 09:54:18,960
zoom in I did not use a star before the

15696
09:54:14,640 --> 09:54:21,560
S why well it's subtle here but printf

15697
09:54:18,960 --> 09:54:24,479
is was invented years ago to know given

15698
09:54:21,560 --> 09:54:25,960
an address like in the variable s printf

15699
09:54:24,480 --> 09:54:27,880
knows to go there so if we looked at the

15700
09:54:25,960 --> 09:54:30,880
source code that some human wrote years

15701
09:54:27,880 --> 09:54:32,719
ago for C we would likely see the actual

15702
09:54:30,880 --> 09:54:34,479
uh asterisk that you're referring to

15703
09:54:32,720 --> 09:54:37,916
printf is taking on the responsibility

15704
09:54:34,480 --> 09:54:40,800
for going to S if you were to do uh star

15705
09:54:37,916 --> 09:54:43,596
s here instead an asterisk and then s

15706
09:54:40,800 --> 09:54:46,200
that would now be literally a character

15707
09:54:43,596 --> 09:54:47,720
because if I say p uh star s that means

15708
09:54:46,200 --> 09:54:49,000
go to the address in s and all you're

15709
09:54:47,720 --> 09:54:51,916
going to find there is a single

15710
09:54:49,000 --> 09:54:53,960
character what printf wants to know is

15711
09:54:51,916 --> 09:54:55,916
not what is the character there what is

15712
09:54:53,960 --> 09:54:58,400
the address of that character why

15713
09:54:55,916 --> 09:55:01,276
because printf needs to walk through the

15714
09:54:58,400 --> 09:55:03,640
rest of those characters looking for the

15715
09:55:01,276 --> 09:55:05,479
final null character and in fact let me

15716
09:55:03,640 --> 09:55:07,520
see with a bit more syntax if we can

15717
09:55:05,480 --> 09:55:09,720
highlight this a bit more let me do this

15718
09:55:07,520 --> 09:55:11,399
in addition to printing s let's try out

15719
09:55:09,720 --> 09:55:14,596
our syntax in another way let me print

15720
09:55:11,400 --> 09:55:16,596
out with percent s how about uh not s

15721
09:55:14,596 --> 09:55:20,240
here but let's print out some addresses

15722
09:55:16,596 --> 09:55:22,880
percent s back sln close quote and then

15723
09:55:20,240 --> 09:55:24,680
let's print out how about this the first

15724
09:55:22,880 --> 09:55:27,640
character in the string s would be

15725
09:55:24,680 --> 09:55:30,800
called s bracket Z but how do I get the

15726
09:55:27,640 --> 09:55:32,276
address of the first character in s well

15727
09:55:30,800 --> 09:55:33,960
I could technically just use today's new

15728
09:55:32,276 --> 09:55:35,799
primitive I can just add an ampon that

15729
09:55:33,960 --> 09:55:40,159
always gives me the address of some

15730
09:55:35,800 --> 09:55:41,596
value so when I end this thought and

15731
09:55:40,160 --> 09:55:44,000
clear my terminal window and run make

15732
09:55:41,596 --> 09:55:46,000
addresses still compiles when I run

15733
09:55:44,000 --> 09:55:48,880
addresses in just a moment any guesses

15734
09:55:46,000 --> 09:55:50,200
as to what I will see line by line this

15735
09:55:48,880 --> 09:55:52,159
will print out two

15736
09:55:50,200 --> 09:55:54,240
things and you don't have to remember

15737
09:55:52,160 --> 09:55:57,240
what the actual number was but at a high

15738
09:55:54,240 --> 09:55:59,756
level what will be printed now the same

15739
09:55:57,240 --> 09:56:01,360
thing twice why well when I run this

15740
09:55:59,756 --> 09:56:03,520
what I'm printing here and let me zoom

15741
09:56:01,360 --> 09:56:05,680
in at the bottom I ined see two really

15742
09:56:03,520 --> 09:56:08,596
long addresses but they're in fact the

15743
09:56:05,680 --> 09:56:11,400
same why well that's because again if s

15744
09:56:08,596 --> 09:56:14,040
is the address of a character as implied

15745
09:56:11,400 --> 09:56:16,960
Now by either the cs50 word string or

15746
09:56:14,040 --> 09:56:19,840
the actual phrase Char star well then s

15747
09:56:16,960 --> 09:56:23,640
is just an address by contrast per week

15748
09:56:19,840 --> 09:56:25,435
two s bracket 0 is a Char always has

15749
09:56:23,640 --> 09:56:27,240
been a Char a specific Char but if you

15750
09:56:25,436 --> 09:56:29,560
want the address of that Char you just

15751
09:56:27,240 --> 09:56:31,436
add the Ampersand well it turns out that

15752
09:56:29,560 --> 09:56:33,276
strings per the definition we keep

15753
09:56:31,436 --> 09:56:34,840
emphasizing is just the address of the

15754
09:56:33,276 --> 09:56:36,436
first character in a string so of course

15755
09:56:34,840 --> 09:56:38,320
if you do this you're going to see the

15756
09:56:36,436 --> 09:56:40,116
exact same thing and if I do this a bit

15757
09:56:38,320 --> 09:56:41,960
more generally you don't want to copy

15758
09:56:40,116 --> 09:56:43,800
paste but this is just for uh

15759
09:56:41,960 --> 09:56:45,680
visualization sake let me print out all

15760
09:56:43,800 --> 09:56:47,596
the characters so another another

15761
09:56:45,680 --> 09:56:50,400
another and let me change this to print

15762
09:56:47,596 --> 09:56:52,880
out the address of bracket 1 bracket two

15763
09:56:50,400 --> 09:56:54,800
and bracket three so all four characters

15764
09:56:52,880 --> 09:56:57,040
Hi exclamation point and the null

15765
09:56:54,800 --> 09:56:59,000
character notice I'm using percent P for

15766
09:56:57,040 --> 09:57:01,840
all of them so if I now do make

15767
09:56:59,000 --> 09:57:04,200
addresses and do/ addresses now notice

15768
09:57:01,840 --> 09:57:06,200
and this is kind of cool the first two

15769
09:57:04,200 --> 09:57:10,159
are indeed still the same but what's no

15770
09:57:06,200 --> 09:57:10,159
noteworthy about the other values on the

15771
09:57:10,320 --> 09:57:14,360
screen yeah they're consecutive each of

15772
09:57:12,680 --> 09:57:15,596
these is just one bite away even if

15773
09:57:14,360 --> 09:57:17,480
you're not good at hex yet and there's a

15774
09:57:15,596 --> 09:57:18,916
crazy number of digits here who cares

15775
09:57:17,480 --> 09:57:21,960
they're all the same except for the last

15776
09:57:18,916 --> 09:57:23,399
ones four four and then 5 six seven and

15777
09:57:21,960 --> 09:57:25,680
this confirms what I've been claiming

15778
09:57:23,400 --> 09:57:27,320
for weeks is that in an array all of the

15779
09:57:25,680 --> 09:57:31,116
characters are back to back to back

15780
09:57:27,320 --> 09:57:32,880
contiguous One Bites away so with just

15781
09:57:31,116 --> 09:57:34,480
this Ampersand with just this star like

15782
09:57:32,880 --> 09:57:36,479
it's actually a pretty cool tool in the

15783
09:57:34,480 --> 09:57:39,040
toolkit to have because you can start to

15784
09:57:36,480 --> 09:57:41,596
poke around what's actually going on

15785
09:57:39,040 --> 09:57:44,480
inside of the computer's memory and in

15786
09:57:41,596 --> 09:57:46,960
fact if we do this I can introduce one

15787
09:57:44,480 --> 09:57:50,436
other cool trick here if you will let me

15788
09:57:46,960 --> 09:57:52,520
propose that we can actually now do

15789
09:57:50,436 --> 09:57:54,320
arithmetic on pointers and you don't

15790
09:57:52,520 --> 09:57:56,435
have to you'll see a simpler way to do

15791
09:57:54,320 --> 09:57:58,880
this but now that you have perhaps this

15792
09:57:56,436 --> 09:58:00,880
underlying understanding of where things

15793
09:57:58,880 --> 09:58:02,719
are in memory and it's just addresses we

15794
09:58:00,880 --> 09:58:05,115
can actually do something kind of neat

15795
09:58:02,720 --> 09:58:07,756
we can do something like this uh let me

15796
09:58:05,116 --> 09:58:10,276
go back to how about uh the string

15797
09:58:07,756 --> 09:58:12,916
version of this with high and let me do

15798
09:58:10,276 --> 09:58:14,720
this instead let me um clean this up a

15799
09:58:12,916 --> 09:58:16,680
bit get rid of some of these lines of

15800
09:58:14,720 --> 09:58:19,480
code and let me do this let me print out

15801
09:58:16,680 --> 09:58:20,916
percent C percent C percent C let me get

15802
09:58:19,480 --> 09:58:23,436
rid of all these Amper Sands we're going

15803
09:58:20,916 --> 09:58:25,755
to roll back to like week two stuff just

15804
09:58:23,436 --> 09:58:28,520
to be clear when I compile and run this

15805
09:58:25,756 --> 09:58:31,080
version of the program and I'll zoom in

15806
09:58:28,520 --> 09:58:33,799
what should get printed on the screen

15807
09:58:31,080 --> 09:58:36,840
this is just week two stuff now no

15808
09:58:33,800 --> 09:58:40,000
pointers per se yeah

15809
09:58:36,840 --> 09:58:41,479
mhm just Hi exclamation point one per

15810
09:58:40,000 --> 09:58:43,560
line because I have all of these back

15811
09:58:41,480 --> 09:58:46,480
slash ends so let me do that let me go

15812
09:58:43,560 --> 09:58:49,000
down here make addresses enter okay

15813
09:58:46,480 --> 09:58:51,596
pretty good/ addresses and indeed Hi

15814
09:58:49,000 --> 09:58:52,800
exclamation point But now if you're

15815
09:58:51,596 --> 09:58:54,200
getting a little more comfortable and

15816
09:58:52,800 --> 09:58:55,756
it's fine if you're not yet today but

15817
09:58:54,200 --> 09:58:57,079
over the coming week or weeks as you get

15818
09:58:55,756 --> 09:58:59,400
a little more comfortable with the

15819
09:58:57,080 --> 09:59:01,276
equivalence of addresses with our

15820
09:58:59,400 --> 09:59:03,400
definition in the past of arrays and

15821
09:59:01,276 --> 09:59:05,880
strings and all of this you can start to

15822
09:59:03,400 --> 09:59:08,320
play around and I can do this instead if

15823
09:59:05,880 --> 09:59:10,840
I I want to print out the first

15824
09:59:08,320 --> 09:59:12,480
character in the string I could do like

15825
09:59:10,840 --> 09:59:13,880
week two s bracket zero like that will

15826
09:59:12,480 --> 09:59:15,320
always work and you can keep using that

15827
09:59:13,880 --> 09:59:18,040
that's not a cs50 thing it's just a

15828
09:59:15,320 --> 09:59:21,640
convenience in C but I could technically

15829
09:59:18,040 --> 09:59:23,160
print out not s because s is an address

15830
09:59:21,640 --> 09:59:26,276
but what would be the syntax I could use

15831
09:59:23,160 --> 09:59:28,116
to say print out the character at

15832
09:59:26,276 --> 09:59:30,960
s any

15833
09:59:28,116 --> 09:59:31,880
Instinct how can I say go to the address

15834
09:59:30,960 --> 09:59:34,960
in

15835
09:59:31,880 --> 09:59:38,320
s it's one of two possible answers

15836
09:59:34,960 --> 09:59:39,756
today so of our two new uh uh of our two

15837
09:59:38,320 --> 09:59:42,480
new operators today we have the

15838
09:59:39,756 --> 09:59:45,520
Ampersand and the star which one will

15839
09:59:42,480 --> 09:59:47,596
lead us to what is that an address so

15840
09:59:45,520 --> 09:59:50,320
the star so in fact if I want to print

15841
09:59:47,596 --> 09:59:53,680
out what is that address zero at the

15842
09:59:50,320 --> 09:59:55,480
address S I can just do star s and if

15843
09:59:53,680 --> 09:59:57,200
you really want to get fancy how do you

15844
09:59:55,480 --> 09:59:58,720
print out the second character that's

15845
09:59:57,200 --> 10:00:01,276
immediately to the right of it so to

15846
09:59:58,720 --> 10:00:02,916
speak well you can go to with the D

15847
10:00:01,276 --> 10:00:03,880
reference operator and do you want to

15848
10:00:02,916 --> 10:00:08,200
answer this

15849
10:00:03,880 --> 10:00:09,840
one s+ one Argo pointer arithmetic like

15850
10:00:08,200 --> 10:00:11,680
you can do math simple addition

15851
10:00:09,840 --> 10:00:14,039
subtraction whatever on pointers if you

15852
10:00:11,680 --> 10:00:15,880
want and you can do this here too so

15853
10:00:14,040 --> 10:00:17,200
star you want to pluck this one off too

15854
10:00:15,880 --> 10:00:18,755
how do I print out the last character

15855
10:00:17,200 --> 10:00:21,960
the

15856
10:00:18,756 --> 10:00:23,276
third s plus2 right because if you know

15857
10:00:21,960 --> 10:00:24,640
and understand that like a string is

15858
10:00:23,276 --> 10:00:26,520
just a sequence of characters every

15859
10:00:24,640 --> 10:00:28,880
character is just a bite and these bites

15860
10:00:26,520 --> 10:00:30,560
are back to back to back you can just go

15861
10:00:28,880 --> 10:00:32,799
wherever you want in the computer's

15862
10:00:30,560 --> 10:00:35,560
memory and here I can do make addresses

15863
10:00:32,800 --> 10:00:37,680
again/ addresses and voila we now have

15864
10:00:35,560 --> 10:00:39,596
high exclamation point so we haven't

15865
10:00:37,680 --> 10:00:41,116
printed out anything new but again just

15866
10:00:39,596 --> 10:00:43,079
by using these two new operators the

15867
10:00:41,116 --> 10:00:45,040
erson and the star you can figure out

15868
10:00:43,080 --> 10:00:47,160
the address of something and you can go

15869
10:00:45,040 --> 10:00:48,800
to the address of something okay

15870
10:00:47,160 --> 10:00:51,400
question in

15871
10:00:48,800 --> 10:00:52,880
back indeed it ends up being the exact

15872
10:00:51,400 --> 10:00:55,520
same and so I might have used this term

15873
10:00:52,880 --> 10:00:57,320
before the Amper sand technique where

15874
10:00:55,520 --> 10:00:59,680
sorry the square bracket technique where

15875
10:00:57,320 --> 10:01:01,320
you do s bracket 0o s bracket One S

15876
10:00:59,680 --> 10:01:03,320
bracket 2 that's actually what we would

15877
10:01:01,320 --> 10:01:04,916
really call syntactic Sugar like it

15878
10:01:03,320 --> 10:01:06,360
works and you can use it you should use

15879
10:01:04,916 --> 10:01:07,916
it it's nice and simple

15880
10:01:06,360 --> 10:01:10,200
but the square bracket notation

15881
10:01:07,916 --> 10:01:12,479
underneath the hood is essentially being

15882
10:01:10,200 --> 10:01:13,479
converted to this which this is not fun

15883
10:01:12,480 --> 10:01:14,640
right like this is when you want to show

15884
10:01:13,480 --> 10:01:16,560
off to your friends like you know how to

15885
10:01:14,640 --> 10:01:19,000
do cool stuff in code but this is not as

15886
10:01:16,560 --> 10:01:20,596
readable as just s bracket Z and one and

15887
10:01:19,000 --> 10:01:22,200
two but that's all that's happening

15888
10:01:20,596 --> 10:01:24,115
underneath the hood and so again this is

15889
10:01:22,200 --> 10:01:25,560
why in cs50 we spend time on some of

15890
10:01:24,116 --> 10:01:27,320
these lower level building blocks

15891
10:01:25,560 --> 10:01:28,756
because if you assume that indeed your

15892
10:01:27,320 --> 10:01:31,596
computer's memory is just this grid of

15893
10:01:28,756 --> 10:01:34,040
btes and you have now the code ability

15894
10:01:31,596 --> 10:01:36,079
in code to get an address and go to an

15895
10:01:34,040 --> 10:01:37,596
address you can start doing any anything

15896
10:01:36,080 --> 10:01:39,360
you want and you can poke around a

15897
10:01:37,596 --> 10:01:41,320
computer's memory at any location and

15898
10:01:39,360 --> 10:01:42,960
here in lies the danger like I'm kind of

15899
10:01:41,320 --> 10:01:45,360
on the honor System right now that if my

15900
10:01:42,960 --> 10:01:47,560
string is high exclamation point it's

15901
10:01:45,360 --> 10:01:49,720
kind of up to me to go to the first bite

15902
10:01:47,560 --> 10:01:51,479
the second and the third but I could get

15903
10:01:49,720 --> 10:01:53,756
kind of crazy now and if I want to see

15904
10:01:51,480 --> 10:01:55,200
what's going on in the computer's memory

15905
10:01:53,756 --> 10:01:58,400
I mean there's nothing stopping me from

15906
10:01:55,200 --> 10:02:01,719
doing like s+ 50 and let's see what's

15907
10:01:58,400 --> 10:02:03,840
there so make addresses do/ addresses Hi

15908
10:02:01,720 --> 10:02:06,400
and then okay nothing it seems well how

15909
10:02:03,840 --> 10:02:07,880
about 5,000 bytes away let's poke around

15910
10:02:06,400 --> 10:02:10,756
what's inside of the computer's memory

15911
10:02:07,880 --> 10:02:13,719
so make addresses again uh make

15912
10:02:10,756 --> 10:02:15,480
addresses addresses enter okay still

15913
10:02:13,720 --> 10:02:19,200
nothing there let's try

15914
10:02:15,480 --> 10:02:22,160
50,000 all right do make addresses do SL

15915
10:02:19,200 --> 10:02:23,520
addresses okay there we see it so you've

15916
10:02:22,160 --> 10:02:25,000
probably done this some of you by

15917
10:02:23,520 --> 10:02:26,479
accident because you probably went too

15918
10:02:25,000 --> 10:02:28,800
far to the left or to the right in an

15919
10:02:26,480 --> 10:02:30,360
array touching memory that you shouldn't

15920
10:02:28,800 --> 10:02:33,320
suffice it to say I should not go

15921
10:02:30,360 --> 10:02:35,240
blindly touching 50,000 bytes away cuz

15922
10:02:33,320 --> 10:02:36,880
who knows what's there and indeed in

15923
10:02:35,240 --> 10:02:39,276
your computer computer when a program is

15924
10:02:36,880 --> 10:02:41,159
running the computer uh segments it into

15925
10:02:39,276 --> 10:02:43,276
different segments of memory and if you

15926
10:02:41,160 --> 10:02:44,916
get a little too greedy and you touch

15927
10:02:43,276 --> 10:02:46,799
another segment of memory that

15928
10:02:44,916 --> 10:02:48,680
technically was not allocated to you by

15929
10:02:46,800 --> 10:02:50,880
Mac OS or Windows or Linux or the

15930
10:02:48,680 --> 10:02:52,560
operating system bad things happen and

15931
10:02:50,880 --> 10:02:54,719
you get a segmentation fault and that

15932
10:02:52,560 --> 10:02:56,880
means it's a bug in your code so you can

15933
10:02:54,720 --> 10:02:58,800
now do this and this means hackers too

15934
10:02:56,880 --> 10:03:01,596
can do things like this if they can

15935
10:02:58,800 --> 10:03:03,240
somehow inject code into your C program

15936
10:03:01,596 --> 10:03:05,115
maybe they can poke around the

15937
10:03:03,240 --> 10:03:06,680
computer's memory and indeed this is

15938
10:03:05,116 --> 10:03:08,960
kind of the technique whereby maybe a

15939
10:03:06,680 --> 10:03:10,360
really sophisticated hacker can jump to

15940
10:03:08,960 --> 10:03:12,840
this memory this memory this memory

15941
10:03:10,360 --> 10:03:14,596
looking for something like your password

15942
10:03:12,840 --> 10:03:16,159
or your financial information or

15943
10:03:14,596 --> 10:03:17,880
anything that's in the program but at

15944
10:03:16,160 --> 10:03:20,520
some other address there's nothing

15945
10:03:17,880 --> 10:03:22,360
stopping an adversary at least right now

15946
10:03:20,520 --> 10:03:24,399
from poking around if they can execute

15947
10:03:22,360 --> 10:03:25,916
code on your computer from doing this

15948
10:03:24,400 --> 10:03:27,880
kind of thing so there and again is the

15949
10:03:25,916 --> 10:03:30,000
power of C but also the danger and

15950
10:03:27,880 --> 10:03:31,840
you'll absolutely suffer more segals in

15951
10:03:30,000 --> 10:03:34,080
the coming days but ultimately the goal

15952
10:03:31,840 --> 10:03:37,000
is going to be to help you solve them

15953
10:03:34,080 --> 10:03:40,680
ultimately uh and fix things um but for

15954
10:03:37,000 --> 10:03:42,880
now I think that was that was quite a

15955
10:03:40,680 --> 10:03:44,960
bit so let me propose that we go ahead

15956
10:03:42,880 --> 10:03:46,680
and take our longer break here maybe 10

15957
10:03:44,960 --> 10:03:48,960
minutes and have ourselves some whoopy

15958
10:03:46,680 --> 10:03:53,200
pies in the transcept we'll be back in

15959
10:03:48,960 --> 10:03:55,360
10 all right so we're back and to recap

15960
10:03:53,200 --> 10:03:57,320
where we left off you now have this new

15961
10:03:55,360 --> 10:03:59,240
capability in code to do pointer

15962
10:03:57,320 --> 10:04:01,276
arithmetic like treat addresses as

15963
10:03:59,240 --> 10:04:03,320
numbers which they really are in heximal

15964
10:04:01,276 --> 10:04:04,756
or otherwise and like add them together

15965
10:04:03,320 --> 10:04:07,040
and kind of poke around a computer's

15966
10:04:04,756 --> 10:04:09,436
memory and it was asked during break

15967
10:04:07,040 --> 10:04:11,200
actually how we might further harness

15968
10:04:09,436 --> 10:04:12,720
this in the context of string so I

15969
10:04:11,200 --> 10:04:15,360
didn't change the code we wrote just

15970
10:04:12,720 --> 10:04:18,000
before break recall that we last broke

15971
10:04:15,360 --> 10:04:20,080
the program by checking out bytes 50,000

15972
10:04:18,000 --> 10:04:21,720
bytes away but let's not do that and

15973
10:04:20,080 --> 10:04:24,320
let's actually try printing out not

15974
10:04:21,720 --> 10:04:26,480
individual characters like I did per the

15975
10:04:24,320 --> 10:04:29,040
percent C but why don't we try printing

15976
10:04:26,480 --> 10:04:30,960
out strings and substrings if you will

15977
10:04:29,040 --> 10:04:33,240
so let me clear my terminal window let

15978
10:04:30,960 --> 10:04:35,799
me change all of these percent C's to

15979
10:04:33,240 --> 10:04:37,640
percent s percent s percent s and then

15980
10:04:35,800 --> 10:04:39,560
let me rewind to what we've been doing

15981
10:04:37,640 --> 10:04:41,400
since week one with strings which is

15982
10:04:39,560 --> 10:04:43,756
just print them out for instance with

15983
10:04:41,400 --> 10:04:46,116
that first line and the only difference

15984
10:04:43,756 --> 10:04:48,360
at the moment is that now I took off the

15985
10:04:46,116 --> 10:04:52,240
training wheels I got rid of cs50.h

15986
10:04:48,360 --> 10:04:54,596
wherein string is typ Def to char star

15987
10:04:52,240 --> 10:04:56,115
for you got rid of that so now on line

15988
10:04:54,596 --> 10:04:57,596
five I'm declaring S as being a Char

15989
10:04:56,116 --> 10:04:59,240
star which just means the address of a

15990
10:04:57,596 --> 10:05:00,720
character and print f is smart enough to

15991
10:04:59,240 --> 10:05:02,880
know that the end of a string is

15992
10:05:00,720 --> 10:05:05,040
wherever that null character is but now

15993
10:05:02,880 --> 10:05:07,000
that I can do pointer arithmetic notice

15994
10:05:05,040 --> 10:05:09,520
that I could do something like this if I

15995
10:05:07,000 --> 10:05:13,200
want to print out s i just print out s

15996
10:05:09,520 --> 10:05:15,039
suppose I do s+ one here and s+2 here

15997
10:05:13,200 --> 10:05:19,240
again after changing percent C to

15998
10:05:15,040 --> 10:05:21,800
percent s any intuition around what this

15999
10:05:19,240 --> 10:05:23,436
code will now print on the screen line

16000
10:05:21,800 --> 10:05:25,360
by

16001
10:05:23,436 --> 10:05:27,400
line yeah

16002
10:05:25,360 --> 10:05:30,276
thoughts okay reasonable conjecture

16003
10:05:27,400 --> 10:05:32,430
maybe the memory address of H that of I

16004
10:05:30,276 --> 10:05:33,640
that of exclamation point but other

16005
10:05:32,430 --> 10:05:35,960
[Music]

16006
10:05:33,640 --> 10:05:37,596
thoughts yeah I think it's going to do

16007
10:05:35,960 --> 10:05:39,799
the latter it's going to print high in

16008
10:05:37,596 --> 10:05:42,079
the usual way because honestly line five

16009
10:05:39,800 --> 10:05:44,200
is this rather line six is the same as

16010
10:05:42,080 --> 10:05:45,360
like week one stuff except we took off

16011
10:05:44,200 --> 10:05:47,435
the training wheel of string and we're

16012
10:05:45,360 --> 10:05:50,200
calling it Char star but I think line

16013
10:05:47,436 --> 10:05:52,560
seven is indeed going to print out I and

16014
10:05:50,200 --> 10:05:54,115
line eight is just going to print out

16015
10:05:52,560 --> 10:05:56,320
because it'll be just the exclamation

16016
10:05:54,116 --> 10:05:59,116
point prti will still be smart enough to

16017
10:05:56,320 --> 10:06:01,040
know where each of those substrings a

16018
10:05:59,116 --> 10:06:02,480
portions of the string End by the same

16019
10:06:01,040 --> 10:06:05,480
logic as always but let me go ahead and

16020
10:06:02,480 --> 10:06:09,756
zoom out run make addresses enter

16021
10:06:05,480 --> 10:06:11,840
compiles okay/ addresses and now indeed

16022
10:06:09,756 --> 10:06:13,840
this is all a string is it's a sequence

16023
10:06:11,840 --> 10:06:16,479
of characters identified by its first

16024
10:06:13,840 --> 10:06:18,679
bite if you then start poking around and

16025
10:06:16,480 --> 10:06:20,640
tell printf to print at what's at the

16026
10:06:18,680 --> 10:06:22,360
next bite or the next next bite it's

16027
10:06:20,640 --> 10:06:24,200
going to do its same thing printing out

16028
10:06:22,360 --> 10:06:26,916
that character and everything after it

16029
10:06:24,200 --> 10:06:28,596
up until that null character so again

16030
10:06:26,916 --> 10:06:30,360
even though there's like a lot going on

16031
10:06:28,596 --> 10:06:32,040
we've introduced these two new operators

16032
10:06:30,360 --> 10:06:33,480
like there's nothing that's happening

16033
10:06:32,040 --> 10:06:35,916
today that hasn't been happening for

16034
10:06:33,480 --> 10:06:37,320
weeks but hopefully through this week uh

16035
10:06:35,916 --> 10:06:39,040
this week's lecture this week's problem

16036
10:06:37,320 --> 10:06:40,840
set and Beyond you'll start to realize

16037
10:06:39,040 --> 10:06:42,960
that now you just have more tools via

16038
10:06:40,840 --> 10:06:46,240
which to harness those lower level

16039
10:06:42,960 --> 10:06:48,479
implementation details so last week too

16040
10:06:46,240 --> 10:06:51,000
recall one other implementation detail I

16041
10:06:48,480 --> 10:06:53,200
claimed that you could not compare two

16042
10:06:51,000 --> 10:06:57,720
strings quite as easily as you could

16043
10:06:53,200 --> 10:06:59,360
compare to uh integers for instance and

16044
10:06:57,720 --> 10:07:00,960
I told you to use a different function

16045
10:06:59,360 --> 10:07:03,596
instead that you probably used one or

16046
10:07:00,960 --> 10:07:06,320
more times with the past problem set how

16047
10:07:03,596 --> 10:07:08,560
are you supposed to compare strings

16048
10:07:06,320 --> 10:07:10,040
apparently yeah so string compare stir

16049
10:07:08,560 --> 10:07:12,040
comp that additional function that we

16050
10:07:10,040 --> 10:07:14,116
said H you just have to use it for now

16051
10:07:12,040 --> 10:07:16,080
but you might have a little intuition

16052
10:07:14,116 --> 10:07:17,520
already as to like why we have to use

16053
10:07:16,080 --> 10:07:20,080
Stir compare and we can't just use

16054
10:07:17,520 --> 10:07:22,399
equals equals to compare strings like

16055
10:07:20,080 --> 10:07:24,720
any intuition for this already why was

16056
10:07:22,400 --> 10:07:27,436
Stir compare necessary last week

16057
10:07:24,720 --> 10:07:29,040
equ perfect equals equals would compare

16058
10:07:27,436 --> 10:07:31,320
literally the two memory addresses

16059
10:07:29,040 --> 10:07:33,436
instead of the actual strings character

16060
10:07:31,320 --> 10:07:35,320
by character and unless the memory

16061
10:07:33,436 --> 10:07:37,400
addresses are literally the same so you

16062
10:07:35,320 --> 10:07:39,640
compare the that exact same memory

16063
10:07:37,400 --> 10:07:41,040
address two different strings probably

16064
10:07:39,640 --> 10:07:43,000
are not going to be considered equal

16065
10:07:41,040 --> 10:07:44,960
even if to us humans they indeed look

16066
10:07:43,000 --> 10:07:47,520
equal so let's see this let me go ahead

16067
10:07:44,960 --> 10:07:49,560
and close addresses. C and actually

16068
10:07:47,520 --> 10:07:51,960
before I do one last mention one of the

16069
10:07:49,560 --> 10:07:54,720
powerful things about Pointer arithmetic

16070
10:07:51,960 --> 10:07:57,680
as an aside is that c and really the

16071
10:07:54,720 --> 10:08:00,200
compiler is smart enough to know how

16072
10:07:57,680 --> 10:08:01,520
many bytes to keep adding and adding and

16073
10:08:00,200 --> 10:08:03,115
by that I mean this right now we got

16074
10:08:01,520 --> 10:08:04,560
lucky because a string is a sequence of

16075
10:08:03,116 --> 10:08:06,520
characters and by definition every

16076
10:08:04,560 --> 10:08:08,560
character is is a single bite you can

16077
10:08:06,520 --> 10:08:11,200
poke around and do s+ one to get the

16078
10:08:08,560 --> 10:08:13,320
next bite S Plus 2 to get the uh the

16079
10:08:11,200 --> 10:08:14,960
third bite however if we weren't dealing

16080
10:08:13,320 --> 10:08:17,520
with strings suppose we were dealing

16081
10:08:14,960 --> 10:08:19,436
with integers that were in an array back

16082
10:08:17,520 --> 10:08:22,520
to back to back if you wanted to get at

16083
10:08:19,436 --> 10:08:24,596
the next integer you could still do plus

16084
10:08:22,520 --> 10:08:26,159
one or plus two to get at the next or

16085
10:08:24,596 --> 10:08:28,040
the next next integer you would not

16086
10:08:26,160 --> 10:08:30,480
start to get into the weeds of doing

16087
10:08:28,040 --> 10:08:32,276
plus four and then plus eight you don't

16088
10:08:30,480 --> 10:08:34,040
have to know or care how big the data

16089
10:08:32,276 --> 10:08:35,680
types are in the computer C and the

16090
10:08:34,040 --> 10:08:37,596
compiler will figure that out for you

16091
10:08:35,680 --> 10:08:39,276
based on the data type in question so

16092
10:08:37,596 --> 10:08:41,799
keep that in mind if ever doing this on

16093
10:08:39,276 --> 10:08:43,159
a different data type uh than chars all

16094
10:08:41,800 --> 10:08:46,040
right so let me go ahead and open up a

16095
10:08:43,160 --> 10:08:47,596
file that I wrote in advance most of and

16096
10:08:46,040 --> 10:08:49,436
let me hide my terminal window and show

16097
10:08:47,596 --> 10:08:51,320
you this so here is a program called

16098
10:08:49,436 --> 10:08:53,916
compare. C whose purpose in life is to

16099
10:08:51,320 --> 10:08:55,596
compare two strings I'm back to using

16100
10:08:53,916 --> 10:08:57,596
the cs50 library because at least for

16101
10:08:55,596 --> 10:08:59,680
now in probably a couple more weeks it

16102
10:08:57,596 --> 10:09:02,079
is so much easier to get input from the

16103
10:08:59,680 --> 10:09:03,840
user using cs50's function get in but

16104
10:09:02,080 --> 10:09:05,880
we'll conclude today by taking off those

16105
10:09:03,840 --> 10:09:07,520
training wheels as well so you can see

16106
10:09:05,880 --> 10:09:10,200
how you can actually get user input with

16107
10:09:07,520 --> 10:09:12,916
nothing cs50 specific so line six and

16108
10:09:10,200 --> 10:09:15,200
seven pretty boring week one stuff get

16109
10:09:12,916 --> 10:09:16,880
an INT called I get an INT called J and

16110
10:09:15,200 --> 10:09:19,719
store them in two variables I and J

16111
10:09:16,880 --> 10:09:21,719
respectively if I equals equals J print

16112
10:09:19,720 --> 10:09:23,680
out the same else print out that they're

16113
10:09:21,720 --> 10:09:25,200
different let me just stipulate for time

16114
10:09:23,680 --> 10:09:26,880
sake I'm pretty sure this code is

16115
10:09:25,200 --> 10:09:28,799
correct this will get two integers from

16116
10:09:26,880 --> 10:09:30,960
the human it will compare them and tell

16117
10:09:28,800 --> 10:09:33,080
me correctly if they're the same or

16118
10:09:30,960 --> 10:09:36,116
different and I'll prove as much by

16119
10:09:33,080 --> 10:09:38,880
running make compare

16120
10:09:36,116 --> 10:09:41,400
slash compare and I'll type in 50 for I

16121
10:09:38,880 --> 10:09:45,040
50 for J and they're the same and now

16122
10:09:41,400 --> 10:09:46,240
I'll do how about 50 and say 13 and

16123
10:09:45,040 --> 10:09:48,080
those are different so let me just

16124
10:09:46,240 --> 10:09:49,916
stipulate this code is indeed correct

16125
10:09:48,080 --> 10:09:52,400
would have worked in week one also works

16126
10:09:49,916 --> 10:09:55,115
now in week four but let me now change

16127
10:09:52,400 --> 10:09:57,916
it to compare not two integers but as I

16128
10:09:55,116 --> 10:10:00,200
hinted maybe two strings instead so let

16129
10:09:57,916 --> 10:10:03,880
me go ahead and change this line of code

16130
10:10:00,200 --> 10:10:06,799
to maybe be string s equals get string

16131
10:10:03,880 --> 10:10:08,560
uh asking the user for s s uh then let's

16132
10:10:06,800 --> 10:10:10,360
change this second line here to be

16133
10:10:08,560 --> 10:10:13,040
string T just to keep the variable name

16134
10:10:10,360 --> 10:10:14,960
short for now and T is a good uh Choice

16135
10:10:13,040 --> 10:10:17,840
after s for something like this get

16136
10:10:14,960 --> 10:10:20,200
string prompt the human for T and then

16137
10:10:17,840 --> 10:10:22,679
let's change our I and J here to do the

16138
10:10:20,200 --> 10:10:25,200
wrong thing per the intuition earlier if

16139
10:10:22,680 --> 10:10:26,916
s equals equals T then print out the

16140
10:10:25,200 --> 10:10:28,840
same else print out that they're

16141
10:10:26,916 --> 10:10:30,115
different now if I want I could take off

16142
10:10:28,840 --> 10:10:31,916
at least some of the training wheels I

16143
10:10:30,116 --> 10:10:34,116
could change this to char star I could

16144
10:10:31,916 --> 10:10:35,596
change this to char star either is fine

16145
10:10:34,116 --> 10:10:36,880
I still need the Cs library though

16146
10:10:35,596 --> 10:10:38,680
because I'm using get string because

16147
10:10:36,880 --> 10:10:40,479
it's actually hard as we'll see today to

16148
10:10:38,680 --> 10:10:42,480
get strings manually without using a

16149
10:10:40,480 --> 10:10:44,800
library but I'll keep it using string

16150
10:10:42,480 --> 10:10:46,200
just for now with the library all right

16151
10:10:44,800 --> 10:10:48,720
make compare

16152
10:10:46,200 --> 10:10:51,115
again compare and now let me go ahead

16153
10:10:48,720 --> 10:10:53,756
and type in for instance Hi exclamation

16154
10:10:51,116 --> 10:10:57,080
point Enter and Hi exclamation point

16155
10:10:53,756 --> 10:10:58,756
Enter and they're different all they're

16156
10:10:57,080 --> 10:11:00,400
obviously not visually but they are

16157
10:10:58,756 --> 10:11:02,560
underneath the hood and you probably do

16158
10:11:00,400 --> 10:11:04,240
have the intuition for this already

16159
10:11:02,560 --> 10:11:05,840
whereby what's going on underneath the

16160
10:11:04,240 --> 10:11:08,115
hood is that we're comparing

16161
10:11:05,840 --> 10:11:10,115
accidentally the two memory addresses so

16162
10:11:08,116 --> 10:11:11,720
in fact let's go there let's consider

16163
10:11:10,116 --> 10:11:13,560
the memory and let me zoom out now so I

16164
10:11:11,720 --> 10:11:14,960
can just have more btes to play with so

16165
10:11:13,560 --> 10:11:17,040
the squares are a little smaller than

16166
10:11:14,960 --> 10:11:19,880
before just so we can fit more in them

16167
10:11:17,040 --> 10:11:23,160
and let me propose that when I declare s

16168
10:11:19,880 --> 10:11:24,719
on what was line six a moment ago it

16169
10:11:23,160 --> 10:11:26,080
ends up somewhere in memory like the top

16170
10:11:24,720 --> 10:11:29,436
leftand corner of my picture for

16171
10:11:26,080 --> 10:11:32,116
discussion sake and when I uh execute

16172
10:11:29,436 --> 10:11:34,400
that same line of code and get string is

16173
10:11:32,116 --> 10:11:36,520
called and I type in high exclamation

16174
10:11:34,400 --> 10:11:37,960
point we know from week one that get

16175
10:11:36,520 --> 10:11:39,680
string puts it somewhere in the

16176
10:11:37,960 --> 10:11:41,276
computer's memory and I'll propose that

16177
10:11:39,680 --> 10:11:43,560
it's in like the bottom left hand corner

16178
10:11:41,276 --> 10:11:45,079
of the screen here what happens after

16179
10:11:43,560 --> 10:11:47,756
that well I know even though I don't

16180
10:11:45,080 --> 10:11:49,276
generally care that Hi exclamation point

16181
10:11:47,756 --> 10:11:53,320
in the null character exist at some

16182
10:11:49,276 --> 10:11:56,000
address like ox123 12 4 125 126 for

16183
10:11:53,320 --> 10:11:59,436
discussion sake and what's in s same as

16184
10:11:56,000 --> 10:12:02,200
before break 0x1 23 so that's all that's

16185
10:11:59,436 --> 10:12:03,560
happening again on line six which is

16186
10:12:02,200 --> 10:12:06,360
pretty much the same as when we were

16187
10:12:03,560 --> 10:12:08,479
getting an S earlier but notice now with

16188
10:12:06,360 --> 10:12:11,200
line seven when I get a second variable

16189
10:12:08,480 --> 10:12:13,240
called T and I call get string again and

16190
10:12:11,200 --> 10:12:15,320
by coincidence as the human I type the

16191
10:12:13,240 --> 10:12:17,276
same thing well what happens here T gets

16192
10:12:15,320 --> 10:12:20,080
its own chunk of memory maybe at the top

16193
10:12:17,276 --> 10:12:21,916
right uh that second version of high

16194
10:12:20,080 --> 10:12:23,480
gets somewhere else in memory you know

16195
10:12:21,916 --> 10:12:25,320
the computer could be smart and notice

16196
10:12:23,480 --> 10:12:26,800
it's the same but C doesn't generally do

16197
10:12:25,320 --> 10:12:28,800
that for you it just plops it somewhere

16198
10:12:26,800 --> 10:12:33,320
else in memory and maybe it's at address

16199
10:12:28,800 --> 10:12:34,436
Ox 456 457 458 459 or wherever but you

16200
10:12:33,320 --> 10:12:36,320
can perhaps see where this is going

16201
10:12:34,436 --> 10:12:38,640
already T now of course contains the

16202
10:12:36,320 --> 10:12:42,240
address of that first bite and so in my

16203
10:12:38,640 --> 10:12:45,276
code on line nine when I compare s and t

16204
10:12:42,240 --> 10:12:48,079
for equality suffice it to say they are

16205
10:12:45,276 --> 10:12:49,840
not equal because of the way the uh

16206
10:12:48,080 --> 10:12:51,840
strings are laid out in the computer's

16207
10:12:49,840 --> 10:12:53,596
memory it's indeed looks the same the

16208
10:12:51,840 --> 10:12:55,679
same values are there but if we abstract

16209
10:12:53,596 --> 10:12:59,756
away further you can really see that s

16210
10:12:55,680 --> 10:13:01,596
and t are not the same themselves and so

16211
10:12:59,756 --> 10:13:03,596
how did we fix this or really how did we

16212
10:13:01,596 --> 10:13:05,040
avoid this last week without spilling

16213
10:13:03,596 --> 10:13:06,916
the beans and going down this Rabbit

16214
10:13:05,040 --> 10:13:08,800
Hole explaining like why you have to use

16215
10:13:06,916 --> 10:13:11,719
Stir compare well if I go back to my

16216
10:13:08,800 --> 10:13:14,360
code here let's do it now the right way

16217
10:13:11,720 --> 10:13:16,960
let me go ahead and include uh a line of

16218
10:13:14,360 --> 10:13:20,840
code that says string compare of s comma

16219
10:13:16,960 --> 10:13:22,799
T both as inputs and then if you recall

16220
10:13:20,840 --> 10:13:24,916
what does stir compare return when two

16221
10:13:22,800 --> 10:13:27,960
strings are equal there's three possible

16222
10:13:24,916 --> 10:13:29,916
return values so zero so one is for if

16223
10:13:27,960 --> 10:13:32,159
it comes alphabetically or atically

16224
10:13:29,916 --> 10:13:34,360
first or second but for now I just want

16225
10:13:32,160 --> 10:13:35,520
zero if I want to use S compare I do

16226
10:13:34,360 --> 10:13:38,240
need

16227
10:13:35,520 --> 10:13:40,359
string.h so string.h does exist that's

16228
10:13:38,240 --> 10:13:42,840
not a cs50 thing there's no keyword

16229
10:13:40,360 --> 10:13:45,320
string as a data type that's a cs50

16230
10:13:42,840 --> 10:13:47,719
thing but string.h does exist so I think

16231
10:13:45,320 --> 10:13:51,200
now with that change on line 10 if I do

16232
10:13:47,720 --> 10:13:53,880
make compare and slash compare and then

16233
10:13:51,200 --> 10:13:56,596
run again uh type again High exclamation

16234
10:13:53,880 --> 10:13:59,320
point High exclamation point I think now

16235
10:13:56,596 --> 10:14:01,880
they're the same and just as a uh second

16236
10:13:59,320 --> 10:14:04,436
check high in L caps maybe high in

16237
10:14:01,880 --> 10:14:06,755
lowercase those are in fact different

16238
10:14:04,436 --> 10:14:09,436
why well stir compare which was written

16239
10:14:06,756 --> 10:14:11,800
by some other human decades ago is just

16240
10:14:09,436 --> 10:14:15,160
smart enough to know that it should go

16241
10:14:11,800 --> 10:14:17,596
to S and go to T start comparing them

16242
10:14:15,160 --> 10:14:20,116
left to right stopping once it hits one

16243
10:14:17,596 --> 10:14:23,040
or both null characters and return zero

16244
10:14:20,116 --> 10:14:27,080
only if everything in s and and T are

16245
10:14:23,040 --> 10:14:28,480
exactly the same are any questions then

16246
10:14:27,080 --> 10:14:30,960
on this

16247
10:14:28,480 --> 10:14:34,436
here any questions on why we're using

16248
10:14:30,960 --> 10:14:36,596
stir compare all right if no yeah oh in

16249
10:14:34,436 --> 10:14:36,596
the

16250
10:14:38,840 --> 10:14:43,399
middle yes so so why does why is it not

16251
10:14:41,756 --> 10:14:45,200
the case with integers so it turns out

16252
10:14:43,400 --> 10:14:48,436
it's not the case with integers with

16253
10:14:45,200 --> 10:14:50,115
floats with bulls with uh doubles with

16254
10:14:48,436 --> 10:14:52,916
Longs like literally every other data

16255
10:14:50,116 --> 10:14:54,680
type works correctly strings though are

16256
10:14:52,916 --> 10:14:56,560
special they are useful enough in

16257
10:14:54,680 --> 10:14:58,080
programming and have been for decades

16258
10:14:56,560 --> 10:14:59,840
that the authors of printf and the

16259
10:14:58,080 --> 10:15:01,960
authors of stir compare and bunches of

16260
10:14:59,840 --> 10:15:04,200
other functions Sterling for that matter

16261
10:15:01,960 --> 10:15:05,756
just kind of treat strings special

16262
10:15:04,200 --> 10:15:07,435
because they're just useful right we

16263
10:15:05,756 --> 10:15:08,960
humans interact using language be it

16264
10:15:07,436 --> 10:15:12,080
English or anything else and so it's

16265
10:15:08,960 --> 10:15:14,520
just useful to have into the language C

16266
10:15:12,080 --> 10:15:17,276
just sort of uh first class support for

16267
10:15:14,520 --> 10:15:19,640
this notion of strings of human text so

16268
10:15:17,276 --> 10:15:21,680
the short answer is just because like it

16269
10:15:19,640 --> 10:15:23,756
just uh is necessar strings are

16270
10:15:21,680 --> 10:15:25,596
different they're implemented with this

16271
10:15:23,756 --> 10:15:28,040
address and the null character

16272
10:15:25,596 --> 10:15:29,680
everything else though is just a value

16273
10:15:28,040 --> 10:15:33,480
but a string again is a white lie it's

16274
10:15:29,680 --> 10:15:36,480
an address it's not a thing unto itself

16275
10:15:33,480 --> 10:15:36,480
good question yeah in front

16276
10:15:37,756 --> 10:15:44,116
oh really good question so in my code

16277
10:15:39,800 --> 10:15:46,436
here in vs code what if I do this

16278
10:15:44,116 --> 10:15:49,240
instead of stir compare and instead of

16279
10:15:46,436 --> 10:15:53,080
if s equals equals T what if I start

16280
10:15:49,240 --> 10:15:54,916
playing around using star s and star T

16281
10:15:53,080 --> 10:15:56,596
really interesting case to consider

16282
10:15:54,916 --> 10:15:58,880
let's go back to our sort of deductive

16283
10:15:56,596 --> 10:16:01,360
logic here so star the asteris operator

16284
10:15:58,880 --> 10:16:04,040
today means go there so when I've typed

16285
10:16:01,360 --> 10:16:06,560
in high once and then high again both

16286
10:16:04,040 --> 10:16:09,436
uppercase for instance what is at the

16287
10:16:06,560 --> 10:16:13,360
address s literally someone

16288
10:16:09,436 --> 10:16:16,116
else what is at the address s yeah uh so

16289
10:16:13,360 --> 10:16:18,840
not quite at the address not so not what

16290
10:16:16,116 --> 10:16:22,560
is the address what is at the address

16291
10:16:18,840 --> 10:16:26,159
ox123 H and what is at the address Ox

16292
10:16:22,560 --> 10:16:28,200
456 H also and so here you're kind of

16293
10:16:26,160 --> 10:16:31,160
cheating like you're comparing the first

16294
10:16:28,200 --> 10:16:32,960
character of both strings but not every

16295
10:16:31,160 --> 10:16:34,880
other one now you could be really

16296
10:16:32,960 --> 10:16:37,200
pedantic and here again this is like a

16297
10:16:34,880 --> 10:16:39,755
good use of uh codee but you could do

16298
10:16:37,200 --> 10:16:41,680
this if that and how about this

16299
10:16:39,756 --> 10:16:46,520
craziness so star

16300
10:16:41,680 --> 10:16:47,916
s+1 equals equals star t + one and and

16301
10:16:46,520 --> 10:16:49,399
you could do this for every character

16302
10:16:47,916 --> 10:16:51,200
manually but that's why stir compare

16303
10:16:49,400 --> 10:16:52,960
exists it does all of this for you but

16304
10:16:51,200 --> 10:16:54,240
that's why and that's the intuition so I

16305
10:16:52,960 --> 10:16:56,640
would encourage you too anytime there's

16306
10:16:54,240 --> 10:16:58,360
something kind of weird going on there's

16307
10:16:56,640 --> 10:16:59,960
I realize we might be um straining

16308
10:16:58,360 --> 10:17:02,520
credibility now we haven't told you that

16309
10:16:59,960 --> 10:17:05,159
many white lies and so most everything

16310
10:17:02,520 --> 10:17:07,039
that we've seen thus far can explain

16311
10:17:05,160 --> 10:17:09,436
pretty much all of the behavior up until

16312
10:17:07,040 --> 10:17:11,560
now from week one onward in C so let me

16313
10:17:09,436 --> 10:17:14,360
revert this back to the right way if s

16314
10:17:11,560 --> 10:17:16,079
compare of S&T equals equals z this now

16315
10:17:14,360 --> 10:17:17,560
is the right version of the code and now

16316
10:17:16,080 --> 10:17:19,800
here is again where you can play so let

16317
10:17:17,560 --> 10:17:22,000
me do this let me um clear my terminal

16318
10:17:19,800 --> 10:17:23,680
window just to tidy things up let me get

16319
10:17:22,000 --> 10:17:25,160
rid of all of this comparison stuff and

16320
10:17:23,680 --> 10:17:27,000
let's just see what's going on as you

16321
10:17:25,160 --> 10:17:28,800
are welcome to in your own code let's

16322
10:17:27,000 --> 10:17:31,320
print out for instance as we might have

16323
10:17:28,800 --> 10:17:33,400
in week one the value of s itself in a

16324
10:17:31,320 --> 10:17:34,880
new line comma s and then let's just

16325
10:17:33,400 --> 10:17:36,320
print out T just to make sure it

16326
10:17:34,880 --> 10:17:37,960
compiles and I'm not doing anything

16327
10:17:36,320 --> 10:17:40,520
wrong but this is not going to be that

16328
10:17:37,960 --> 10:17:42,360
interesting and frankly I don't need

16329
10:17:40,520 --> 10:17:45,799
string.h anymore because I'm not using

16330
10:17:42,360 --> 10:17:50,400
stir compare so make addresses addresses

16331
10:17:45,800 --> 10:17:53,520
there's my um oh sorry that's fun okay

16332
10:17:50,400 --> 10:17:55,640
not percent T percent s here too ignore

16333
10:17:53,520 --> 10:17:58,479
that let's do this again make a oh and

16334
10:17:55,640 --> 10:17:59,960
that's the wrong program okay dot SL

16335
10:17:58,480 --> 10:18:02,916
let's do make

16336
10:17:59,960 --> 10:18:04,720
compare compare and let's type in high

16337
10:18:02,916 --> 10:18:06,435
again and high again and and now we just

16338
10:18:04,720 --> 10:18:08,080
see the two strings I'm not comparing

16339
10:18:06,436 --> 10:18:10,720
but now we can kind of play around right

16340
10:18:08,080 --> 10:18:13,160
instead of printing out percent s which

16341
10:18:10,720 --> 10:18:16,720
prints the string how do I print the

16342
10:18:13,160 --> 10:18:19,640
address in S I just need to make a

16343
10:18:16,720 --> 10:18:22,560
slight change if I want to see not

16344
10:18:19,640 --> 10:18:25,560
what's at s but I want to see s the

16345
10:18:22,560 --> 10:18:25,560
address

16346
10:18:26,596 --> 10:18:32,960
yeah perfect so change percent s in both

16347
10:18:29,560 --> 10:18:34,680
places here to percent P so now printf

16348
10:18:32,960 --> 10:18:36,000
will treat it literally as an dress it's

16349
10:18:34,680 --> 10:18:37,480
not going to do any fanciness this with

16350
10:18:36,000 --> 10:18:38,960
a loop from left to right looking for

16351
10:18:37,480 --> 10:18:40,840
the null character it's just going to

16352
10:18:38,960 --> 10:18:43,276
print out S&T so let me clear my

16353
10:18:40,840 --> 10:18:46,560
terminal run make compare whoops let's

16354
10:18:43,276 --> 10:18:49,479
do make comparecompare enter type in

16355
10:18:46,560 --> 10:18:52,360
high type in high again and now you see

16356
10:18:49,480 --> 10:18:53,880
oh so this is interesting it's not quite

16357
10:18:52,360 --> 10:18:56,240
as straightforward as the other values

16358
10:18:53,880 --> 10:18:59,079
which were slight one bite away they're

16359
10:18:56,240 --> 10:19:01,320
almost the same but this one ends in b0

16360
10:18:59,080 --> 10:19:04,436
this one ends in F0 so they're indeed

16361
10:19:01,320 --> 10:19:06,000
separated by some number of bytes not

16362
10:19:04,436 --> 10:19:08,680
just one but a few because these strings

16363
10:19:06,000 --> 10:19:11,200
are indeed longer all right so once

16364
10:19:08,680 --> 10:19:13,720
you've seen this here how can we now

16365
10:19:11,200 --> 10:19:15,520
maybe leverage this to solve other

16366
10:19:13,720 --> 10:19:17,960
problems well let me propose that we do

16367
10:19:15,520 --> 10:19:20,799
this let me uh zoom out here let me

16368
10:19:17,960 --> 10:19:22,276
close compare and let me open up another

16369
10:19:20,800 --> 10:19:23,276
program I wrote part of in advance

16370
10:19:22,276 --> 10:19:27,479
called

16371
10:19:23,276 --> 10:19:31,000
copy.c so copy. C in theory makes a copy

16372
10:19:27,480 --> 10:19:32,596
of a string how on line eight I'm using

16373
10:19:31,000 --> 10:19:35,000
the same thing as before get string

16374
10:19:32,596 --> 10:19:37,040
storing in a string or char star and

16375
10:19:35,000 --> 10:19:39,520
asking the user for it then I'm not

16376
10:19:37,040 --> 10:19:42,800
asking get string again I'm just making

16377
10:19:39,520 --> 10:19:46,000
a copy super simply with line 10 here

16378
10:19:42,800 --> 10:19:47,596
string T equals s now intuitively I

16379
10:19:46,000 --> 10:19:49,160
think that's how I would copy a variable

16380
10:19:47,596 --> 10:19:51,360
right that's how we've copied variables

16381
10:19:49,160 --> 10:19:54,560
every week thus far and see but

16382
10:19:51,360 --> 10:19:56,400
something's going to go wrong in line 12

16383
10:19:54,560 --> 10:19:58,840
in English does someone want to explain

16384
10:19:56,400 --> 10:20:00,960
what you think line 12 does don't worry

16385
10:19:58,840 --> 10:20:02,960
about finding any bugs or mistakes but

16386
10:20:00,960 --> 10:20:04,756
what does line 12 seem to be doing using

16387
10:20:02,960 --> 10:20:06,640
two upper which which is thanks to the

16388
10:20:04,756 --> 10:20:10,240
ctype library which I've included the

16389
10:20:06,640 --> 10:20:12,840
header file for

16390
10:20:10,240 --> 10:20:14,400
yeah yeah right it's kind of like ugly

16391
10:20:12,840 --> 10:20:16,755
syntax but this would seem to be

16392
10:20:14,400 --> 10:20:19,000
capitalizing the first letter of T

16393
10:20:16,756 --> 10:20:20,596
specifically and just changing it so we

16394
10:20:19,000 --> 10:20:22,436
have t bracket Zer here because we want

16395
10:20:20,596 --> 10:20:24,560
to save the change and we're passing to

16396
10:20:22,436 --> 10:20:26,520
two upper the first character here so

16397
10:20:24,560 --> 10:20:29,756
this is how we did uppercase in the past

16398
10:20:26,520 --> 10:20:31,799
and now I print out s and t respectively

16399
10:20:29,756 --> 10:20:34,680
using percent s so this feels like it

16400
10:20:31,800 --> 10:20:37,360
should work I copied s and stored it in

16401
10:20:34,680 --> 10:20:40,640
t on line 10 and then I change T and

16402
10:20:37,360 --> 10:20:42,800
only t on line 12 but you can perhaps if

16403
10:20:40,640 --> 10:20:45,240
you're comfy thus far see where this is

16404
10:20:42,800 --> 10:20:48,560
going if I do make

16405
10:20:45,240 --> 10:20:51,079
copy copy and let me type in lowercase

16406
10:20:48,560 --> 10:20:53,240
Hi exclamation point this time just once

16407
10:20:51,080 --> 10:20:55,960
so I'm going to hit enter and watch what

16408
10:20:53,240 --> 10:20:59,560
we see for the value of s and

16409
10:20:55,960 --> 10:21:03,240
t huh the new value of SN T at the end

16410
10:20:59,560 --> 10:21:04,799
of my program seems to be what it seems

16411
10:21:03,240 --> 10:21:08,276
to be

16412
10:21:04,800 --> 10:21:10,756
the same high is capitalized both times

16413
10:21:08,276 --> 10:21:13,159
so what's the intuition then for this

16414
10:21:10,756 --> 10:21:15,840
why did this just

16415
10:21:13,160 --> 10:21:18,720
happen yeah and

16416
10:21:15,840 --> 10:21:22,115
back yeah I assigned S&T the same memory

16417
10:21:18,720 --> 10:21:24,116
address so it did copy s into T but C

16418
10:21:22,116 --> 10:21:26,116
takes this very literally what is s it's

16419
10:21:24,116 --> 10:21:28,000
an address what is T it's a copy of that

16420
10:21:26,116 --> 10:21:30,040
address if you want to copy the whole

16421
10:21:28,000 --> 10:21:31,800
string like a normal human would expect

16422
10:21:30,040 --> 10:21:34,080
hey you or someone has to do a lot more

16423
10:21:31,800 --> 10:21:35,800
work you have to go to that address copy

16424
10:21:34,080 --> 10:21:37,880
this character this one this one this

16425
10:21:35,800 --> 10:21:39,400
one and copy it to a new location in

16426
10:21:37,880 --> 10:21:41,079
memory that does not happen

16427
10:21:39,400 --> 10:21:42,596
automatically here for you in C it does

16428
10:21:41,080 --> 10:21:43,840
in some other languages those of you

16429
10:21:42,596 --> 10:21:45,640
who've programmed in certain higher

16430
10:21:43,840 --> 10:21:46,679
level languages this just works as you

16431
10:21:45,640 --> 10:21:48,520
would hope and that's one of the

16432
10:21:46,680 --> 10:21:50,520
benefits of python and other languages

16433
10:21:48,520 --> 10:21:52,479
that we'll soon see but for now it

16434
10:21:50,520 --> 10:21:54,680
literally takes at face value what this

16435
10:21:52,480 --> 10:21:56,436
is copy the address into this address

16436
10:21:54,680 --> 10:21:58,840
and I'll make that more clear by getting

16437
10:21:56,436 --> 10:22:00,880
rid of the string keyword which again is

16438
10:21:58,840 --> 10:22:02,679
just a type def this is technically an

16439
10:22:00,880 --> 10:22:04,200
address here this is technically an

16440
10:22:02,680 --> 10:22:06,680
address here so what's being being

16441
10:22:04,200 --> 10:22:08,719
copied is the value of that address not

16442
10:22:06,680 --> 10:22:11,320
all of the characters that might very

16443
10:22:08,720 --> 10:22:13,800
well follow it so I should make one note

16444
10:22:11,320 --> 10:22:15,840
to here I'm going to start getting more

16445
10:22:13,800 --> 10:22:18,200
in the habit of trying to avoid

16446
10:22:15,840 --> 10:22:20,799
segmentation faults because things could

16447
10:22:18,200 --> 10:22:23,880
go wrong here for instance online 12

16448
10:22:20,800 --> 10:22:25,880
previously I was kind of blindly naively

16449
10:22:23,880 --> 10:22:28,520
dangerously assuming that there will be

16450
10:22:25,880 --> 10:22:29,916
at least one character in s or t that

16451
10:22:28,520 --> 10:22:31,719
might not be the case if the user Just

16452
10:22:29,916 --> 10:22:33,680
Hits enter there's no characters to

16453
10:22:31,720 --> 10:22:35,756
uppercase and so this is reckless of me

16454
10:22:33,680 --> 10:22:38,040
and could theoretically create a sigall

16455
10:22:35,756 --> 10:22:39,916
so I should probably start to be smarter

16456
10:22:38,040 --> 10:22:43,200
and say something like this if the

16457
10:22:39,916 --> 10:22:45,596
length of T is greater than zero okay

16458
10:22:43,200 --> 10:22:47,520
now it's safe to actually capitalize the

16459
10:22:45,596 --> 10:22:49,560
first letter and that will decrease the

16460
10:22:47,520 --> 10:22:52,159
probability now of those segmentation

16461
10:22:49,560 --> 10:22:54,115
faults by just not making any

16462
10:22:52,160 --> 10:22:56,000
assumptions about what the human does

16463
10:22:54,116 --> 10:22:58,320
almost always the your programs will

16464
10:22:56,000 --> 10:23:00,400
crash when you've made a mistake yes but

16465
10:22:58,320 --> 10:23:02,116
the user gives you an input that you

16466
10:23:00,400 --> 10:23:04,360
yourself did not

16467
10:23:02,116 --> 10:23:06,000
expect so what does this all look like

16468
10:23:04,360 --> 10:23:08,400
in memory well let's go back to the Big

16469
10:23:06,000 --> 10:23:11,080
Grid this time focusing on the copying

16470
10:23:08,400 --> 10:23:13,560
of values and let's do this here's S as

16471
10:23:11,080 --> 10:23:15,880
in this new program just declared to be

16472
10:23:13,560 --> 10:23:17,680
a Char star uh here is where my

16473
10:23:15,880 --> 10:23:19,240
lowercase High maybe ended up in the

16474
10:23:17,680 --> 10:23:22,400
computer's memory that's probably at

16475
10:23:19,240 --> 10:23:24,159
ox123 12 4 125 whatever something like

16476
10:23:22,400 --> 10:23:27,916
that and that's of course what ends up

16477
10:23:24,160 --> 10:23:30,160
in s as a value when I declare T I do

16478
10:23:27,916 --> 10:23:34,435
get a second variable called T just like

16479
10:23:30,160 --> 10:23:37,680
before but when I copy s into T what

16480
10:23:34,436 --> 10:23:40,000
happens it's really just literally ox1 2

16481
10:23:37,680 --> 10:23:42,040
3 whatever the value of s is is now also

16482
10:23:40,000 --> 10:23:43,596
the value of T and so if we abstract

16483
10:23:42,040 --> 10:23:46,240
this away at a high level get rid of all

16484
10:23:43,596 --> 10:23:48,596
of those extra squares this is what s

16485
10:23:46,240 --> 10:23:50,680
and t now are they're indeed copies but

16486
10:23:48,596 --> 10:23:52,756
copies of each other not copies of the

16487
10:23:50,680 --> 10:23:55,436
underlying characters and so if you

16488
10:23:52,756 --> 10:23:57,240
follow those arrows um and try to print

16489
10:23:55,436 --> 10:23:58,916
them both out after capitalizing one or

16490
10:23:57,240 --> 10:24:01,115
the other you're going to unfortunately

16491
10:23:58,916 --> 10:24:04,680
end up capitalizing not just one of them

16492
10:24:01,116 --> 10:24:07,160
s but both of them s and T because

16493
10:24:04,680 --> 10:24:09,240
literally it's the same address any

16494
10:24:07,160 --> 10:24:12,080
questions then on this

16495
10:24:09,240 --> 10:24:14,640
visualization

16496
10:24:12,080 --> 10:24:18,720
yeah good question is this pass by

16497
10:24:14,640 --> 10:24:21,479
reference we haven't um we have not seen

16498
10:24:18,720 --> 10:24:23,400
in detail an example like that um right

16499
10:24:21,480 --> 10:24:24,560
now you're copying by value but

16500
10:24:23,400 --> 10:24:25,880
references will come into play and

16501
10:24:24,560 --> 10:24:27,560
remind me in a bit if I haven't used

16502
10:24:25,880 --> 10:24:31,360
that term yet but this is just copying

16503
10:24:27,560 --> 10:24:32,680
things by could have ended poorly value

16504
10:24:31,360 --> 10:24:36,360
other

16505
10:24:32,680 --> 10:24:39,200
questions no all right so with this in

16506
10:24:36,360 --> 10:24:41,200
mind like how do we actually copy things

16507
10:24:39,200 --> 10:24:42,880
properly for this we actually need

16508
10:24:41,200 --> 10:24:44,719
another building block so today we give

16509
10:24:42,880 --> 10:24:47,000
you two functions one of which is called

16510
10:24:44,720 --> 10:24:49,000
Malo one of which is called free and

16511
10:24:47,000 --> 10:24:50,720
these are used all of the time by like

16512
10:24:49,000 --> 10:24:52,720
every piece of software you and I use on

16513
10:24:50,720 --> 10:24:54,360
our Macs PCS and phones whether it's

16514
10:24:52,720 --> 10:24:57,320
written in C or some equivalent other

16515
10:24:54,360 --> 10:24:59,840
language Malo is for memory allocation

16516
10:24:57,320 --> 10:25:01,800
it's a function that you can use to ask

16517
10:24:59,840 --> 10:25:03,840
the operating system Mac OS Linux

16518
10:25:01,800 --> 10:25:06,160
Windows anything for some number of of

16519
10:25:03,840 --> 10:25:08,039
bytes one bite 100 bytes a gigabyte of

16520
10:25:06,160 --> 10:25:10,320
memory you can ask malog for however

16521
10:25:08,040 --> 10:25:13,436
much memory you want in advance it will

16522
10:25:10,320 --> 10:25:15,400
return to you the address of the first

16523
10:25:13,436 --> 10:25:18,000
bite of memory that it found free for

16524
10:25:15,400 --> 10:25:20,520
you unlike a string it is not null

16525
10:25:18,000 --> 10:25:22,160
terminated and so the danger with malok

16526
10:25:20,520 --> 10:25:24,680
is that it's on the honor System if you

16527
10:25:22,160 --> 10:25:26,680
ask it for one bite or 10 bytes you the

16528
10:25:24,680 --> 10:25:28,960
programmer in like a variable have to

16529
10:25:26,680 --> 10:25:31,160
remember how many byes you requested one

16530
10:25:28,960 --> 10:25:32,799
or 10 or the like strings do that for

16531
10:25:31,160 --> 10:25:34,240
you not when we're getting now to this

16532
10:25:32,800 --> 10:25:35,756
low level Mal just going to give you

16533
10:25:34,240 --> 10:25:37,680
some memory and it's up to you to manage

16534
10:25:35,756 --> 10:25:38,960
it free does the opposite when you're

16535
10:25:37,680 --> 10:25:40,960
done with some chunk of memory you can

16536
10:25:38,960 --> 10:25:42,596
free it by passing in that same address

16537
10:25:40,960 --> 10:25:44,276
and just hand it back to Mac OS windows

16538
10:25:42,596 --> 10:25:46,040
or Linux and say I'm done with this you

16539
10:25:44,276 --> 10:25:49,320
can let me use this for something else

16540
10:25:46,040 --> 10:25:52,360
later um as an aside if your computer

16541
10:25:49,320 --> 10:25:53,680
has ever like frozen or hung like the

16542
10:25:52,360 --> 10:25:55,640
whole thing maybe just spontaneously

16543
10:25:53,680 --> 10:25:57,320
reboots yet another reason for a bug

16544
10:25:55,640 --> 10:25:59,276
like that might be if you write a

16545
10:25:57,320 --> 10:26:00,800
program with a bug that keeps Mal

16546
10:25:59,276 --> 10:26:02,756
loocking Mal loocking Mal loocking that

16547
10:26:00,800 --> 10:26:04,800
is asking for more and more and more

16548
10:26:02,756 --> 10:26:06,560
memory but you make a mistake and you

16549
10:26:04,800 --> 10:26:08,040
never free it well eventually the

16550
10:26:06,560 --> 10:26:09,880
computer is going to literally run out

16551
10:26:08,040 --> 10:26:12,200
of memory and something's going to go

16552
10:26:09,880 --> 10:26:13,880
wrong and that's often when computers

16553
10:26:12,200 --> 10:26:15,916
freeze like they're just out of memory

16554
10:26:13,880 --> 10:26:17,435
it has the memory there but the program

16555
10:26:15,916 --> 10:26:19,360
was trying to use too much of it

16556
10:26:17,436 --> 10:26:21,116
endlessly so this too will be a mistake

16557
10:26:19,360 --> 10:26:22,916
that some of us will surely make in the

16558
10:26:21,116 --> 10:26:25,320
coming weeks but hopefully you'll now

16559
10:26:22,916 --> 10:26:28,360
see the solution so let me go back to uh

16560
10:26:25,320 --> 10:26:29,800
vs code here and let me propose that we

16561
10:26:28,360 --> 10:26:31,400
do the following I'll hide my terminal

16562
10:26:29,800 --> 10:26:33,960
window for a moment and I'm going to

16563
10:26:31,400 --> 10:26:35,200
introduce another header file up here

16564
10:26:33,960 --> 10:26:36,880
and I promise there's not going to be

16565
10:26:35,200 --> 10:26:41,039
too many more of these but this one is

16566
10:26:36,880 --> 10:26:43,200
called standard li. for standard library

16567
10:26:41,040 --> 10:26:45,200
and in this file are the Declarations

16568
10:26:43,200 --> 10:26:47,159
the prototypes for malok and free and a

16569
10:26:45,200 --> 10:26:50,039
bunch of other stuff as well it lets me

16570
10:26:47,160 --> 10:26:52,720
now manage my own memory so let's focus

16571
10:26:50,040 --> 10:26:54,360
now on line 11 line 11 is where I went

16572
10:26:52,720 --> 10:26:56,200
wrong before because conceptually I want

16573
10:26:54,360 --> 10:26:58,916
to copy the whole string but of course

16574
10:26:56,200 --> 10:27:01,115
I'm only copying modestly the individual

16575
10:26:58,916 --> 10:27:03,276
address so how do I copy the whole darn

16576
10:27:01,116 --> 10:27:05,916
thing well what I need to do is this

16577
10:27:03,276 --> 10:27:08,400
when when I declare T to be the address

16578
10:27:05,916 --> 10:27:10,159
of something in memory why don't I set T

16579
10:27:08,400 --> 10:27:11,916
to be the address of a free chunk of

16580
10:27:10,160 --> 10:27:14,000
memory so let me ask the operating

16581
10:27:11,916 --> 10:27:15,115
system give me this many bytes tell me

16582
10:27:14,000 --> 10:27:17,320
what the address is and I'm going to

16583
10:27:15,116 --> 10:27:19,116
store that in t initially just so I know

16584
10:27:17,320 --> 10:27:20,916
where there's free space for me so how

16585
10:27:19,116 --> 10:27:22,880
do I do that well quite simply I call

16586
10:27:20,916 --> 10:27:25,320
malok and then I pass in the number of

16587
10:27:22,880 --> 10:27:27,560
bytes that I need now for Hi exclamation

16588
10:27:25,320 --> 10:27:29,560
point I think I need three although wait

16589
10:27:27,560 --> 10:27:31,360
no I really need four because of the

16590
10:27:29,560 --> 10:27:33,040
null character but I don't think I

16591
10:27:31,360 --> 10:27:34,400
should be hardcoding numbers like this

16592
10:27:33,040 --> 10:27:37,116
cuz who knows what the human's going to

16593
10:27:34,400 --> 10:27:40,560
type in so I can actually use Sterling

16594
10:27:37,116 --> 10:27:43,000
of s and then plus one this will ask

16595
10:27:40,560 --> 10:27:44,560
malok then for however many btes

16596
10:27:43,000 --> 10:27:46,960
corresponds to the number of characters

16597
10:27:44,560 --> 10:27:48,399
the human typed in plus one for again

16598
10:27:46,960 --> 10:27:50,320
the null character so it's just being

16599
10:27:48,400 --> 10:27:54,040
smart and defensive rather than choosing

16600
10:27:50,320 --> 10:27:56,200
a number myself but now all T is is a

16601
10:27:54,040 --> 10:27:58,640
pointer if you will to some random chunk

16602
10:27:56,200 --> 10:28:00,079
of free space so there's nothing there

16603
10:27:58,640 --> 10:28:01,436
yet or there's you know bits there but

16604
10:28:00,080 --> 10:28:02,800
who knows what value they are they're

16605
10:28:01,436 --> 10:28:05,560
certainly not identical to what the

16606
10:28:02,800 --> 10:28:08,596
human type did in I now have to do this

16607
10:28:05,560 --> 10:28:12,435
so how can I copy one string into the

16608
10:28:08,596 --> 10:28:14,040
other well let me do this instead of uh

16609
10:28:12,436 --> 10:28:18,116
capitalizing something just yet let me

16610
10:28:14,040 --> 10:28:20,840
do this how about four in I gets zero I

16611
10:28:18,116 --> 10:28:23,596
is less than the length of

16612
10:28:20,840 --> 10:28:24,840
s uh and then i++ so I'm going to

16613
10:28:23,596 --> 10:28:27,079
iterate for the whole length of the

16614
10:28:24,840 --> 10:28:29,960
string and in here I'm just going to do

16615
10:28:27,080 --> 10:28:32,840
this the E character in t should be

16616
10:28:29,960 --> 10:28:34,320
identical to the E character in s so I'm

16617
10:28:32,840 --> 10:28:37,240
just literally copying from right to

16618
10:28:34,320 --> 10:28:38,880
left each and every character in s and I

16619
10:28:37,240 --> 10:28:40,880
can trust that there's enough memory in

16620
10:28:38,880 --> 10:28:42,880
t why cuz I asked for that many bytes

16621
10:28:40,880 --> 10:28:45,200
plus one now there's technically a bug

16622
10:28:42,880 --> 10:28:49,200
here I actually should probably do this

16623
10:28:45,200 --> 10:28:51,880
I should do plus one here or if you

16624
10:28:49,200 --> 10:28:53,880
prefer I should do less than or equal to

16625
10:28:51,880 --> 10:28:56,360
the Sterling but I think it's a little

16626
10:28:53,880 --> 10:28:58,916
clear to do the plus one why do I for

16627
10:28:56,360 --> 10:29:02,160
the first time want to go just beyond

16628
10:28:58,916 --> 10:29:04,596
the boundary of s and copy one more

16629
10:29:02,160 --> 10:29:06,200
bite yeah yeah I need the null character

16630
10:29:04,596 --> 10:29:08,115
like I could technically manually add it

16631
10:29:06,200 --> 10:29:09,840
with some additional line of code but I

16632
10:29:08,116 --> 10:29:12,720
might as well just copy it because back

16633
10:29:09,840 --> 10:29:14,479
sl0 is back sl0 so this time and

16634
10:29:12,720 --> 10:29:16,276
probably only this time it's reasonable

16635
10:29:14,480 --> 10:29:18,000
and correct to go just beyond the

16636
10:29:16,276 --> 10:29:19,880
boundary of your string so you copy the

16637
10:29:18,000 --> 10:29:22,800
null terminating character so that the

16638
10:29:19,880 --> 10:29:24,799
computer also knows where T ends and now

16639
10:29:22,800 --> 10:29:28,080
I think what I can do a little more

16640
10:29:24,800 --> 10:29:33,520
safely is this let me go down here and

16641
10:29:28,080 --> 10:29:35,880
say t braet 0 equals 2 upper of t uh two

16642
10:29:33,520 --> 10:29:37,359
upper of T bracket Z so same line of

16643
10:29:35,880 --> 10:29:39,200
code as before if I actually want to be

16644
10:29:37,360 --> 10:29:42,400
really safe I should probably do this so

16645
10:29:39,200 --> 10:29:44,320
if the stir L of T is greater than zero

16646
10:29:42,400 --> 10:29:46,680
so there's at least one bite there okay

16647
10:29:44,320 --> 10:29:48,840
now it's safe to blindly capitalize the

16648
10:29:46,680 --> 10:29:50,880
first character and I think that now

16649
10:29:48,840 --> 10:29:53,320
puts me in better shape so let me try

16650
10:29:50,880 --> 10:29:57,596
this now let me uh open up my terminal

16651
10:29:53,320 --> 10:29:59,756
make uh copy do slash copy I'm going to

16652
10:29:57,596 --> 10:30:02,276
type in Hi exclamation point in all

16653
10:29:59,756 --> 10:30:05,000
lowercase crossing my fingers this time

16654
10:30:02,276 --> 10:30:09,115
and now if I zoom in it indeed

16655
10:30:05,000 --> 10:30:11,080
capitalized only T and not s in this

16656
10:30:09,116 --> 10:30:14,640
case so pictorially let me switch over

16657
10:30:11,080 --> 10:30:17,400
here here is as before the variable s

16658
10:30:14,640 --> 10:30:20,400
pointing at high in all lowercase when I

16659
10:30:17,400 --> 10:30:21,720
call malok though that gives me a chunk

16660
10:30:20,400 --> 10:30:24,560
of memory that I'm going to store the

16661
10:30:21,720 --> 10:30:27,000
address in t of so if T is some other

16662
10:30:24,560 --> 10:30:28,640
variable as it is in my code and there's

16663
10:30:27,000 --> 10:30:29,916
some other available chunk of memory I

16664
10:30:28,640 --> 10:30:33,756
don't know where it is but let's assume

16665
10:30:29,916 --> 10:30:36,320
as always it's at Ox 456 4557 4558 N9 so

16666
10:30:33,756 --> 10:30:38,880
four bytes total what is now happening

16667
10:30:36,320 --> 10:30:40,320
well T is defined as pointing to that

16668
10:30:38,880 --> 10:30:42,479
because that's what Malo gives us the

16669
10:30:40,320 --> 10:30:45,200
address of the first bite of the free

16670
10:30:42,480 --> 10:30:47,400
memory and now with my for Loop I'm just

16671
10:30:45,200 --> 10:30:49,360
iterating over it copying the H then the

16672
10:30:47,400 --> 10:30:52,960
I then the exclamation point and then

16673
10:30:49,360 --> 10:30:57,320
for good measure the back slash Zer

16674
10:30:52,960 --> 10:31:00,596
instead questions then on this process

16675
10:30:57,320 --> 10:31:03,880
here a really good question um if I

16676
10:31:00,596 --> 10:31:06,479
omitted in my code the

16677
10:31:03,880 --> 10:31:08,240
uh plus one and I didn't do less than or

16678
10:31:06,480 --> 10:31:10,240
equal to so that I'm copying the fourth

16679
10:31:08,240 --> 10:31:11,880
bite odds are in this program because

16680
10:31:10,240 --> 10:31:14,596
it's so short you wouldn't notice that

16681
10:31:11,880 --> 10:31:18,799
there's an actual error but what could

16682
10:31:14,596 --> 10:31:20,756
happen is When I Call printf On T if

16683
10:31:18,800 --> 10:31:24,400
there's no null bite there it might

16684
10:31:20,756 --> 10:31:25,916
print h i exclamation point some random

16685
10:31:24,400 --> 10:31:27,520
value some random value some random

16686
10:31:25,916 --> 10:31:29,560
value some random value until it gets

16687
10:31:27,520 --> 10:31:32,320
lucky and there happens to be a zero

16688
10:31:29,560 --> 10:31:34,560
bite a null bite by chance for instance

16689
10:31:32,320 --> 10:31:37,040
so if you don't include the back sl0

16690
10:31:34,560 --> 10:31:39,079
some way that's going to happen and I

16691
10:31:37,040 --> 10:31:41,240
say some way I could even do this I

16692
10:31:39,080 --> 10:31:43,400
could technically just copy the length

16693
10:31:41,240 --> 10:31:46,115
of the string s and at the very bottom

16694
10:31:43,400 --> 10:31:49,756
here I could do something like T bracket

16695
10:31:46,116 --> 10:31:53,680
I uh sorry T bracket um

16696
10:31:49,756 --> 10:31:55,240
Sterling of T I could do this but this

16697
10:31:53,680 --> 10:31:57,480
is just not necessary like I could

16698
10:31:55,240 --> 10:31:58,840
manually add it at the end of the string

16699
10:31:57,480 --> 10:32:01,080
but again i' claim that it's just

16700
10:31:58,840 --> 10:32:02,479
simpler to borrow that is copy the one

16701
10:32:01,080 --> 10:32:04,596
that's already in s because it's the

16702
10:32:02,480 --> 10:32:06,916
same thing at the end of the day good

16703
10:32:04,596 --> 10:32:08,439
question other questions on this copying

16704
10:32:06,916 --> 10:32:10,115
correctly

16705
10:32:08,440 --> 10:32:12,276
[Music]

16706
10:32:10,116 --> 10:32:15,240
now all right is there any room for

16707
10:32:12,276 --> 10:32:16,756
improvement here well let me propose a

16708
10:32:15,240 --> 10:32:19,840
slight optimization this is kind of a

16709
10:32:16,756 --> 10:32:22,840
throwback now to week one turns out that

16710
10:32:19,840 --> 10:32:25,240
arguably my line 13 here wherein I have

16711
10:32:22,840 --> 10:32:27,115
this for Loop now that I'm doing things

16712
10:32:25,240 --> 10:32:29,159
in Loops again and again and using a

16713
10:32:27,116 --> 10:32:32,040
function like Sterling this is correct

16714
10:32:29,160 --> 10:32:35,680
it will iterate from zero on up to the

16715
10:32:32,040 --> 10:32:39,360
length of I a length of uh s plus one

16716
10:32:35,680 --> 10:32:41,436
but it's kind of stupid of me to write

16717
10:32:39,360 --> 10:32:43,160
this for Loop in this way why well

16718
10:32:41,436 --> 10:32:45,436
here's my initialization on the left

16719
10:32:43,160 --> 10:32:48,200
here's my condition in the middle and in

16720
10:32:45,436 --> 10:32:51,160
general calling a function inside of

16721
10:32:48,200 --> 10:32:54,000
your condition is probably not very good

16722
10:32:51,160 --> 10:32:56,276
design like why why is it bad for me to

16723
10:32:54,000 --> 10:32:58,200
be calling a function like Sterling in

16724
10:32:56,276 --> 10:33:00,720
this condition in the middle of my for

16725
10:32:58,200 --> 10:33:00,719
Loop

16726
10:33:01,960 --> 10:33:05,840
yeah yeah you're just calling it again

16727
10:33:04,480 --> 10:33:07,560
and again for no reason like the length

16728
10:33:05,840 --> 10:33:08,840
of s never changes so like why are you

16729
10:33:07,560 --> 10:33:11,596
wasting everyone's Time by calling

16730
10:33:08,840 --> 10:33:14,000
Sterling of s again again again again

16731
10:33:11,596 --> 10:33:15,840
just to check this inequality whether I

16732
10:33:14,000 --> 10:33:17,200
is less than that value so it turns out

16733
10:33:15,840 --> 10:33:18,719
if you haven't discovered this already

16734
10:33:17,200 --> 10:33:19,719
there's a slight optimization we can do

16735
10:33:18,720 --> 10:33:22,276
here that has nothing to do

16736
10:33:19,720 --> 10:33:24,436
fundamentally with strings or pointers

16737
10:33:22,276 --> 10:33:26,720
just with better design I can actually

16738
10:33:24,436 --> 10:33:29,360
Define two variables at once I could do

16739
10:33:26,720 --> 10:33:32,436
this let me remove this whole condition

16740
10:33:29,360 --> 10:33:36,320
and let me add a comma after I equals 0

16741
10:33:32,436 --> 10:33:41,116
set n or any variable equal to the stirl

16742
10:33:36,320 --> 10:33:43,320
of s + 1 and then after the semicolon

16743
10:33:41,116 --> 10:33:45,680
just ask the question while I is less

16744
10:33:43,320 --> 10:33:47,756
than n so it's almost the same but

16745
10:33:45,680 --> 10:33:49,596
notice now my condition in the very

16746
10:33:47,756 --> 10:33:52,360
middle of this Loop is at least

16747
10:33:49,596 --> 10:33:54,680
comparing two static values n never

16748
10:33:52,360 --> 10:33:56,680
change sorry one static value n never

16749
10:33:54,680 --> 10:33:58,480
changes all that changes is I but I'm

16750
10:33:56,680 --> 10:34:00,560
not foolishly calling sterling sterling

16751
10:33:58,480 --> 10:34:02,680
sterling again and again why well how

16752
10:34:00,560 --> 10:34:05,720
does Sterling work similar in spirit to

16753
10:34:02,680 --> 10:34:07,840
PR print F Sterling given the name of a

16754
10:34:05,720 --> 10:34:09,596
string looks at the first character and

16755
10:34:07,840 --> 10:34:11,479
then starts looking through the entire

16756
10:34:09,596 --> 10:34:13,799
string looking for the null character

16757
10:34:11,480 --> 10:34:15,360
and we saw this in week two counting up

16758
10:34:13,800 --> 10:34:17,170
how many characters are there so it's

16759
10:34:15,360 --> 10:34:20,239
just a waste of time again and

16760
10:34:17,170 --> 10:34:20,239
[Music]

16761
10:34:22,840 --> 10:34:27,039
again totally if you wanted to use n

16762
10:34:25,400 --> 10:34:28,800
multiple times you could absolutely take

16763
10:34:27,040 --> 10:34:31,276
it out of the for Loop put it right

16764
10:34:28,800 --> 10:34:33,200
after s is defined and reuse n and again

16765
10:34:31,276 --> 10:34:34,960
and again absolutely but in General

16766
10:34:33,200 --> 10:34:37,039
consider this when designing your for

16767
10:34:34,960 --> 10:34:38,916
Loops even though modern compilers like

16768
10:34:37,040 --> 10:34:41,160
cang can actually fix this problem this

16769
10:34:38,916 --> 10:34:43,320
inefficiency for you good practice would

16770
10:34:41,160 --> 10:34:45,436
be don't call functions unnecessarily

16771
10:34:43,320 --> 10:34:48,640
especially if the answer is always going

16772
10:34:45,436 --> 10:34:51,520
to be the same all right so what else

16773
10:34:48,640 --> 10:34:53,640
should I perhaps refine here well how

16774
10:34:51,520 --> 10:34:56,359
about I do one last thing and just

16775
10:34:53,640 --> 10:34:58,880
comment on what exactly could go wrong

16776
10:34:56,360 --> 10:35:00,400
here well a couple of things well

16777
10:34:58,880 --> 10:35:02,276
actually this is just silly too like

16778
10:35:00,400 --> 10:35:04,680
surely someone before me in the world

16779
10:35:02,276 --> 10:35:07,040
has had to copy a string before surely

16780
10:35:04,680 --> 10:35:08,960
there's a function like called stir copy

16781
10:35:07,040 --> 10:35:10,800
maybe like stir compare like stir Ling

16782
10:35:08,960 --> 10:35:12,200
and indeed there is so let me propose

16783
10:35:10,800 --> 10:35:14,000
that we actually get rid of this whole

16784
10:35:12,200 --> 10:35:17,000
for Loop and we actually just call a

16785
10:35:14,000 --> 10:35:19,960
function called stir copy no o just St

16786
10:35:17,000 --> 10:35:22,436
cpy and pass in the destination which is

16787
10:35:19,960 --> 10:35:24,596
T first and then the source that you

16788
10:35:22,436 --> 10:35:27,080
want to copy into the destination and

16789
10:35:24,596 --> 10:35:29,200
that takes the place entirely of that

16790
10:35:27,080 --> 10:35:30,640
whole Loop so again I demonstrated the

16791
10:35:29,200 --> 10:35:32,240
loop first just to be very pedantic

16792
10:35:30,640 --> 10:35:33,520
about it but that's wasting time you're

16793
10:35:32,240 --> 10:35:36,040
wasting time writing lines of code you

16794
10:35:33,520 --> 10:35:38,960
don't need to stir copy is what you can

16795
10:35:36,040 --> 10:35:41,000
use here instead and so this has now

16796
10:35:38,960 --> 10:35:43,640
always existed and what more can I do

16797
10:35:41,000 --> 10:35:45,116
well as one final point it turns out

16798
10:35:43,640 --> 10:35:47,520
that there's actually things that can go

16799
10:35:45,116 --> 10:35:49,240
wrong in this code even besides the

16800
10:35:47,520 --> 10:35:50,560
string being too short like if the human

16801
10:35:49,240 --> 10:35:51,840
Just Hits enter and there are no

16802
10:35:50,560 --> 10:35:53,115
characters I don't want to blindly

16803
10:35:51,840 --> 10:35:55,320
capitalize the first character that

16804
10:35:53,116 --> 10:35:57,040
doesn't exist that's why I added that if

16805
10:35:55,320 --> 10:35:58,800
condition but there's other things that

16806
10:35:57,040 --> 10:36:01,560
can go wrong and we introduced those to

16807
10:35:58,800 --> 10:36:05,800
you today it turns out that functions

16808
10:36:01,560 --> 10:36:08,520
like get string and functions like Malo

16809
10:36:05,800 --> 10:36:10,436
return potentially a special value and

16810
10:36:08,520 --> 10:36:13,039
wonderfully confusingly it's also called

16811
10:36:10,436 --> 10:36:14,320
null but with two L's all right so left

16812
10:36:13,040 --> 10:36:18,040
hand and right hand weren't talking so

16813
10:36:14,320 --> 10:36:20,520
well like decades ago NL is a back SL

16814
10:36:18,040 --> 10:36:22,480
zero it's a single character as it

16815
10:36:20,520 --> 10:36:23,560
always has been for a couple of weeks

16816
10:36:22,480 --> 10:36:26,276
now

16817
10:36:23,560 --> 10:36:28,960
n is technically a pointer it's an

16818
10:36:26,276 --> 10:36:31,436
address but it's address zero it's like

16819
10:36:28,960 --> 10:36:33,276
the top left hand corner if you will of

16820
10:36:31,436 --> 10:36:35,480
your computer's memory that just nothing

16821
10:36:33,276 --> 10:36:39,115
is ever supposed to go in by convention

16822
10:36:35,480 --> 10:36:40,840
so null is a synonym for zero but it's

16823
10:36:39,116 --> 10:36:43,520
specifically an address now why is this

16824
10:36:40,840 --> 10:36:44,840
useful well suppose that in my code here

16825
10:36:43,520 --> 10:36:45,916
something goes wrong with get string

16826
10:36:44,840 --> 10:36:47,640
suppose you're being a little crazy and

16827
10:36:45,916 --> 10:36:49,115
you type in way too long of a string

16828
10:36:47,640 --> 10:36:50,840
it's not just high but it's like an

16829
10:36:49,116 --> 10:36:52,520
entire essay of text and there's not

16830
10:36:50,840 --> 10:36:55,115
enough memory in the computer how does

16831
10:36:52,520 --> 10:36:56,880
get string signal to the programmer whoa

16832
10:36:55,116 --> 10:36:58,960
like that's way too big of a string I

16833
10:36:56,880 --> 10:37:01,560
can't fit it in memory well we never

16834
10:36:58,960 --> 10:37:04,200
told you this but all of this time it

16835
10:37:01,560 --> 10:37:06,360
turns out that that get string will

16836
10:37:04,200 --> 10:37:09,000
return this special value called null if

16837
10:37:06,360 --> 10:37:10,596
something goes wrong so to be really

16838
10:37:09,000 --> 10:37:14,400
careful now you should do something like

16839
10:37:10,596 --> 10:37:16,640
this if s equals equals literally null

16840
10:37:14,400 --> 10:37:18,640
then you better um exit the program

16841
10:37:16,640 --> 10:37:20,080
entirely and return like one or two or

16842
10:37:18,640 --> 10:37:23,040
three to signify that something went

16843
10:37:20,080 --> 10:37:25,116
wrong don't uh go any further similarly

16844
10:37:23,040 --> 10:37:26,596
with malok it's possible if you ask for

16845
10:37:25,116 --> 10:37:27,680
way too much memory that could fail

16846
10:37:26,596 --> 10:37:29,479
especially if you're asking now for

16847
10:37:27,680 --> 10:37:32,040
double the memory after the human typed

16848
10:37:29,480 --> 10:37:33,596
something in so if T equals equals null

16849
10:37:32,040 --> 10:37:35,680
then you know what but let's also return

16850
10:37:33,596 --> 10:37:37,960
one or some other value to just get out

16851
10:37:35,680 --> 10:37:40,160
before something crashes or freezes on

16852
10:37:37,960 --> 10:37:41,916
the human as well so honestly I tend not

16853
10:37:40,160 --> 10:37:43,240
to do this always in class because the

16854
10:37:41,916 --> 10:37:44,680
code just gets so bloated and

16855
10:37:43,240 --> 10:37:46,680
complicated but you absolutely in

16856
10:37:44,680 --> 10:37:48,680
practice need to start doing this

16857
10:37:46,680 --> 10:37:50,116
otherwise you will be responsible for

16858
10:37:48,680 --> 10:37:52,276
the freezes and the crashes and the

16859
10:37:50,116 --> 10:37:54,520
reboots that users in the real world

16860
10:37:52,276 --> 10:37:55,916
might actually encounter otherwise of

16861
10:37:54,520 --> 10:37:58,276
course if we get to the bottom of this

16862
10:37:55,916 --> 10:38:00,880
program now I should probably return

16863
10:37:58,276 --> 10:38:03,240
zero explicitly or implicitly to just

16864
10:38:00,880 --> 10:38:05,320
signify that everything is is

16865
10:38:03,240 --> 10:38:07,960
successful but there's one other thing I

16866
10:38:05,320 --> 10:38:09,480
haven't done we introduced malok but

16867
10:38:07,960 --> 10:38:12,080
what did I claim also

16868
10:38:09,480 --> 10:38:14,040
existed so free I'm also being a little

16869
10:38:12,080 --> 10:38:15,436
reckless now here I am not practicing

16870
10:38:14,040 --> 10:38:17,436
what I'm preaching I'm asking the

16871
10:38:15,436 --> 10:38:19,080
computer for memory via get string I'm

16872
10:38:17,436 --> 10:38:21,000
asking the computer for more memory my

16873
10:38:19,080 --> 10:38:23,360
via malok and I'm never technically

16874
10:38:21,000 --> 10:38:25,200
handing it back so really what I should

16875
10:38:23,360 --> 10:38:29,360
be doing at the very bottom of my

16876
10:38:25,200 --> 10:38:32,000
program to is freeing the memory I've

16877
10:38:29,360 --> 10:38:34,360
asked for so henceforth it is a rule a

16878
10:38:32,000 --> 10:38:36,640
law if you will in see whenever you

16879
10:38:34,360 --> 10:38:38,880
allocate memory with malok or certain

16880
10:38:36,640 --> 10:38:40,640
other functions as well you the

16881
10:38:38,880 --> 10:38:42,960
programmer must free it when you're all

16882
10:38:40,640 --> 10:38:44,360
done with it now this is a bit of an

16883
10:38:42,960 --> 10:38:46,116
overstatement because technically when

16884
10:38:44,360 --> 10:38:47,240
programs quit they'll free the memory

16885
10:38:46,116 --> 10:38:48,880
automatically so you're not going to

16886
10:38:47,240 --> 10:38:50,320
break someone's Mac or PC because you

16887
10:38:48,880 --> 10:38:51,680
necessarily have this bug but for

16888
10:38:50,320 --> 10:38:53,159
programs that are running all the time

16889
10:38:51,680 --> 10:38:55,360
like someone keeps a chrome their

16890
10:38:53,160 --> 10:38:57,200
browser open Microsoft Word or the like

16891
10:38:55,360 --> 10:38:59,200
bad things will happen if over time you

16892
10:38:57,200 --> 10:39:01,200
never never never call free and the

16893
10:38:59,200 --> 10:39:03,276
program keeps running so always get into

16894
10:39:01,200 --> 10:39:05,680
this habit here you you do not need to

16895
10:39:03,276 --> 10:39:07,596
free memory that comes from get string

16896
10:39:05,680 --> 10:39:09,916
because the cs50 library automatically

16897
10:39:07,596 --> 10:39:12,320
frees it for you but you anytime you use

16898
10:39:09,916 --> 10:39:15,115
malok henceforth as you did or I did

16899
10:39:12,320 --> 10:39:18,159
here you must free that by just passing

16900
10:39:15,116 --> 10:39:22,800
in the same address you got back

16901
10:39:18,160 --> 10:39:27,240
questions now on malok and

16902
10:39:22,800 --> 10:39:27,240
free questions

16903
10:39:31,116 --> 10:39:37,640
yeah oh really good question so free

16904
10:39:34,680 --> 10:39:40,116
just so what does free do so free um

16905
10:39:37,640 --> 10:39:41,640
just uh lets the computer know that you

16906
10:39:40,116 --> 10:39:43,240
are done with that chunk of memory which

16907
10:39:41,640 --> 10:39:45,520
means that if you have a another line of

16908
10:39:43,240 --> 10:39:47,880
code elsewhere that same memory might be

16909
10:39:45,520 --> 10:39:48,719
reused and can be used again and again

16910
10:39:47,880 --> 10:39:50,079
and that's going to be necessary

16911
10:39:48,720 --> 10:39:51,800
certainly for any long running program

16912
10:39:50,080 --> 10:39:53,200
you can't ask for memory constantly

16913
10:39:51,800 --> 10:39:55,160
you'll eventually run out so you need to

16914
10:39:53,200 --> 10:39:56,435
free it in this way other languages as

16915
10:39:55,160 --> 10:39:57,800
an aside python you get another

16916
10:39:56,436 --> 10:39:59,400
motivation in a couple of weeks for it

16917
10:39:57,800 --> 10:40:01,400
is going to be Python and certain other

16918
10:39:59,400 --> 10:40:03,520
languages manage all this headache for

16919
10:40:01,400 --> 10:40:06,880
you but in C the goal here is to really

16920
10:40:03,520 --> 10:40:08,596
harness these capabilities ourselves all

16921
10:40:06,880 --> 10:40:09,755
right so it turns out like almost

16922
10:40:08,596 --> 10:40:10,916
everyone in the room everyone in the

16923
10:40:09,756 --> 10:40:12,276
room myself included you're going to

16924
10:40:10,916 --> 10:40:13,960
screw up when it comes to anything

16925
10:40:12,276 --> 10:40:16,200
memory related if you haven't already

16926
10:40:13,960 --> 10:40:17,880
segals are in your future but hopefully

16927
10:40:16,200 --> 10:40:19,960
there's tools via which you can detect

16928
10:40:17,880 --> 10:40:22,320
these things and fix them proactively

16929
10:40:19,960 --> 10:40:24,360
and not just use print def uh or debug

16930
10:40:22,320 --> 10:40:26,400
50 or rubber duck we actually have

16931
10:40:24,360 --> 10:40:28,276
another tool we can equip you with now

16932
10:40:26,400 --> 10:40:31,116
that help you find some mistakes so let

16933
10:40:28,276 --> 10:40:32,799
me do this let me close copy.c let me

16934
10:40:31,116 --> 10:40:34,960
open a program I wrote In Advance called

16935
10:40:32,800 --> 10:40:36,640
memory. C that doesn't do anything

16936
10:40:34,960 --> 10:40:38,680
really interesting but it's going to

16937
10:40:36,640 --> 10:40:41,320
have two bugs in it notice that I've

16938
10:40:38,680 --> 10:40:43,436
included standard i.h as always I've

16939
10:40:41,320 --> 10:40:45,200
also included standard li. which is

16940
10:40:43,436 --> 10:40:48,880
necessary now for anything related to

16941
10:40:45,200 --> 10:40:50,680
malok Andor free and the like line six

16942
10:40:48,880 --> 10:40:53,240
it's a little weird what I've done here

16943
10:40:50,680 --> 10:40:56,480
but this is like the manual way of

16944
10:40:53,240 --> 10:40:59,040
asking for enough memory for an array in

16945
10:40:56,480 --> 10:41:03,520
week two how do we ask for memory for an

16946
10:40:59,040 --> 10:41:05,560
array you very simply say int X3 and

16947
10:41:03,520 --> 10:41:07,596
that gives you an array called X of size

16948
10:41:05,560 --> 10:41:10,596
three but if you do it manually Now

16949
10:41:07,596 --> 10:41:13,320
using Malo what you have to do is use

16950
10:41:10,596 --> 10:41:15,680
syntax like this you call malok you ask

16951
10:41:13,320 --> 10:41:17,159
for three things times however big an

16952
10:41:15,680 --> 10:41:19,200
INT is now we know it's four so you

16953
10:41:17,160 --> 10:41:21,276
could literally write 12 here but this

16954
10:41:19,200 --> 10:41:23,000
is more generic so three times the size

16955
10:41:21,276 --> 10:41:25,360
of an integer will give you 12

16956
10:41:23,000 --> 10:41:28,480
dynamically and what do Malo return the

16957
10:41:25,360 --> 10:41:30,116
address of the first bite you get back

16958
10:41:28,480 --> 10:41:32,240
what do I want to put that well I want

16959
10:41:30,116 --> 10:41:34,000
to put it in a variable now the variable

16960
10:41:32,240 --> 10:41:36,560
can't just be int X because that's a

16961
10:41:34,000 --> 10:41:38,680
number it's not an address per se if I

16962
10:41:36,560 --> 10:41:40,799
want to store this address in a variable

16963
10:41:38,680 --> 10:41:43,320
I could call it X I could call it P but

16964
10:41:40,800 --> 10:41:45,320
in Star X just means that X is now the

16965
10:41:43,320 --> 10:41:46,640
address of a chunk of memory

16966
10:41:45,320 --> 10:41:49,480
specifically a chunk of memory that's

16967
10:41:46,640 --> 10:41:52,680
big enough not for one but for three ins

16968
10:41:49,480 --> 10:41:55,360
in total all right now I'm just sort of

16969
10:41:52,680 --> 10:41:57,480
naively putting our old friends 72 73

16970
10:41:55,360 --> 10:42:00,040
and 33 at the first second and third

16971
10:41:57,480 --> 10:42:01,680
locations in memory but perhaps based on

16972
10:42:00,040 --> 10:42:03,520
week two or week four I'm clearly

16973
10:42:01,680 --> 10:42:05,160
screwing up up here in a couple of ways

16974
10:42:03,520 --> 10:42:08,276
someone want to identify at least one

16975
10:42:05,160 --> 10:42:10,916
bug what did I do

16976
10:42:08,276 --> 10:42:13,159
wrong yeah like this is now you know

16977
10:42:10,916 --> 10:42:15,200
amateur uh stuff like I should be zero

16978
10:42:13,160 --> 10:42:17,680
indexing not one indexing so this has

16979
10:42:15,200 --> 10:42:21,240
got to be 0 one2 ultimately and other

16980
10:42:17,680 --> 10:42:24,320
bugs that are maybe more week four

16981
10:42:21,240 --> 10:42:26,479
specific other bugs it's more subtle

16982
10:42:24,320 --> 10:42:28,080
yeah I'm not freeing the memory right so

16983
10:42:26,480 --> 10:42:29,680
I'm not practicing what I'm preaching by

16984
10:42:28,080 --> 10:42:31,240
freeing this memory now suppose these

16985
10:42:29,680 --> 10:42:32,480
are non obvious and honestly after like

16986
10:42:31,240 --> 10:42:34,840
an hour or two of this like this

16987
10:42:32,480 --> 10:42:38,720
shouldn't be obvious yet it will be over

16988
10:42:34,840 --> 10:42:40,679
time how could I find these bugs with uh

16989
10:42:38,720 --> 10:42:42,560
software as opposed to just staring at

16990
10:42:40,680 --> 10:42:44,640
the thing or asking someone for help

16991
10:42:42,560 --> 10:42:46,916
well let me propose this let me first go

16992
10:42:44,640 --> 10:42:49,960
ahead and run make memory to compile the

16993
10:42:46,916 --> 10:42:51,880
program and it seems to work look fine

16994
10:42:49,960 --> 10:42:55,080
there's no syntax errors at least

16995
10:42:51,880 --> 10:42:56,320
dotmemory notice seems to work fine too

16996
10:42:55,080 --> 10:42:57,680
now this program doesn't do anything

16997
10:42:56,320 --> 10:42:59,596
interesting there's no printf or

16998
10:42:57,680 --> 10:43:01,596
anything like that but it didn't crash

16999
10:42:59,596 --> 10:43:04,115
there's no segmentation fault but that

17000
10:43:01,596 --> 10:43:06,560
doesn't mean there aren't bugs latent in

17001
10:43:04,116 --> 10:43:08,720
the software and this is true sadly of

17002
10:43:06,560 --> 10:43:11,200
all of today's software like Chrome and

17003
10:43:08,720 --> 10:43:13,160
Microsoft Word and other programs surely

17004
10:43:11,200 --> 10:43:15,115
have memory related bugs that people at

17005
10:43:13,160 --> 10:43:16,680
Google and Microsoft haven't yet found

17006
10:43:15,116 --> 10:43:18,596
but there are tools at least to find the

17007
10:43:16,680 --> 10:43:20,240
most obvious of those bugs and we're

17008
10:43:18,596 --> 10:43:23,040
going to introduce you now to a program

17009
10:43:20,240 --> 10:43:24,840
called valren so valren it's a fairly

17010
10:43:23,040 --> 10:43:27,320
fancy program but we'll use it for very

17011
10:43:24,840 --> 10:43:29,960
simple ways we'll look at your code and

17012
10:43:27,320 --> 10:43:31,480
find memory errors as it's executing and

17013
10:43:29,960 --> 10:43:34,240
try to help you understand where they

17014
10:43:31,480 --> 10:43:36,040
are so let me go back to vs code here

17015
10:43:34,240 --> 10:43:37,115
memory seems to be fine you know I feel

17016
10:43:36,040 --> 10:43:39,160
like okay I'm going to submit this

17017
10:43:37,116 --> 10:43:40,916
homework all is good no error messages

17018
10:43:39,160 --> 10:43:42,720
that's no longer the case now you need

17019
10:43:40,916 --> 10:43:44,240
to poke a little more at your code to

17020
10:43:42,720 --> 10:43:46,320
see if maybe there's still some bug

17021
10:43:44,240 --> 10:43:49,640
there so let me do this

17022
10:43:46,320 --> 10:43:51,436
valren and then space dotmemory so just

17023
10:43:49,640 --> 10:43:53,436
like debug 50 you run it on a program

17024
10:43:51,436 --> 10:43:55,520
you already compiled valren I'm going to

17025
10:43:53,436 --> 10:43:57,320
run it on a program I already compiled

17026
10:43:55,520 --> 10:44:00,240
let me uh zoom in on my terminal window

17027
10:43:57,320 --> 10:44:02,680
so we can see more at once and enter all

17028
10:44:00,240 --> 10:44:04,159
right the output is crazy cryp IC for no

17029
10:44:02,680 --> 10:44:06,436
good reason there's lots of numbers and

17030
10:44:04,160 --> 10:44:08,160
equal signs it's a lot of clutter but

17031
10:44:06,436 --> 10:44:10,916
there is some juicy information here and

17032
10:44:08,160 --> 10:44:13,240
let me start from the top down invalid

17033
10:44:10,916 --> 10:44:15,640
write of size four so write means to

17034
10:44:13,240 --> 10:44:18,240
change a value read means to like access

17035
10:44:15,640 --> 10:44:20,596
a value and this is again esoteric like

17036
10:44:18,240 --> 10:44:24,400
a lot of our error messages are but it

17037
10:44:20,596 --> 10:44:26,276
looks like uh after a block of size 12

17038
10:44:24,400 --> 10:44:28,520
allock and then there's these weird hex

17039
10:44:26,276 --> 10:44:30,200
notation there's some mention of malok

17040
10:44:28,520 --> 10:44:32,755
but honestly the juicy part here is

17041
10:44:30,200 --> 10:44:34,916
memory. C line six that's probably my

17042
10:44:32,756 --> 10:44:37,040
fault so let's look at line six per that

17043
10:44:34,916 --> 10:44:39,960
output let me shrink the terminal window

17044
10:44:37,040 --> 10:44:41,320
look at line six okay 12 is now Germain

17045
10:44:39,960 --> 10:44:43,680
right if you did the mental math of the

17046
10:44:41,320 --> 10:44:48,116
size of an INT times three 12 is somehow

17047
10:44:43,680 --> 10:44:50,640
involved here but line six is now uh

17048
10:44:48,116 --> 10:44:52,520
happening next year that's where the

17049
10:44:50,640 --> 10:44:56,520
memory came from what is this let me

17050
10:44:52,520 --> 10:44:59,916
Zoom back in where is there invalid

17051
10:44:56,520 --> 10:45:03,359
right of size four like what's perhaps

17052
10:44:59,916 --> 10:45:05,276
going wrong here invalid right of size

17053
10:45:03,360 --> 10:45:08,080
four what does that mean it's like a

17054
10:45:05,276 --> 10:45:10,079
very technical way of explaining the bug

17055
10:45:08,080 --> 10:45:11,840
is actually one line later on line seven

17056
10:45:10,080 --> 10:45:14,160
as we already identified

17057
10:45:11,840 --> 10:45:15,840
yeah indeed and I I misspoke a moment

17058
10:45:14,160 --> 10:45:17,520
ago the bug actually arises here with

17059
10:45:15,840 --> 10:45:20,039
line nine so after the allocation of

17060
10:45:17,520 --> 10:45:21,680
memory I'm somehow writing four bytes

17061
10:45:20,040 --> 10:45:23,240
incorrectly and unfortunately the onus

17062
10:45:21,680 --> 10:45:24,916
is kind of on you to sort of think

17063
10:45:23,240 --> 10:45:27,200
through deductively like what could that

17064
10:45:24,916 --> 10:45:28,880
mean but I'm clearly touching four bytes

17065
10:45:27,200 --> 10:45:30,479
of memory in these few lines of code

17066
10:45:28,880 --> 10:45:32,399
that I shouldn't be and hopefully here

17067
10:45:30,480 --> 10:45:34,720
is the light bulb already went off ear

17068
10:45:32,400 --> 10:45:36,880
oh I'm not zero indexing okay that must

17069
10:45:34,720 --> 10:45:39,240
mean that X bracket 3 as you note is

17070
10:45:36,880 --> 10:45:41,880
just too far past the chunk of memory so

17071
10:45:39,240 --> 10:45:43,756
I'm invalidly writing to four bytes that

17072
10:45:41,880 --> 10:45:45,479
I shouldn't be so again it's not super

17073
10:45:43,756 --> 10:45:48,080
obvious this is not super userfriendly

17074
10:45:45,480 --> 10:45:50,360
but at least it does give you a clue as

17075
10:45:48,080 --> 10:45:52,320
to where that bug is so the fix there is

17076
10:45:50,360 --> 10:45:54,960
going to be quite simply to change the

17077
10:45:52,320 --> 10:45:57,000
one to a zero the two to a one and the

17078
10:45:54,960 --> 10:45:58,360
three to a two that'll fix that but

17079
10:45:57,000 --> 10:46:00,520
there's still a second error and let me

17080
10:45:58,360 --> 10:46:02,596
look at the cryptic output again Heap

17081
10:46:00,520 --> 10:46:05,755
summary some stuff there okay this does

17082
10:46:02,596 --> 10:46:07,720
not sound good down here 12 bytes in one

17083
10:46:05,756 --> 10:46:10,520
blocks are definitely lost in Lost

17084
10:46:07,720 --> 10:46:12,320
record one of one very Arcane output two

17085
10:46:10,520 --> 10:46:14,719
but clearly related to line six again

17086
10:46:12,320 --> 10:46:16,276
our allocation of memory now here too

17087
10:46:14,720 --> 10:46:19,276
it's not obvious what the solution is

17088
10:46:16,276 --> 10:46:21,680
but memory is lost AKA this is a memory

17089
10:46:19,276 --> 10:46:24,436
leak and now the deductions kind of up

17090
10:46:21,680 --> 10:46:26,916
to you why what is leak oh wait I didn't

17091
10:46:24,436 --> 10:46:29,276
call free and so the second solution

17092
10:46:26,916 --> 10:46:31,115
here is probably to free x at the very

17093
10:46:29,276 --> 10:46:32,916
end of the program and if you really

17094
10:46:31,116 --> 10:46:35,360
want to be you should probably check

17095
10:46:32,916 --> 10:46:37,755
like I proposed earlier if x is null

17096
10:46:35,360 --> 10:46:39,200
just get out now while you still can and

17097
10:46:37,756 --> 10:46:40,800
don't even touch those other lines of

17098
10:46:39,200 --> 10:46:43,520
code but if you get to the bottom return

17099
10:46:40,800 --> 10:46:45,400
zero but really the takeaways are I

17100
10:46:43,520 --> 10:46:48,399
fixed my zero indexing of the array to

17101
10:46:45,400 --> 10:46:50,040
avoid the invalid right of size four and

17102
10:46:48,400 --> 10:46:52,116
now I'm freeing the memory that I asked

17103
10:46:50,040 --> 10:46:54,560
for so there should be no leak lost all

17104
10:46:52,116 --> 10:46:57,560
right let's try this again make

17105
10:46:54,560 --> 10:46:59,200
memorymemory no visible errors yet but

17106
10:46:57,560 --> 10:47:02,320
let me now increase my terminal window

17107
10:46:59,200 --> 10:47:05,719
again do valren of dotmemory crossing my

17108
10:47:02,320 --> 10:47:07,960
fingers and now all Heap blocks were

17109
10:47:05,720 --> 10:47:09,400
freed no leaks are possible I don't see

17110
10:47:07,960 --> 10:47:10,720
any invalid rights there's still a crazy

17111
10:47:09,400 --> 10:47:13,276
amount of output but none of it is

17112
10:47:10,720 --> 10:47:15,520
erroneous it's not bad now I fixed my

17113
10:47:13,276 --> 10:47:16,880
memory bugs and so now my my ta my TF

17114
10:47:15,520 --> 10:47:18,479
they're not going to find them either

17115
10:47:16,880 --> 10:47:21,840
because at least valr has proactively

17116
10:47:18,480 --> 10:47:24,000
done that for me questions then on

17117
10:47:21,840 --> 10:47:25,359
valgren generally it's those two types

17118
10:47:24,000 --> 10:47:27,840
of Errors you might trip over there's

17119
10:47:25,360 --> 10:47:30,640
not twoo much else in the way of Arcane

17120
10:47:27,840 --> 10:47:33,880
output questions then on

17121
10:47:30,640 --> 10:47:35,596
this no all right well what else might

17122
10:47:33,880 --> 10:47:38,719
be going on so someone alluded to this

17123
10:47:35,596 --> 10:47:40,880
earlier what happens when you for

17124
10:47:38,720 --> 10:47:42,680
instance forget the null Terminator or

17125
10:47:40,880 --> 10:47:45,596
you generally start poking around memory

17126
10:47:42,680 --> 10:47:47,360
that you yourself didn't ask for or uh

17127
10:47:45,596 --> 10:47:49,240
looking at values you didn't put there

17128
10:47:47,360 --> 10:47:51,916
well let me go ahead and open this code

17129
10:47:49,240 --> 10:47:54,000
of garbage. C in honor of Oscar the

17130
10:47:51,916 --> 10:47:56,115
Grouch here of sorts and here is a

17131
10:47:54,000 --> 10:47:57,520
simple program if I hide my terminal

17132
10:47:56,116 --> 10:48:00,480
window that just does something kind of

17133
10:47:57,520 --> 10:48:03,079
arbitrary I first declare an array uh

17134
10:48:00,480 --> 10:48:05,916
called scores uh but I made it crazy big

17135
10:48:03,080 --> 10:48:08,240
like 1024 like that's a lot of uh

17136
10:48:05,916 --> 10:48:10,435
integers but so be it and then I iterate

17137
10:48:08,240 --> 10:48:12,240
over those integers and I print each of

17138
10:48:10,436 --> 10:48:14,680
those scores out so I'm using week two

17139
10:48:12,240 --> 10:48:16,479
syntax here but based on this program

17140
10:48:14,680 --> 10:48:19,240
what have I clearly not done that I did

17141
10:48:16,480 --> 10:48:22,800
do back in week two I've allocated the

17142
10:48:19,240 --> 10:48:25,720
array I'm printing the array but but

17143
10:48:22,800 --> 10:48:27,200
Bute yeah I didn't initialize any values

17144
10:48:25,720 --> 10:48:28,916
for that array back in week two we

17145
10:48:27,200 --> 10:48:30,435
didn't do 1024 we did like three and I

17146
10:48:28,916 --> 10:48:31,880
typed in like three test scores or

17147
10:48:30,436 --> 10:48:33,560
something like that he here I'm

17148
10:48:31,880 --> 10:48:34,520
allocating memory even more than that

17149
10:48:33,560 --> 10:48:36,320
just because I really want to be

17150
10:48:34,520 --> 10:48:38,039
dramatic with what I'm demonstrating but

17151
10:48:36,320 --> 10:48:41,000
I'm not initializing those values to

17152
10:48:38,040 --> 10:48:43,040
anything and so here it turns out in C

17153
10:48:41,000 --> 10:48:44,800
generally if you do not initialize a

17154
10:48:43,040 --> 10:48:46,800
variable or you do not initialize an

17155
10:48:44,800 --> 10:48:48,840
array with explicit values there are

17156
10:48:46,800 --> 10:48:51,000
going to be garbage values there so to

17157
10:48:48,840 --> 10:48:53,679
speak remnants of that memory having

17158
10:48:51,000 --> 10:48:55,560
been used before probably by some other

17159
10:48:53,680 --> 10:48:57,240
function of yours some Library function

17160
10:48:55,560 --> 10:48:59,115
or something else while your program is

17161
10:48:57,240 --> 10:49:01,000
running not a huge deal with a super

17162
10:48:59,116 --> 10:49:03,160
small program like this but for anything

17163
10:49:01,000 --> 10:49:04,720
sizable memory is going to be used and

17164
10:49:03,160 --> 10:49:06,680
unused and used and unused that is

17165
10:49:04,720 --> 10:49:08,480
macked and freed again and again there's

17166
10:49:06,680 --> 10:49:11,040
going to be lots of garbage values in

17167
10:49:08,480 --> 10:49:13,436
the computer's memory by default so if I

17168
10:49:11,040 --> 10:49:16,400
open my terminal window here uh let me

17169
10:49:13,436 --> 10:49:18,560
do make garbage uh let me zoom in on my

17170
10:49:16,400 --> 10:49:21,680
terminal so we can see the output when I

17171
10:49:18,560 --> 10:49:24,399
runt garbage theoretically I should see

17172
10:49:21,680 --> 10:49:26,116
1,24 integers but none of which have

17173
10:49:24,400 --> 10:49:27,756
been initialized now I'm going to get

17174
10:49:26,116 --> 10:49:29,276
lucky with some of them and it looks

17175
10:49:27,756 --> 10:49:31,640
like wow okay a lot of them are

17176
10:49:29,276 --> 10:49:33,320
initialized to zero and C does in some

17177
10:49:31,640 --> 10:49:35,240
context initialize memory for you to

17178
10:49:33,320 --> 10:49:37,640
zero at least at the beginning but not

17179
10:49:35,240 --> 10:49:39,276
again and again typically but if I start

17180
10:49:37,640 --> 10:49:41,159
scrolling backwards in time at this

17181
10:49:39,276 --> 10:49:45,040
array of size

17182
10:49:41,160 --> 10:49:47,080
1024 where did these values come from so

17183
10:49:45,040 --> 10:49:48,880
just random positive and negative

17184
10:49:47,080 --> 10:49:50,320
numbers interspersed among the zeros

17185
10:49:48,880 --> 10:49:53,320
well that's because I'm literally poking

17186
10:49:50,320 --> 10:49:55,480
around a random 1,24 bytes of the

17187
10:49:53,320 --> 10:49:57,000
computer's memory who knows what's there

17188
10:49:55,480 --> 10:49:58,840
so the lesson here is that garbage

17189
10:49:57,000 --> 10:50:01,160
values are indeed this like term of art

17190
10:49:58,840 --> 10:50:03,435
it means that a variable that you might

17191
10:50:01,160 --> 10:50:04,840
have uh defined that you might have

17192
10:50:03,436 --> 10:50:07,200
declared if you don't give it an

17193
10:50:04,840 --> 10:50:08,596
explicit value who knows what's going to

17194
10:50:07,200 --> 10:50:10,399
be there and the lesson here is just

17195
10:50:08,596 --> 10:50:13,000
don't do that always initialize

17196
10:50:10,400 --> 10:50:15,040
variables to something either yourself

17197
10:50:13,000 --> 10:50:18,560
or prompting the human for

17198
10:50:15,040 --> 10:50:20,880
it questions about garbage

17199
10:50:18,560 --> 10:50:22,560
values you'll see them sometimes if you

17200
10:50:20,880 --> 10:50:24,755
print things you shouldn't or touch

17201
10:50:22,560 --> 10:50:26,680
arrays beyond their

17202
10:50:24,756 --> 10:50:28,360
boundaries all right so maybe to make

17203
10:50:26,680 --> 10:50:29,840
this a little visual too it turns out

17204
10:50:28,360 --> 10:50:31,160
that a lot of things can go wrong

17205
10:50:29,840 --> 10:50:32,799
unfortunately with poers and we've seen

17206
10:50:31,160 --> 10:50:34,116
some of them and here's another program

17207
10:50:32,800 --> 10:50:37,240
that's a little contrived it's very

17208
10:50:34,116 --> 10:50:38,840
simple and it just is about manipulating

17209
10:50:37,240 --> 10:50:40,400
values it doesn't do anything useful per

17210
10:50:38,840 --> 10:50:42,719
se except demonstrate some of today's

17211
10:50:40,400 --> 10:50:44,680
Concepts so in main here let me propose

17212
10:50:42,720 --> 10:50:45,840
that we declare a pointer called X

17213
10:50:44,680 --> 10:50:47,880
that's going to store eventually the

17214
10:50:45,840 --> 10:50:49,039
address of an integer apparently here's

17215
10:50:47,880 --> 10:50:51,200
another one called y that's going to

17216
10:50:49,040 --> 10:50:53,840
store the address of an integer as well

17217
10:50:51,200 --> 10:50:55,680
here now I'm allocating enough memory to

17218
10:50:53,840 --> 10:50:57,799
fit one integer now technically it's

17219
10:50:55,680 --> 10:51:00,360
four we know that but size of in just

17220
10:50:57,800 --> 10:51:01,880
gives me that answer dynamically so it

17221
10:51:00,360 --> 10:51:03,480
will work on all systems

17222
10:51:01,880 --> 10:51:08,399
and I'm going to store the address that

17223
10:51:03,480 --> 10:51:11,040
Malo finds for me in X then I go to x

17224
10:51:08,400 --> 10:51:13,520
and put the number 42 there all right

17225
10:51:11,040 --> 10:51:15,800
why it's the sort of meaning of life the

17226
10:51:13,520 --> 10:51:18,079
universe and everything here but star X

17227
10:51:15,800 --> 10:51:20,200
again just means go to that address and

17228
10:51:18,080 --> 10:51:22,720
put a value there so why I don't know

17229
10:51:20,200 --> 10:51:25,755
but it's just uh correct at this point

17230
10:51:22,720 --> 10:51:28,640
but what about this line here star y

17231
10:51:25,756 --> 10:51:31,596
equals 13 unlucky in this case what's

17232
10:51:28,640 --> 10:51:33,040
bad about this line here star y It's a

17233
10:51:31,596 --> 10:51:35,680
combination now of today's Primitives

17234
10:51:33,040 --> 10:51:37,800
and that point here

17235
10:51:35,680 --> 10:51:39,916
yeah yeah we didn't ask the computer to

17236
10:51:37,800 --> 10:51:41,756
allocate any space so why was not

17237
10:51:39,916 --> 10:51:43,640
initialized with an equal sign at any

17238
10:51:41,756 --> 10:51:46,520
point to anything and so what is inside

17239
10:51:43,640 --> 10:51:47,960
y so to speak like a garbage value maybe

17240
10:51:46,520 --> 10:51:49,079
it's zero which isn't bad because at

17241
10:51:47,960 --> 10:51:51,040
least it's nice and simple but maybe

17242
10:51:49,080 --> 10:51:52,916
it's some crazy large uh positive number

17243
10:51:51,040 --> 10:51:54,720
some crazy large negative number either

17244
10:51:52,916 --> 10:51:57,399
way odds are if I go to this address or

17245
10:51:54,720 --> 10:51:59,200
that address randomly with star y bad

17246
10:51:57,400 --> 10:52:00,680
things are going to happen and so let me

17247
10:51:59,200 --> 10:52:02,159
go ahead and propose well let's not do

17248
10:52:00,680 --> 10:52:04,880
that let's let's actually do this

17249
10:52:02,160 --> 10:52:07,080
instead assign y equal to X and we've

17250
10:52:04,880 --> 10:52:10,560
done that before and then I can go to Y

17251
10:52:07,080 --> 10:52:12,276
now and change what was a 42 to a 13

17252
10:52:10,560 --> 10:52:15,115
again why this is just for educational

17253
10:52:12,276 --> 10:52:18,040
sake but for now this does not crash

17254
10:52:15,116 --> 10:52:19,756
because I only dreference y with star y

17255
10:52:18,040 --> 10:52:22,480
after actually giving it a value albe it

17256
10:52:19,756 --> 10:52:24,160
a duplicate value similar to our copy

17257
10:52:22,480 --> 10:52:25,800
example earlier so our friends at

17258
10:52:24,160 --> 10:52:27,596
Stanford have put together a wonderful

17259
10:52:25,800 --> 10:52:29,596
visual it's about 2 minutes long allow

17260
10:52:27,596 --> 10:52:32,115
me to dramatically dim the lights if we

17261
10:52:29,596 --> 10:52:35,820
could and play with what happens with

17262
10:52:32,116 --> 10:52:37,000
memory when you do bad things like

17263
10:52:35,820 --> 10:52:40,360
[Music]

17264
10:52:37,000 --> 10:52:44,000
this hey Binky wake up it's time for

17265
10:52:40,360 --> 10:52:47,800
pointer fun what's that learn about

17266
10:52:44,000 --> 10:52:48,960
pointers Oh goodie well to get started I

17267
10:52:47,800 --> 10:52:51,880
guess we're going to need a couple

17268
10:52:48,960 --> 10:52:54,400
pointers okay this code allocates two

17269
10:52:51,880 --> 10:52:56,596
pointers which can point to integers

17270
10:52:54,400 --> 10:52:57,720
okay well I see the two pointers but

17271
10:52:56,596 --> 10:53:00,000
they don't seem to be pointing to

17272
10:52:57,720 --> 10:53:01,720
anything that's right initially pointers

17273
10:53:00,000 --> 10:53:03,880
don't point to anything the things they

17274
10:53:01,720 --> 10:53:06,116
point to are called Pointes and setting

17275
10:53:03,880 --> 10:53:07,840
them up is a separate step oh right

17276
10:53:06,116 --> 10:53:10,240
right I knew that the Pointes are

17277
10:53:07,840 --> 10:53:13,560
separate or so how do you allocate a

17278
10:53:10,240 --> 10:53:16,320
point e okay well this code allocates a

17279
10:53:13,560 --> 10:53:19,596
new integer point and this part sets X

17280
10:53:16,320 --> 10:53:22,116
to point to it hey that looks better so

17281
10:53:19,596 --> 10:53:24,159
make it do something okay I'll

17282
10:53:22,116 --> 10:53:27,080
dereference the pointer X to store the

17283
10:53:24,160 --> 10:53:29,320
number 42 into its Point e for this

17284
10:53:27,080 --> 10:53:32,480
trick I'll need my magic wand of

17285
10:53:29,320 --> 10:53:35,800
dereferencing your magic wand of D

17286
10:53:32,480 --> 10:53:37,720
referencing uh that that's great this is

17287
10:53:35,800 --> 10:53:39,276
what the code looks like I'll just set

17288
10:53:37,720 --> 10:53:43,400
up the number

17289
10:53:39,276 --> 10:53:45,880
and hey look there it goes so doing a d

17290
10:53:43,400 --> 10:53:47,960
reference on X follows the arrow to

17291
10:53:45,880 --> 10:53:50,680
access its Point T in this case to store

17292
10:53:47,960 --> 10:53:53,040
42 in there hey try using it to store

17293
10:53:50,680 --> 10:53:57,400
the number 13 through the other pointer

17294
10:53:53,040 --> 10:54:00,160
why okay I'll just go over here to Y and

17295
10:53:57,400 --> 10:54:04,040
get the number 13 set up and then take

17296
10:54:00,160 --> 10:54:08,000
the wand of d referencing and

17297
10:54:04,040 --> 10:54:10,040
just oh hey that didn't work say uh

17298
10:54:08,000 --> 10:54:12,436
Binky I don't think de referencing Y is

17299
10:54:10,040 --> 10:54:14,640
a good idea cuz uh you know setting up

17300
10:54:12,436 --> 10:54:17,880
the point T is a separate step and uh I

17301
10:54:14,640 --> 10:54:20,200
don't think we ever did it good point

17302
10:54:17,880 --> 10:54:22,360
yeah we we allocated the pointer y but

17303
10:54:20,200 --> 10:54:25,520
we never set it to point to a point

17304
10:54:22,360 --> 10:54:27,680
T very observant hey you're looking good

17305
10:54:25,520 --> 10:54:30,240
there Binky can you fix it so that y

17306
10:54:27,680 --> 10:54:32,880
points to the same point as X sure I'll

17307
10:54:30,240 --> 10:54:34,276
use my magic wand of pointer assignment

17308
10:54:32,880 --> 10:54:36,916
is that going to be a problem like

17309
10:54:34,276 --> 10:54:38,640
before no this doesn't touch the Pointes

17310
10:54:36,916 --> 10:54:42,200
it just changes one pointer to point to

17311
10:54:38,640 --> 10:54:45,080
the same thing is another oh I see now y

17312
10:54:42,200 --> 10:54:47,520
points to the same place as X so so wait

17313
10:54:45,080 --> 10:54:49,116
now Y is fixed it has a point e so you

17314
10:54:47,520 --> 10:54:53,320
can try the wand of D referencing again

17315
10:54:49,116 --> 10:54:56,240
to send the 13 over uh okay here it

17316
10:54:53,320 --> 10:54:58,000
goes hey look at that now D referencing

17317
10:54:56,240 --> 10:54:59,840
works on why and because the pointers

17318
10:54:58,000 --> 10:55:03,240
are sharing that one point e they both

17319
10:54:59,840 --> 10:55:05,320
see the 13 yeah sharing uh whatever so

17320
10:55:03,240 --> 10:55:07,960
are we going to switch places now oh

17321
10:55:05,320 --> 10:55:09,720
look we're out of time but L thanks to

17322
10:55:07,960 --> 10:55:11,436
Professor Nick parlante of Stanford for

17323
10:55:09,720 --> 10:55:13,480
spending a huge amount of time doing

17324
10:55:11,436 --> 10:55:14,720
stop motion animation for that but

17325
10:55:13,480 --> 10:55:17,880
hopefully now you have a sense of what

17326
10:55:14,720 --> 10:55:19,800
two can go wrong when you misuse memory

17327
10:55:17,880 --> 10:55:21,079
in this way but at the end of the day we

17328
10:55:19,800 --> 10:55:22,880
really only have these four new building

17329
10:55:21,080 --> 10:55:25,320
blocks today like the star operator the

17330
10:55:22,880 --> 10:55:26,960
Ampersand operator malok and free and

17331
10:55:25,320 --> 10:55:28,276
really with that and the underlying

17332
10:55:26,960 --> 10:55:30,240
understanding of what your computer is

17333
10:55:28,276 --> 10:55:32,320
doing underneath the hood we have this

17334
10:55:30,240 --> 10:55:33,960
way now to really manipulate things in

17335
10:55:32,320 --> 10:55:35,360
memory For Better or For Worse and

17336
10:55:33,960 --> 10:55:37,360
eventually we'll see how we can build

17337
10:55:35,360 --> 10:55:39,880
things but we can also now use today's

17338
10:55:37,360 --> 10:55:41,200
Primitives to better explain some things

17339
10:55:39,880 --> 10:55:43,159
that we've been asking you to take for

17340
10:55:41,200 --> 10:55:46,435
granted over the past several weeks so

17341
10:55:43,160 --> 10:55:49,240
for instance let me propose that we uh

17342
10:55:46,436 --> 10:55:51,400
do one volunteer up here if we could

17343
10:55:49,240 --> 10:55:53,240
could we get one volunteer who's you

17344
10:55:51,400 --> 10:55:54,640
want to come straight up yep right in

17345
10:55:53,240 --> 10:55:57,400
the middle come on you'll have to take a

17346
10:55:54,640 --> 10:55:57,400
left right

17347
10:55:59,880 --> 10:56:04,399
there

17348
10:56:01,800 --> 10:56:06,680
all right so we have two empty glasses

17349
10:56:04,400 --> 10:56:08,320
here and two colors of liquid and we

17350
10:56:06,680 --> 10:56:10,080
have let me give you the mic if you'd

17351
10:56:08,320 --> 10:56:13,680
like to say hello to the

17352
10:56:10,080 --> 10:56:15,596
group hello um I'm Moen uh I'm in the

17353
10:56:13,680 --> 10:56:17,200
and first year all right welcome well

17354
10:56:15,596 --> 10:56:18,916
well welcome here I'm going to go ahead

17355
10:56:17,200 --> 10:56:21,399
and fill these two glasses with this

17356
10:56:18,916 --> 10:56:25,435
colored liquid um purple here on my

17357
10:56:21,400 --> 10:56:25,436
right let's fill up a glass

17358
10:56:25,720 --> 10:56:32,276
here yeah don't drink uh and now we'll

17359
10:56:29,080 --> 10:56:33,840
put some orange in here

17360
10:56:32,276 --> 10:56:36,916
and what we'd like you to do for the

17361
10:56:33,840 --> 10:56:38,880
audience if you don't mind is swap the

17362
10:56:36,916 --> 10:56:40,435
two values we've got a purple value and

17363
10:56:38,880 --> 10:56:42,240
orange value and I'd like the purple

17364
10:56:40,436 --> 10:56:45,360
liquid in this glass and the orange

17365
10:56:42,240 --> 10:56:45,360
liquid in that glass

17366
10:56:45,840 --> 10:56:51,320
please can I have another glass oh okay

17367
10:56:48,480 --> 10:56:53,520
good intuition but for the microphone uh

17368
10:56:51,320 --> 10:56:55,520
can I have another glass so you can and

17369
10:56:53,520 --> 10:56:57,276
just in fact I brought one here for you

17370
10:56:55,520 --> 10:56:58,880
why are you asking for this though cuz

17371
10:56:57,276 --> 10:57:00,680
if I just pour this into this and it'll

17372
10:56:58,880 --> 10:57:03,399
get mixed up right so obviously we need

17373
10:57:00,680 --> 10:57:05,960
like a temporary variable if you will so

17374
10:57:03,400 --> 10:57:09,680
here is your temporary

17375
10:57:05,960 --> 10:57:12,596
variable and you want yeah there's

17376
10:57:09,680 --> 10:57:14,640
yeah all right so pouring the value of

17377
10:57:12,596 --> 10:57:16,399
the orange glass into this temporary

17378
10:57:14,640 --> 10:57:20,040
variable if you

17379
10:57:16,400 --> 10:57:22,240
will all right and now pouring the value

17380
10:57:20,040 --> 10:57:24,800
of the purple glass into the former

17381
10:57:22,240 --> 10:57:24,799
orange

17382
10:57:26,000 --> 10:57:31,756
glass and

17383
10:57:28,640 --> 10:57:34,400
now the temporary value goes back into

17384
10:57:31,756 --> 10:57:35,720
the original purple glass and now I

17385
10:57:34,400 --> 10:57:38,960
think we give you a round of applause

17386
10:57:35,720 --> 10:57:42,880
for having done that very well

17387
10:57:38,960 --> 10:57:44,240
okay thank you all right so so it should

17388
10:57:42,880 --> 10:57:45,880
go without saying that in the real world

17389
10:57:44,240 --> 10:57:47,840
like that's how you do this and in fact

17390
10:57:45,880 --> 10:57:50,240
in code that's pretty much how you have

17391
10:57:47,840 --> 10:57:52,039
to do this although ask us some time for

17392
10:57:50,240 --> 10:57:53,799
a super fancy way of doing it without a

17393
10:57:52,040 --> 10:57:56,200
temporary variable turns out that is

17394
10:57:53,800 --> 10:57:57,680
possible using bits but for now let's

17395
10:57:56,200 --> 10:57:59,039
suppose that indeed this demonstrates

17396
10:57:57,680 --> 10:58:00,916
what is the reality in code if you want

17397
10:57:59,040 --> 10:58:03,000
to swap two values you need to have have

17398
10:58:00,916 --> 10:58:05,840
something like a temporary variable so

17399
10:58:03,000 --> 10:58:07,480
for instance on the screen here is a uh

17400
10:58:05,840 --> 10:58:09,115
the beginning of a function called swap

17401
10:58:07,480 --> 10:58:11,880
whose purpose in life is to as you just

17402
10:58:09,116 --> 10:58:13,436
did swap two values call it a and b so

17403
10:58:11,880 --> 10:58:15,159
orange and purple respectively are now

17404
10:58:13,436 --> 10:58:16,880
just a and b and integers to keep things

17405
10:58:15,160 --> 10:58:18,480
simple well here is the corresponding

17406
10:58:16,880 --> 10:58:20,399
code if I may to what you just enacted

17407
10:58:18,480 --> 10:58:22,560
as a human you declared a temporary

17408
10:58:20,400 --> 10:58:24,160
variable a called temp in this case

17409
10:58:22,560 --> 10:58:26,079
which was like me handing you The Empty

17410
10:58:24,160 --> 10:58:29,520
Glass and you stored the orange liquid

17411
10:58:26,080 --> 10:58:32,520
in it akaa you then changed the value of

17412
10:58:29,520 --> 10:58:34,520
the formerly orange glass to be equal to

17413
10:58:32,520 --> 10:58:36,240
the Purple by pouring one into the other

17414
10:58:34,520 --> 10:58:37,596
and then you did the opposite there now

17415
10:58:36,240 --> 10:58:39,479
at the end of this you still have a

17416
10:58:37,596 --> 10:58:41,079
temporary variable that's now empty so

17417
10:58:39,480 --> 10:58:42,360
it's temporary in literally that sense

17418
10:58:41,080 --> 10:58:45,080
like you just don't need it anymore but

17419
10:58:42,360 --> 10:58:47,756
it was necessary along the way so I dare

17420
10:58:45,080 --> 10:58:51,040
say this code is correct logically like

17421
10:58:47,756 --> 10:58:53,520
this will swap two values A and B thanks

17422
10:58:51,040 --> 10:58:55,360
to the use of that temporary variable

17423
10:58:53,520 --> 10:58:57,200
unfortunately though if I actually do

17424
10:58:55,360 --> 10:58:58,756
this in practice let me go over to VSS

17425
10:58:57,200 --> 10:59:01,960
code here and open a program I wrote in

17426
10:58:58,756 --> 10:59:04,480
advance called swap. C which does this

17427
10:59:01,960 --> 10:59:06,040
as follows in here notice I have my

17428
10:59:04,480 --> 10:59:07,840
prototype for a swap function at the

17429
10:59:06,040 --> 10:59:09,756
very top and let me scroll down to the

17430
10:59:07,840 --> 10:59:12,596
very bottom there is that exact same

17431
10:59:09,756 --> 10:59:14,400
code so I'm uh the same code for

17432
10:59:12,596 --> 10:59:16,916
swapping two values A and B which I'm

17433
10:59:14,400 --> 10:59:18,276
claiming for now is correct now if I go

17434
10:59:16,916 --> 10:59:19,755
back up here what is main going to do

17435
10:59:18,276 --> 10:59:21,436
for us main is really just meant to be a

17436
10:59:19,756 --> 10:59:23,680
demonstration of the correctness of your

17437
10:59:21,436 --> 10:59:26,000
algorithm so here I declare on line

17438
10:59:23,680 --> 10:59:28,756
seven and eight two variables X and Y

17439
10:59:26,000 --> 10:59:30,640
being 1 and two arbitrarily respectively

17440
10:59:28,756 --> 10:59:32,840
I then on line 10 just print out what

17441
10:59:30,640 --> 10:59:35,276
the value of x is and Y is just so I can

17442
10:59:32,840 --> 10:59:37,479
see it on the screen I then call the

17443
10:59:35,276 --> 10:59:39,115
swap function on line 11 and then I

17444
10:59:37,480 --> 10:59:41,680
literally print the exact same thing

17445
10:59:39,116 --> 10:59:43,960
again I print X and Y hopefully it'll

17446
10:59:41,680 --> 10:59:45,720
obviously be the opposite so I think

17447
10:59:43,960 --> 10:59:48,640
logically swap is indeed correct let me

17448
10:59:45,720 --> 10:59:51,436
do make Swap and then do/ Swap and I

17449
10:59:48,640 --> 10:59:56,080
should see X is one y is 2 and then

17450
10:59:51,436 --> 10:59:58,720
hopefully X is 2 Y is 1 enter but I

17451
10:59:56,080 --> 11:00:00,880
don't and it did work in the sense that

17452
10:59:58,720 --> 11:00:03,436
the code compiled the code ran so it's

17453
11:00:00,880 --> 11:00:05,640
not like some bug in that sense but

17454
11:00:03,436 --> 11:00:07,360
because I don't quite understand what's

17455
11:00:05,640 --> 11:00:10,000
going on underneath the hood at least as

17456
11:00:07,360 --> 11:00:13,560
of right now or prior weeks this code

17457
11:00:10,000 --> 11:00:15,276
here is indeed buggy in some way but

17458
11:00:13,560 --> 11:00:17,079
does anyone have an intuition perhaps

17459
11:00:15,276 --> 11:00:18,880
based on today's discussion is to like

17460
11:00:17,080 --> 11:00:21,080
why this code while logically correct

17461
11:00:18,880 --> 11:00:22,680
clearly works in reality apparently does

17462
11:00:21,080 --> 11:00:26,916
not work in

17463
11:00:22,680 --> 11:00:26,916
C any intuition

17464
11:00:27,560 --> 11:00:31,040
yeah perfect and to summarize here's

17465
11:00:29,596 --> 11:00:33,159
that term of art I prom

17466
11:00:31,040 --> 11:00:35,200
when you call a function and pass in two

17467
11:00:33,160 --> 11:00:38,240
arguments Like A and B you're passing

17468
11:00:35,200 --> 11:00:40,520
those arguments by value so copies of

17469
11:00:38,240 --> 11:00:43,079
those values effectively and so when

17470
11:00:40,520 --> 11:00:45,840
swap is actually called here sorry when

17471
11:00:43,080 --> 11:00:47,080
you pass in X and Y we call them A and B

17472
11:00:45,840 --> 11:00:49,596
but that's just a convention we could

17473
11:00:47,080 --> 11:00:52,160
call the parameters anything we want

17474
11:00:49,596 --> 11:00:55,000
what A and B are are indeed the values

17475
11:00:52,160 --> 11:00:57,520
of X and Y respectively but copies of

17476
11:00:55,000 --> 11:00:59,800
the values so this code here is very

17477
11:00:57,520 --> 11:01:02,435
successfully in vs code 2 swapping the

17478
11:00:59,800 --> 11:01:04,720
values of a A and B but as you note

17479
11:01:02,436 --> 11:01:06,960
because I'm passing them in by value

17480
11:01:04,720 --> 11:01:09,640
literally one literally two and not by

17481
11:01:06,960 --> 11:01:12,756
another term of art by reference AKA by

17482
11:01:09,640 --> 11:01:15,720
their addresses swap has no capability

17483
11:01:12,756 --> 11:01:17,276
in C to go to those locations swap the

17484
11:01:15,720 --> 11:01:19,840
actual locations just like we did

17485
11:01:17,276 --> 11:01:21,436
successfully in reality but I think we

17486
11:01:19,840 --> 11:01:23,359
really have the syntax already for

17487
11:01:21,436 --> 11:01:24,880
solving this if we consider that really

17488
11:01:23,360 --> 11:01:26,840
this is just an issue of scope and we've

17489
11:01:24,880 --> 11:01:28,840
talked a bit about scope in the past

17490
11:01:26,840 --> 11:01:30,799
whereby scope refers to the context in

17491
11:01:28,840 --> 11:01:32,240
which a variable lives and generally

17492
11:01:30,800 --> 11:01:34,480
I've claimed that a variable exists

17493
11:01:32,240 --> 11:01:36,115
between the most recent curly braces and

17494
11:01:34,480 --> 11:01:38,640
that's pretty much true for the swap

17495
11:01:36,116 --> 11:01:40,756
function because a and b i now claim

17496
11:01:38,640 --> 11:01:43,000
again exist only in the context of these

17497
11:01:40,756 --> 11:01:45,276
curly braces they have no effect on Main

17498
11:01:43,000 --> 11:01:47,520
up top which has different variables X

17499
11:01:45,276 --> 11:01:48,880
and Y but we can consider now what's

17500
11:01:47,520 --> 11:01:50,240
really going on underneath the hood and

17501
11:01:48,880 --> 11:01:52,159
here's that same picture of memory as

17502
11:01:50,240 --> 11:01:53,720
we've seen in the past if we zoom in and

17503
11:01:52,160 --> 11:01:55,880
see on these little black chips this is

17504
11:01:53,720 --> 11:01:57,840
a bunch of bites of memory if I create a

17505
11:01:55,880 --> 11:01:59,799
grid out of it just to kind of highlight

17506
11:01:57,840 --> 11:02:01,560
that we can address each of these bites

17507
11:01:59,800 --> 11:02:04,000
throw away the plastic circuit board and

17508
11:02:01,560 --> 11:02:06,520
focus only on those bites what's going

17509
11:02:04,000 --> 11:02:08,520
on underneath the hood when functions

17510
11:02:06,520 --> 11:02:10,840
are called in C which you've been doing

17511
11:02:08,520 --> 11:02:12,479
for weeks now well this rectangle of

17512
11:02:10,840 --> 11:02:15,079
memory if we kind of abstract it away

17513
11:02:12,480 --> 11:02:16,960
further is generally broken up into

17514
11:02:15,080 --> 11:02:19,360
different regions or segments like I

17515
11:02:16,960 --> 11:02:20,560
called them earlier and different things

17516
11:02:19,360 --> 11:02:22,480
get put in different parts of the

17517
11:02:20,560 --> 11:02:24,960
computer's memory and without getting

17518
11:02:22,480 --> 11:02:26,840
too into the weeds when you double click

17519
11:02:24,960 --> 11:02:31,080
a program on your macro PC or when you

17520
11:02:26,840 --> 11:02:33,079
do/ something on a Linux you are loading

17521
11:02:31,080 --> 11:02:35,560
your machine code into the computer's

17522
11:02:33,080 --> 11:02:37,080
memory from the computer's hard drive so

17523
11:02:35,560 --> 11:02:39,399
all the zeros and ones that compose

17524
11:02:37,080 --> 11:02:42,000
Microsoft Word or Chrome or whatever are

17525
11:02:39,400 --> 11:02:43,800
loaded into the computer's memory or RAM

17526
11:02:42,000 --> 11:02:45,596
and by convention it's put up top in the

17527
11:02:43,800 --> 11:02:47,916
so-called machine code area and that's

17528
11:02:45,596 --> 11:02:50,360
how the CPU has access to them quickly

17529
11:02:47,916 --> 11:02:52,640
at that below that are what are be going

17530
11:02:50,360 --> 11:02:54,520
to be our globals so Global variables

17531
11:02:52,640 --> 11:02:56,720
which we haven't used very much in C but

17532
11:02:54,520 --> 11:02:58,479
you can declare them outside of main at

17533
11:02:56,720 --> 11:03:00,320
the very top of your files if you have

17534
11:02:58,480 --> 11:03:02,436
globals they end up up there as well

17535
11:03:00,320 --> 11:03:04,756
just FYI and then there's this big chunk

17536
11:03:02,436 --> 11:03:06,560
of memory that we saw valgren mention

17537
11:03:04,756 --> 11:03:08,240
indirectly earlier called the Heap and

17538
11:03:06,560 --> 11:03:10,360
it's kind of like Heap literally like

17539
11:03:08,240 --> 11:03:13,240
it's a heap of memory that you can use

17540
11:03:10,360 --> 11:03:15,596
as you see fit and the Heap is where

17541
11:03:13,240 --> 11:03:17,200
malok grabs memory from so initially

17542
11:03:15,596 --> 11:03:19,276
there's nothing in the Heap it's just a

17543
11:03:17,200 --> 11:03:21,799
big chunk of free space anytime you call

17544
11:03:19,276 --> 11:03:24,436
malok Malo kind of carves out from the

17545
11:03:21,800 --> 11:03:26,116
Heap area more and more bites and Malo

17546
11:03:24,436 --> 11:03:28,040
keeps track of essentially which bites

17547
11:03:26,116 --> 11:03:30,276
have already been allocated so initially

17548
11:03:28,040 --> 11:03:31,640
it looks empty but different bites

17549
11:03:30,276 --> 11:03:33,200
squares if you will keep getting

17550
11:03:31,640 --> 11:03:35,880
requested again and again as a program

17551
11:03:33,200 --> 11:03:37,640
runs thanks to functions like malok and

17552
11:03:35,880 --> 11:03:39,276
it grows if you will conceptually down

17553
11:03:37,640 --> 11:03:41,479
so the more and more memory you request

17554
11:03:39,276 --> 11:03:42,916
from malok it starts up here but then

17555
11:03:41,480 --> 11:03:44,596
the next chunk you get is down here

17556
11:03:42,916 --> 11:03:46,435
conceptually the next chunk is down here

17557
11:03:44,596 --> 11:03:48,079
down here so it kind of fills the

17558
11:03:46,436 --> 11:03:50,040
available space in the computer's

17559
11:03:48,080 --> 11:03:53,080
overall memory but there's this other

17560
11:03:50,040 --> 11:03:54,640
chunk of memory called the stack and

17561
11:03:53,080 --> 11:03:57,080
just like a stack of trays in like

17562
11:03:54,640 --> 11:03:59,400
annenburg or a cafeteria kind of grow

17563
11:03:57,080 --> 11:04:02,400
upward so does the stack of memory and

17564
11:03:59,400 --> 11:04:05,436
it turns out the stack is where

17565
11:04:02,400 --> 11:04:07,960
functions have variables and have

17566
11:04:05,436 --> 11:04:10,436
arguments stored temporarily so whenever

17567
11:04:07,960 --> 11:04:12,040
you call a function and it has variables

17568
11:04:10,436 --> 11:04:14,080
inside of it or it has arguments there

17569
11:04:12,040 --> 11:04:16,320
too this is the chunk of memory and the

17570
11:04:14,080 --> 11:04:18,200
computer's overall block of memory that

17571
11:04:16,320 --> 11:04:20,840
are used for functions but anytime you

17572
11:04:18,200 --> 11:04:22,159
call malok it's memory up here right at

17573
11:04:20,840 --> 11:04:23,719
the end of the day they just had to pick

17574
11:04:22,160 --> 11:04:24,800
a direction top bottom and technically

17575
11:04:23,720 --> 11:04:26,596
it's an artist rendition you could

17576
11:04:24,800 --> 11:04:28,480
Circle this thing around any orientation

17577
11:04:26,596 --> 11:04:30,240
you want but you're just using a finite

17578
11:04:28,480 --> 11:04:32,916
amount of memory in this conventional

17579
11:04:30,240 --> 11:04:34,720
way Malo Starts Here functions start

17580
11:04:32,916 --> 11:04:37,079
here now you can kind of see where like

17581
11:04:34,720 --> 11:04:38,880
bad things can happen and indeed one of

17582
11:04:37,080 --> 11:04:40,960
the other reasons programs computers can

17583
11:04:38,880 --> 11:04:42,755
crash is if you ask for way too much

17584
11:04:40,960 --> 11:04:45,116
memory from the Heap by calling malok

17585
11:04:42,756 --> 11:04:47,080
many many many times or if you call way

17586
11:04:45,116 --> 11:04:49,320
too many functions or accidentally per

17587
11:04:47,080 --> 11:04:51,116
last week you recurse infinitely many

17588
11:04:49,320 --> 11:04:52,880
times you might have a segmentation

17589
11:04:51,116 --> 11:04:54,960
fault and that's because you're using

17590
11:04:52,880 --> 11:04:57,079
too much stack memory so this is bound

17591
11:04:54,960 --> 11:04:59,436
to be a problem eventually and the onus

17592
11:04:57,080 --> 11:05:01,520
is on the programmer to just minimize

17593
11:04:59,436 --> 11:05:03,360
the probability of doing that and really

17594
11:05:01,520 --> 11:05:05,000
avoid the possibility of doing that by

17595
11:05:03,360 --> 11:05:07,360
just checking return values like

17596
11:05:05,000 --> 11:05:09,560
checking if malok or get string return

17597
11:05:07,360 --> 11:05:11,756
null because you can proactively with

17598
11:05:09,560 --> 11:05:13,435
conditionals make sure that these two

17599
11:05:11,756 --> 11:05:16,040
things do not Collide by just making

17600
11:05:13,436 --> 11:05:17,520
sure that you get back non-null values

17601
11:05:16,040 --> 11:05:19,800
so let's consider the stack in the

17602
11:05:17,520 --> 11:05:20,755
context of Swap and what's really

17603
11:05:19,800 --> 11:05:21,960
happening here and Carter if you

17604
11:05:20,756 --> 11:05:24,960
wouldn't mind helping me animate the

17605
11:05:21,960 --> 11:05:28,040
screen here when I call the main

17606
11:05:24,960 --> 11:05:30,520
function of any program it is allocated

17607
11:05:28,040 --> 11:05:31,840
a slice of memory called a frame at the

17608
11:05:30,520 --> 11:05:33,719
bottom of this stack so if Carter you

17609
11:05:31,840 --> 11:05:35,435
want to go ahead and uh Advance here

17610
11:05:33,720 --> 11:05:37,560
here's like the First Slice of memory

17611
11:05:35,436 --> 11:05:39,680
that will always be used by main whether

17612
11:05:37,560 --> 11:05:42,435
it has commandline arguments or local

17613
11:05:39,680 --> 11:05:45,040
variables it just ends up here in memory

17614
11:05:42,436 --> 11:05:47,520
suppose now per our swap. C program that

17615
11:05:45,040 --> 11:05:49,520
main calls swap well where does the

17616
11:05:47,520 --> 11:05:51,359
memory for swap end up like right up

17617
11:05:49,520 --> 11:05:54,115
here so swap had two variable two

17618
11:05:51,360 --> 11:05:55,840
arguments uh A and B and it also had a

17619
11:05:54,116 --> 11:05:57,916
temporary variable so all of those end

17620
11:05:55,840 --> 11:05:59,719
up in here in memory and if you want to

17621
11:05:57,916 --> 11:06:02,399
go ahead and Advance again Carter once

17622
11:05:59,720 --> 11:06:03,880
swap is done executing whether it just

17623
11:06:02,400 --> 11:06:06,080
returns because there's no more lines of

17624
11:06:03,880 --> 11:06:08,520
code or you explicitly return this

17625
11:06:06,080 --> 11:06:10,560
memory is just freed up automatically

17626
11:06:08,520 --> 11:06:12,159
you don't call free you don't undo malok

17627
11:06:10,560 --> 11:06:14,840
this just all happens automatically and

17628
11:06:12,160 --> 11:06:16,756
has been since week one now technically

17629
11:06:14,840 --> 11:06:18,560
it's still there even though we've

17630
11:06:16,756 --> 11:06:20,640
removed it from the picture and there's

17631
11:06:18,560 --> 11:06:22,276
your first hint of garbage values right

17632
11:06:20,640 --> 11:06:23,960
like there's still zeros and ones there

17633
11:06:22,276 --> 11:06:26,200
and they're left in the original the

17634
11:06:23,960 --> 11:06:28,200
previous configuration and so the reason

17635
11:06:26,200 --> 11:06:29,680
you get random values in the memory is

17636
11:06:28,200 --> 11:06:31,719
because even though we hav't drawn swap

17637
11:06:29,680 --> 11:06:33,116
here there was stuff there a moment ago

17638
11:06:31,720 --> 11:06:35,360
it's going to be there the next time you

17639
11:06:33,116 --> 11:06:36,360
use that same memory now let's go ahead

17640
11:06:35,360 --> 11:06:39,240
and step through this a little more

17641
11:06:36,360 --> 11:06:41,596
methodically main has two variables

17642
11:06:39,240 --> 11:06:44,240
called X and Y one and two so let's

17643
11:06:41,596 --> 11:06:46,079
advance and represent X is one y is two

17644
11:06:44,240 --> 11:06:48,360
taking up these two chunks of memory

17645
11:06:46,080 --> 11:06:51,480
when we call swamp now swamp gets a new

17646
11:06:48,360 --> 11:06:53,400
slice of memory that then gives us three

17647
11:06:51,480 --> 11:06:56,040
variables A and B technically the

17648
11:06:53,400 --> 11:06:58,276
arguments and temp so what happens well

17649
11:06:56,040 --> 11:07:00,640
because functions automatically pass in

17650
11:06:58,276 --> 11:07:04,360
values by value or rather pass in

17651
11:07:00,640 --> 11:07:07,000
arguments by value X gets copied into a

17652
11:07:04,360 --> 11:07:08,880
y gets copied into B and then once we

17653
11:07:07,000 --> 11:07:11,040
start executing the algorithm all the

17654
11:07:08,880 --> 11:07:12,799
watered glasses well what happens here

17655
11:07:11,040 --> 11:07:16,000
so if I execute the first line of code

17656
11:07:12,800 --> 11:07:18,880
temp equals a temp gets a copy of a what

17657
11:07:16,000 --> 11:07:21,200
happens next a equals B so a takes on a

17658
11:07:18,880 --> 11:07:23,799
copy of B and now we do the final swap

17659
11:07:21,200 --> 11:07:25,916
in the glasses b equals temp b gets a

17660
11:07:23,800 --> 11:07:27,840
copy of temp now we don't have to change

17661
11:07:25,916 --> 11:07:29,560
temp because it's essentially empty

17662
11:07:27,840 --> 11:07:31,115
although there's the garbage value one

17663
11:07:29,560 --> 11:07:33,040
is always now going to be there until we

17664
11:07:31,116 --> 11:07:35,400
reuse that memory the important thing

17665
11:07:33,040 --> 11:07:37,436
though is that a and b have been swapped

17666
11:07:35,400 --> 11:07:40,276
but what obviously has not been swapped

17667
11:07:37,436 --> 11:07:42,400
as is Manifest is when swap returns X

17668
11:07:40,276 --> 11:07:44,436
and Y are untouched because copies

17669
11:07:42,400 --> 11:07:45,756
thereof were passed in so we need a

17670
11:07:44,436 --> 11:07:47,276
solution to this problem and if we

17671
11:07:45,756 --> 11:07:48,680
advance one more time if you don't mind

17672
11:07:47,276 --> 11:07:51,320
let me step over here but then call you

17673
11:07:48,680 --> 11:07:53,560
back in a second this code here is

17674
11:07:51,320 --> 11:07:55,960
logically correct this is what you did

17675
11:07:53,560 --> 11:07:57,640
but this is now a detail of C you can't

17676
11:07:55,960 --> 11:07:59,240
just swap the things by value because

17677
11:07:57,640 --> 11:08:01,436
you're only changing it in the scope of

17678
11:07:59,240 --> 11:08:03,400
the swap function function but I think

17679
11:08:01,436 --> 11:08:06,640
if we change it to this and add some

17680
11:08:03,400 --> 11:08:08,560
annoying syntax we can solve the problem

17681
11:08:06,640 --> 11:08:10,436
just like you can declare variables as

17682
11:08:08,560 --> 11:08:13,079
storing addresses you can declare

17683
11:08:10,436 --> 11:08:15,480
arguments to functions AKA parameters as

17684
11:08:13,080 --> 11:08:17,800
taking addresses this new version of

17685
11:08:15,480 --> 11:08:20,240
swap means that a shall be the address

17686
11:08:17,800 --> 11:08:22,160
of an integer B shall be the address of

17687
11:08:20,240 --> 11:08:24,200
an integer and now it gets a little

17688
11:08:22,160 --> 11:08:25,916
cryptic here temp is the same because

17689
11:08:24,200 --> 11:08:28,399
it's just an integer like it was in week

17690
11:08:25,916 --> 11:08:31,435
one nothing special about temp but if

17691
11:08:28,400 --> 11:08:33,240
you want to get the value at a you do

17692
11:08:31,436 --> 11:08:35,400
star a and that goes to the address

17693
11:08:33,240 --> 11:08:37,520
grabs the number one presumably if you

17694
11:08:35,400 --> 11:08:39,240
want to change the value of a you go to

17695
11:08:37,520 --> 11:08:41,000
that address you follow the treasure map

17696
11:08:39,240 --> 11:08:43,240
to the other mailbox and you set it

17697
11:08:41,000 --> 11:08:46,116
equal to whatever is at the value of B

17698
11:08:43,240 --> 11:08:47,756
you go to B as well last line you go to

17699
11:08:46,116 --> 11:08:49,840
B now and change it to be whatever the

17700
11:08:47,756 --> 11:08:51,720
temporary variable was which happened to

17701
11:08:49,840 --> 11:08:53,960
be the same as a so that's where the

17702
11:08:51,720 --> 11:08:55,276
final value gets swapped but here

17703
11:08:53,960 --> 11:08:56,640
there's a lot more like crisscrossing

17704
11:08:55,276 --> 11:08:58,000
metaphorically across the stage where

17705
11:08:56,640 --> 11:09:00,116
you're going to all of these different

17706
11:08:58,000 --> 11:09:01,840
addresses in the swap function to make

17707
11:09:00,116 --> 11:09:03,480
these changes so if we advance now to

17708
11:09:01,840 --> 11:09:05,960
the pictoral version of this here's the

17709
11:09:03,480 --> 11:09:07,880
same story as before with Maine and X

17710
11:09:05,960 --> 11:09:10,159
and Y are 1 and two respectively when

17711
11:09:07,880 --> 11:09:12,799
swap gets called now notice and I'll do

17712
11:09:10,160 --> 11:09:14,960
it with arrows here a is effectively

17713
11:09:12,800 --> 11:09:16,916
pointing to X B is effectively pointing

17714
11:09:14,960 --> 11:09:18,320
to Y if we really get into the weeds

17715
11:09:16,916 --> 11:09:20,115
these are actually like addresses but

17716
11:09:18,320 --> 11:09:22,000
who cares about the specifics it's

17717
11:09:20,116 --> 11:09:25,240
really just the concept here so now what

17718
11:09:22,000 --> 11:09:27,680
happens in temp gets star a star a means

17719
11:09:25,240 --> 11:09:29,040
start at a and go there Follow the arrow

17720
11:09:27,680 --> 11:09:31,080
if you will sort of shoots in ladder

17721
11:09:29,040 --> 11:09:34,240
Style and then that's one so we put one

17722
11:09:31,080 --> 11:09:35,960
and 10th all right star a equals star B

17723
11:09:34,240 --> 11:09:38,400
so let's do it from right to left star b

17724
11:09:35,960 --> 11:09:40,560
means Follow the arrow it's two and then

17725
11:09:38,400 --> 11:09:42,680
what do you do Follow the arrow it's now

17726
11:09:40,560 --> 11:09:45,000
two because you copy one to the other

17727
11:09:42,680 --> 11:09:47,480
from right to left and then lastly star

17728
11:09:45,000 --> 11:09:50,480
b gets temp so start at B go to B and

17729
11:09:47,480 --> 11:09:52,360
now store whatever the value is in temp

17730
11:09:50,480 --> 11:09:54,200
so just by having this basic new syntax

17731
11:09:52,360 --> 11:09:56,160
of like ampersands and stars and so

17732
11:09:54,200 --> 11:09:57,755
forth we can actually now go to places

17733
11:09:56,160 --> 11:10:00,080
and circumvent what is otherwise a

17734
11:09:57,756 --> 11:10:02,320
feature of C that these variables are

17735
11:10:00,080 --> 11:10:04,756
locally scoped but you can still access

17736
11:10:02,320 --> 11:10:05,880
things in other functions as well so

17737
11:10:04,756 --> 11:10:08,000
thank you so much for helping step

17738
11:10:05,880 --> 11:10:10,115
through this so we now have a

17739
11:10:08,000 --> 11:10:12,480
application of this that explains why

17740
11:10:10,116 --> 11:10:14,160
now in this version of the C code this

17741
11:10:12,480 --> 11:10:17,276
would actually now work so in fact let

17742
11:10:14,160 --> 11:10:19,040
me go back to my swap code here and let

17743
11:10:17,276 --> 11:10:21,720
me change the function ever so slightly

17744
11:10:19,040 --> 11:10:24,880
in vs code so let me scroll down leaving

17745
11:10:21,720 --> 11:10:27,756
main the same and let me change swaps

17746
11:10:24,880 --> 11:10:30,435
prototype to taking in addresses let me

17747
11:10:27,756 --> 11:10:33,200
go to a here let me go to a here let me

17748
11:10:30,436 --> 11:10:35,276
go to B here and let me go to B here as

17749
11:10:33,200 --> 11:10:37,115
well but nothing else changes this

17750
11:10:35,276 --> 11:10:39,436
change here in particular is enough of a

17751
11:10:37,116 --> 11:10:42,680
clue to see that means when you call

17752
11:10:39,436 --> 11:10:45,720
Swap and pass into values I'm expecting

17753
11:10:42,680 --> 11:10:47,560
addresses now not integers but now that

17754
11:10:45,720 --> 11:10:51,960
I've made this change I do need to go up

17755
11:10:47,560 --> 11:10:53,720
to Main and make one change does anyone

17756
11:10:51,960 --> 11:10:57,400
have the intuition for what now need

17757
11:10:53,720 --> 11:10:59,400
change in main so that I pass in X and Y

17758
11:10:57,400 --> 11:11:02,930
by reference that is by address rather

17759
11:10:59,400 --> 11:11:05,596
than than by value or copy oh yeah and

17760
11:11:02,930 --> 11:11:08,400
[Music]

17761
11:11:05,596 --> 11:11:10,596
back so close so on the swap line it's

17762
11:11:08,400 --> 11:11:13,276
not star that I want in front of the X

17763
11:11:10,596 --> 11:11:13,276
and the Y it's

17764
11:11:13,640 --> 11:11:18,640
instead what's the other one it's the

17765
11:11:16,596 --> 11:11:20,640
Amper sand why because if I want to

17766
11:11:18,640 --> 11:11:21,840
enable swap to go somewhere just like

17767
11:11:20,640 --> 11:11:24,159
Carter and I played this game with the

17768
11:11:21,840 --> 11:11:26,479
mailboxes I need to inform swap of the

17769
11:11:24,160 --> 11:11:28,520
address of X and the address of Y and

17770
11:11:26,480 --> 11:11:30,480
again per the beginning of today's class

17771
11:11:28,520 --> 11:11:32,000
Ampersand is the text via which we do

17772
11:11:30,480 --> 11:11:33,960
that so I add an ampersand here to get

17773
11:11:32,000 --> 11:11:36,436
the address of X Ampersand here to get

17774
11:11:33,960 --> 11:11:38,200
the address of Y and now this code lines

17775
11:11:36,436 --> 11:11:40,080
up with the picture that Carter just

17776
11:11:38,200 --> 11:11:43,399
helped us walk through and so when I run

17777
11:11:40,080 --> 11:11:46,320
make swap here I have a mistake oh what

17778
11:11:43,400 --> 11:11:48,960
did I do wrong not intentional but I

17779
11:11:46,320 --> 11:11:52,000
guess worth pointing out I screwed up

17780
11:11:48,960 --> 11:11:55,560
here it doesn't like Ampersand

17781
11:11:52,000 --> 11:11:57,360
X because of something on line three

17782
11:11:55,560 --> 11:12:01,435
which is way early in the code what did

17783
11:11:57,360 --> 11:12:01,436
I screw up yeah in the middle

17784
11:12:01,916 --> 11:12:05,435
yeah so this is why we you should not

17785
11:12:04,000 --> 11:12:06,960
copy paste even though it's necessary

17786
11:12:05,436 --> 11:12:08,960
for things like function prototypes if I

17787
11:12:06,960 --> 11:12:10,840
change swap at the bottom I need to

17788
11:12:08,960 --> 11:12:12,436
change its prototype so let me add the

17789
11:12:10,840 --> 11:12:14,640
star there add the star there or just

17790
11:12:12,436 --> 11:12:16,756
recopy paste it at the top of the file

17791
11:12:14,640 --> 11:12:19,320
now let me do make swap again let me now

17792
11:12:16,756 --> 11:12:23,640
do do/ Swap and I should now see X is

17793
11:12:19,320 --> 11:12:25,916
one y is 2 and hopefully X is 2 Y is 1

17794
11:12:23,640 --> 11:12:27,520
which I now do so the logic is the same

17795
11:12:25,916 --> 11:12:29,640
the algorithm is the same all the weak

17796
11:12:27,520 --> 11:12:31,115
zero stuff is the same except now and

17797
11:12:29,640 --> 11:12:33,720
four you just have a bit more

17798
11:12:31,116 --> 11:12:35,560
expressiveness via which you can tell

17799
11:12:33,720 --> 11:12:39,720
the computer exactly what you want to

17800
11:12:35,560 --> 11:12:42,399
manipulate and how any questions then on

17801
11:12:39,720 --> 11:12:45,840
this technique

17802
11:12:42,400 --> 11:12:47,116
here no all right well when we fix this

17803
11:12:45,840 --> 11:12:48,596
there's still going to be problems and

17804
11:12:47,116 --> 11:12:50,200
just so you've seen some terms of art

17805
11:12:48,596 --> 11:12:51,840
here this is bad whenever you have two

17806
11:12:50,200 --> 11:12:53,799
arrows pointing at one another certainly

17807
11:12:51,840 --> 11:12:55,200
if you might use and reuse more and more

17808
11:12:53,800 --> 11:12:56,720
memory and it turns out there's some

17809
11:12:55,200 --> 11:12:57,680
terms of art that might suddenly now

17810
11:12:56,720 --> 11:13:00,320
make sense especially if you've

17811
11:12:57,680 --> 11:13:02,400
programmed before bad things Can Happen

17812
11:13:00,320 --> 11:13:03,596
by this design but there's really only

17813
11:13:02,400 --> 11:13:05,080
this kind of design because it's a

17814
11:13:03,596 --> 11:13:06,320
finite amount of memory so at some point

17815
11:13:05,080 --> 11:13:08,240
bad things are going to happen no matter

17816
11:13:06,320 --> 11:13:09,680
what if a computer runs out of memory so

17817
11:13:08,240 --> 11:13:11,400
it's not that this was a poor decision

17818
11:13:09,680 --> 11:13:13,560
it's just sort of a necessary one given

17819
11:13:11,400 --> 11:13:15,720
finite amounts of memory in a computer

17820
11:13:13,560 --> 11:13:17,479
but a heap overflow so to speak is when

17821
11:13:15,720 --> 11:13:19,720
you actually overflow the Heap and touch

17822
11:13:17,480 --> 11:13:21,360
memory that you shouldn't up there stack

17823
11:13:19,720 --> 11:13:22,960
Overflow is when you somehow overflow

17824
11:13:21,360 --> 11:13:24,880
the stack and touch memory that you

17825
11:13:22,960 --> 11:13:26,320
shouldn't down there so with that said

17826
11:13:24,880 --> 11:13:28,000
these are really just problems that can

17827
11:13:26,320 --> 11:13:29,840
happen and there specific incarnations

17828
11:13:28,000 --> 11:13:32,000
of what are generally called buffer

17829
11:13:29,840 --> 11:13:33,640
overflows a buffer like in the YouTube

17830
11:13:32,000 --> 11:13:35,080
sense is just like a chunk of memory

17831
11:13:33,640 --> 11:13:37,080
that in the case of YouTube stores like

17832
11:13:35,080 --> 11:13:38,840
the next few seconds or minutes of video

17833
11:13:37,080 --> 11:13:40,520
but generally speaking a buffer is just

17834
11:13:38,840 --> 11:13:42,640
a chunk of memory that the computer is

17835
11:13:40,520 --> 11:13:44,755
using for some purpose be it the stack

17836
11:13:42,640 --> 11:13:46,960
be it the Heap be it an array in the

17837
11:13:44,756 --> 11:13:48,880
computer and so buffer overflows are

17838
11:13:46,960 --> 11:13:52,200
what happens when you just have logical

17839
11:13:48,880 --> 11:13:53,960
bugs in your code but with these

17840
11:13:52,200 --> 11:13:56,240
Primitives now in mind we wanted to

17841
11:13:53,960 --> 11:13:58,000
conclude with a final Revelations and

17842
11:13:56,240 --> 11:13:59,960
that's how some functions like these

17843
11:13:58,000 --> 11:14:01,720
here work the other thing in the cs50

17844
11:13:59,960 --> 11:14:03,680
library besides the type def for quote

17845
11:14:01,720 --> 11:14:04,916
unquote string is of course all of these

17846
11:14:03,680 --> 11:14:07,360
functions and we give you these

17847
11:14:04,916 --> 11:14:09,719
functions because honestly in C it is

17848
11:14:07,360 --> 11:14:12,436
hard it's annoying it's painful it's

17849
11:14:09,720 --> 11:14:14,400
difficult to get user input correctly

17850
11:14:12,436 --> 11:14:16,276
it's very easy when you don't know how

17851
11:14:14,400 --> 11:14:18,360
much how much the humans going to type

17852
11:14:16,276 --> 11:14:20,320
to write buggy code when it comes to it

17853
11:14:18,360 --> 11:14:21,960
and indeed it's really hard to store it

17854
11:14:20,320 --> 11:14:24,200
correctly without accidentally having

17855
11:14:21,960 --> 11:14:26,596
some kind of buffer overflow so for

17856
11:14:24,200 --> 11:14:27,640
instance let me show you a program here

17857
11:14:26,596 --> 11:14:29,360
I'm going to go ahead and write this one

17858
11:14:27,640 --> 11:14:31,720
from scratch so let me go ahead and open

17859
11:14:29,360 --> 11:14:33,360
a file called get. C where I'm going to

17860
11:14:31,720 --> 11:14:35,400
go ahead and mimic the idea of getting

17861
11:14:33,360 --> 11:14:37,080
integers manually without the cs50

17862
11:14:35,400 --> 11:14:39,840
library so I'm going to include standard

17863
11:14:37,080 --> 11:14:41,800
io. only I'm going to Define main as not

17864
11:14:39,840 --> 11:14:43,276
taking any command line arguments and

17865
11:14:41,800 --> 11:14:46,040
then I'm going to do something like this

17866
11:14:43,276 --> 11:14:47,640
give me a variable x with no value yet

17867
11:14:46,040 --> 11:14:49,520
and normally I would do something like

17868
11:14:47,640 --> 11:14:51,520
get int but let me take that away no

17869
11:14:49,520 --> 11:14:54,320
more training wheels for get int either

17870
11:14:51,520 --> 11:14:57,755
so let me just Define the int X let me

17871
11:14:54,320 --> 11:14:59,756
then just print out something like uh a

17872
11:14:57,756 --> 11:15:01,276
prompt and I'll just do x c just to make

17873
11:14:59,756 --> 11:15:03,400
it obvious to the human what we're

17874
11:15:01,276 --> 11:15:05,916
waiting for and now I'm going to use a

17875
11:15:03,400 --> 11:15:07,960
builtin c function to get user input I'm

17876
11:15:05,916 --> 11:15:09,640
going to call a function called scan F

17877
11:15:07,960 --> 11:15:11,799
which sort of scans the user's keyboard

17878
11:15:09,640 --> 11:15:13,436
for input I'm going to scan it for an

17879
11:15:11,800 --> 11:15:16,000
integer so just like print F I'm going

17880
11:15:13,436 --> 11:15:18,436
to use percent I because I expect an INT

17881
11:15:16,000 --> 11:15:20,880
and then I want to tell scanf where to

17882
11:15:18,436 --> 11:15:23,400
put the human's integer from the

17883
11:15:20,880 --> 11:15:25,799
keyboard it is not correct though to say

17884
11:15:23,400 --> 11:15:28,400
x because if I say x I run into the same

17885
11:15:25,800 --> 11:15:30,160
swap problem scanf no function can

17886
11:15:28,400 --> 11:15:32,040
change the value of X unless I pass it

17887
11:15:30,160 --> 11:15:34,960
not by value but

17888
11:15:32,040 --> 11:15:37,520
by reference so we're back to our

17889
11:15:34,960 --> 11:15:40,560
Ampersand friend and now it has like a a

17890
11:15:37,520 --> 11:15:42,596
treasure map to the actual location of X

17891
11:15:40,560 --> 11:15:43,880
and can therefore change it and so now

17892
11:15:42,596 --> 11:15:45,640
at the very end of this program let me

17893
11:15:43,880 --> 11:15:49,000
do something simple like let's just go

17894
11:15:45,640 --> 11:15:52,200
ahead and print out with print F uh the

17895
11:15:49,000 --> 11:15:54,756
value of x using percent I as always

17896
11:15:52,200 --> 11:15:56,479
plugging in X not Ampersand X this is

17897
11:15:54,756 --> 11:15:59,240
now week one stuff I want to print the

17898
11:15:56,480 --> 11:16:00,880
actual integer value of x so the only

17899
11:15:59,240 --> 11:16:03,200
change here is that instead of using get

17900
11:16:00,880 --> 11:16:06,200
in I'm now using this new function that

17901
11:16:03,200 --> 11:16:09,320
as of today exists called scanf so let

17902
11:16:06,200 --> 11:16:11,916
me go ahead and run get make get to

17903
11:16:09,320 --> 11:16:15,116
create this program doget and let's go

17904
11:16:11,916 --> 11:16:18,079
ahead and type in a value for x 50 enter

17905
11:16:15,116 --> 11:16:20,240
and it just works so it turns out get in

17906
11:16:18,080 --> 11:16:21,916
is pretty simple to implement however

17907
11:16:20,240 --> 11:16:24,360
notice what does not work if I type in

17908
11:16:21,916 --> 11:16:27,479
cat for instance cat gets converted to

17909
11:16:24,360 --> 11:16:29,840
zero and meanwhile get in recall will

17910
11:16:27,480 --> 11:16:31,720
reprompt the user if a human not type an

17911
11:16:29,840 --> 11:16:33,159
actual integer you get automatically

17912
11:16:31,720 --> 11:16:35,360
reprompt so that's one of the features

17913
11:16:33,160 --> 11:16:37,160
we for cs50 added to get in just to make

17914
11:16:35,360 --> 11:16:38,960
your programs more user friendly but

17915
11:16:37,160 --> 11:16:40,720
otherwise get in is pretty

17916
11:16:38,960 --> 11:16:43,360
straightforward to re-implement using

17917
11:16:40,720 --> 11:16:45,276
scanf unfortunately that's not true for

17918
11:16:43,360 --> 11:16:47,400
Strings because how do you know when you

17919
11:16:45,276 --> 11:16:49,040
write your code what word the human's

17920
11:16:47,400 --> 11:16:51,800
going to eventually type in how long

17921
11:16:49,040 --> 11:16:53,520
they're greeting like high is if it's uh

17922
11:16:51,800 --> 11:16:54,840
if their name is David or Carter or

17923
11:16:53,520 --> 11:16:57,240
anything else you just don't know in

17924
11:16:54,840 --> 11:16:59,679
advance how much memory you need so how

17925
11:16:57,240 --> 11:17:02,436
might we do this in with string well let

17926
11:16:59,680 --> 11:17:03,916
me go ahead and declare a string s

17927
11:17:02,436 --> 11:17:06,320
although you know what there's no cs50

17928
11:17:03,916 --> 11:17:09,040
Library so we do Char star s today

17929
11:17:06,320 --> 11:17:12,276
instead and that gives me not a string

17930
11:17:09,040 --> 11:17:14,360
per se but a pointer that will Point

17931
11:17:12,276 --> 11:17:16,320
presumably to a string ideally I would

17932
11:17:14,360 --> 11:17:18,400
use this get string but again we've

17933
11:17:16,320 --> 11:17:20,640
taken that training wheel away so now

17934
11:17:18,400 --> 11:17:22,360
that I have a pointer s suppose I prompt

17935
11:17:20,640 --> 11:17:24,916
the human for a value for S just like

17936
11:17:22,360 --> 11:17:27,720
before let me use scan F now and tell

17937
11:17:24,916 --> 11:17:29,880
the user that I expect to read a string

17938
11:17:27,720 --> 11:17:33,560
percent s from the keyboard

17939
11:17:29,880 --> 11:17:35,880
uh and store it in s now this is subtle

17940
11:17:33,560 --> 11:17:38,399
I don't technically need an Amper sand

17941
11:17:35,880 --> 11:17:40,200
here even though I did for an INT and I

17942
11:17:38,400 --> 11:17:42,640
would for a float and a double and a

17943
11:17:40,200 --> 11:17:44,755
long and a bull and a Char why do I not

17944
11:17:42,640 --> 11:17:47,320
need an Amper sand in this story to pass

17945
11:17:44,756 --> 11:17:50,880
by

17946
11:17:47,320 --> 11:17:52,720
reference because s is it's already an

17947
11:17:50,880 --> 11:17:55,399
address again strings are just special

17948
11:17:52,720 --> 11:17:57,080
strings now are always addresses so you

17949
11:17:55,400 --> 11:17:58,640
don't need to additionally add an Amper

17950
11:17:57,080 --> 11:18:00,480
sand here that's the only subtle

17951
11:17:58,640 --> 11:18:01,840
difference here but now if I go ahead

17952
11:18:00,480 --> 11:18:04,596
and print out at the very end what the

17953
11:18:01,840 --> 11:18:07,399
value of s is using percent S as before

17954
11:18:04,596 --> 11:18:09,640
this program looks like it's almost the

17955
11:18:07,400 --> 11:18:13,400
same as the int version but let's do

17956
11:18:09,640 --> 11:18:14,880
make get and okay so this is not good

17957
11:18:13,400 --> 11:18:16,400
all right so it doesn't like an

17958
11:18:14,880 --> 11:18:18,276
initialized value so let me make it

17959
11:18:16,400 --> 11:18:19,520
happy I said earlier to always

17960
11:18:18,276 --> 11:18:21,040
initialize my variable so let's

17961
11:18:19,520 --> 11:18:22,435
initialize it to null so that at least

17962
11:18:21,040 --> 11:18:25,560
something is there that's your good

17963
11:18:22,436 --> 11:18:27,320
default value nowadays now if I do doget

17964
11:18:25,560 --> 11:18:30,115
now we're good and let me type in

17965
11:18:27,320 --> 11:18:32,596
something like cat

17966
11:18:30,116 --> 11:18:33,956
okay cat is not X well let me try

17967
11:18:32,596 --> 11:18:37,159
another word maybe it's just cat is

17968
11:18:33,956 --> 11:18:38,880
wrong dog okay let me try David it just

17969
11:18:37,160 --> 11:18:42,360
doesn't seem to be working moreover it's

17970
11:18:38,880 --> 11:18:45,520
printing it as a zero what logically

17971
11:18:42,360 --> 11:18:47,276
though is the bug here scanf worked a

17972
11:18:45,520 --> 11:18:48,799
moment ago for integers but it's not

17973
11:18:47,276 --> 11:18:51,159
working for Strings and it seems to be

17974
11:18:48,800 --> 11:18:52,040
forgetting C A it's forgetting dog it's

17975
11:18:51,160 --> 11:18:53,880
forgetting

17976
11:18:52,040 --> 11:18:56,916
David

17977
11:18:53,880 --> 11:18:59,276
why what's Happening

17978
11:18:56,916 --> 11:19:00,916
Here think back to our yellow pictures

17979
11:18:59,276 --> 11:19:03,596
of

17980
11:19:00,916 --> 11:19:06,079
memory when I

17981
11:19:03,596 --> 11:19:08,320
yeah it might be reading just the null

17982
11:19:06,080 --> 11:19:10,480
itself because s is being initialized to

17983
11:19:08,320 --> 11:19:12,680
null and what step have I forgotten from

17984
11:19:10,480 --> 11:19:15,520
just like a few minutes ago what did I

17985
11:19:12,680 --> 11:19:18,680
not actually request of the computer

17986
11:19:15,520 --> 11:19:21,399
like actual memory to store the C A the

17987
11:19:18,680 --> 11:19:23,436
dog the d v d right there's nowhere have

17988
11:19:21,400 --> 11:19:26,160
I asked the computer for some amount of

17989
11:19:23,436 --> 11:19:28,480
memory and so technically it might be

17990
11:19:26,160 --> 11:19:30,640
reading it into some garbage location

17991
11:19:28,480 --> 11:19:32,720
and that's really the problem here S is

17992
11:19:30,640 --> 11:19:34,640
initialized to null now and so in fact

17993
11:19:32,720 --> 11:19:36,160
it is printing zero as null but I'm not

17994
11:19:34,640 --> 11:19:38,596
seeing any of the other letters because

17995
11:19:36,160 --> 11:19:40,840
there was nowhere to put them C A do D

17996
11:19:38,596 --> 11:19:42,799
ID because I didn't ask for three bytes

17997
11:19:40,840 --> 11:19:44,435
four bytes five bytes 100 bytes there's

17998
11:19:42,800 --> 11:19:46,800
no use of malok there's no use of an

17999
11:19:44,436 --> 11:19:49,360
array there's no memory allocated for

18000
11:19:46,800 --> 11:19:51,116
anything other than the pointer itself

18001
11:19:49,360 --> 11:19:53,200
and this is where honestly life gets

18002
11:19:51,116 --> 11:19:54,956
hard with scanf like I could solve this

18003
11:19:53,200 --> 11:19:56,880
problem in a couple of ways let me go

18004
11:19:54,956 --> 11:19:59,040
ahead and do this instead of declaring s

18005
11:19:56,880 --> 11:20:02,799
to be a pointer let me declare s to

18006
11:19:59,040 --> 11:20:04,880
actually be a an array of four chars and

18007
11:20:02,800 --> 11:20:08,596
now let me go ahead and recompile the

18008
11:20:04,880 --> 11:20:12,115
code so make get doget and I'll type in

18009
11:20:08,596 --> 11:20:14,115
cat now that now works why well I'm

18010
11:20:12,116 --> 11:20:16,160
allocating an explicit array of size

18011
11:20:14,116 --> 11:20:18,680
four enough for a one two three letters

18012
11:20:16,160 --> 11:20:20,800
plus a null character here's where to

18013
11:20:18,680 --> 11:20:22,596
someone's question earlier it turns out

18014
11:20:20,800 --> 11:20:25,400
then in some context you can treat

18015
11:20:22,596 --> 11:20:26,720
arrays as though they are Pointers

18016
11:20:25,400 --> 11:20:28,800
themselves see we'll sort of do the

18017
11:20:26,720 --> 11:20:30,956
conversion for you but for now just

18018
11:20:28,800 --> 11:20:33,720
assume that s is just an array of size

18019
11:20:30,956 --> 11:20:35,400
four and if you pass it into to scanf

18020
11:20:33,720 --> 11:20:37,320
that's like a treasure map that leads to

18021
11:20:35,400 --> 11:20:41,640
those four bytes so scanf can now

18022
11:20:37,320 --> 11:20:43,800
successfully fill it with c a d o but

18023
11:20:41,640 --> 11:20:47,276
but let's try this again let's type in

18024
11:20:43,800 --> 11:20:49,080
David and here okay we got lucky but I

18025
11:20:47,276 --> 11:20:51,115
technically touched memory that I should

18026
11:20:49,080 --> 11:20:52,360
not and in fact if I typed in a long

18027
11:20:51,116 --> 11:20:54,800
enough string and I don't think I could

18028
11:20:52,360 --> 11:20:57,000
do it very easily like by without typing

18029
11:20:54,800 --> 11:20:59,200
this thousands or hundreds of times

18030
11:20:57,000 --> 11:21:01,596
still okay but you'll notice that it's

18031
11:20:59,200 --> 11:21:03,079
forgotten the rest of it now right so

18032
11:21:01,596 --> 11:21:04,240
somewhere we went beyond the boundary of

18033
11:21:03,080 --> 11:21:06,240
the array and we just don't have enough

18034
11:21:04,240 --> 11:21:07,436
storage space for that entire thing so

18035
11:21:06,240 --> 11:21:09,159
what do you do in your program if you

18036
11:21:07,436 --> 11:21:10,956
don't know how long the person's name or

18037
11:21:09,160 --> 11:21:14,800
the the the animal name is going to be

18038
11:21:10,956 --> 11:21:16,080
what do you do 40 400 4,000 40,000 like

18039
11:21:14,800 --> 11:21:17,956
at some point you have to draw a line in

18040
11:21:16,080 --> 11:21:20,200
the sand and that's why like getting

18041
11:21:17,956 --> 11:21:22,880
user input is so annoying in a language

18042
11:21:20,200 --> 11:21:25,320
like C and that's why get string exists

18043
11:21:22,880 --> 11:21:27,360
what we do if you're curious is we look

18044
11:21:25,320 --> 11:21:29,560
at the user's input and we take baby

18045
11:21:27,360 --> 11:21:31,200
steps we look at it one character at a

18046
11:21:29,560 --> 11:21:33,240
time and every time we see another

18047
11:21:31,200 --> 11:21:34,799
character we actually call malok again

18048
11:21:33,240 --> 11:21:36,320
and say no I need more than one bite I

18049
11:21:34,800 --> 11:21:38,080
need two oh wait they typed in three

18050
11:21:36,320 --> 11:21:39,680
letters I need three instead of two oh I

18051
11:21:38,080 --> 11:21:41,640
need four instead of two and we have

18052
11:21:39,680 --> 11:21:43,480
this crazy loop essentially that keeps

18053
11:21:41,640 --> 11:21:45,200
asking for more and more memory but by

18054
11:21:43,480 --> 11:21:47,116
taking baby steps and honestly if you

18055
11:21:45,200 --> 11:21:48,840
all had to do that in week one my God

18056
11:21:47,116 --> 11:21:50,800
like we couldn't even write hello world

18057
11:21:48,840 --> 11:21:52,640
anymore and so that's why these training

18058
11:21:50,800 --> 11:21:54,276
wheels exist at least early on and

18059
11:21:52,640 --> 11:21:56,916
that's why in higher level languages

18060
11:21:54,276 --> 11:21:59,000
like in uh python you don't have to do

18061
11:21:56,916 --> 11:22:01,560
this at all it just works as you'd

18062
11:21:59,000 --> 11:22:03,320
expect so what more can we do well

18063
11:22:01,560 --> 11:22:05,756
you'll see in problems set for this

18064
11:22:03,320 --> 11:22:08,520
coming week if I open up an example like

18065
11:22:05,756 --> 11:22:10,720
this phone book. C you'll see that you

18066
11:22:08,520 --> 11:22:12,479
can manipulate files now that you have a

18067
11:22:10,720 --> 11:22:15,240
vocabulary for pointers it's going to be

18068
11:22:12,480 --> 11:22:17,160
new quickly but here we have an example

18069
11:22:15,240 --> 11:22:19,040
of how I have a program using some

18070
11:22:17,160 --> 11:22:20,596
familiar libraries here but as I claim

18071
11:22:19,040 --> 11:22:22,680
in my comment this saves names and

18072
11:22:20,596 --> 11:22:24,680
numbers to a CSV file all of my examples

18073
11:22:22,680 --> 11:22:26,240
thus far I type in some words I type in

18074
11:22:24,680 --> 11:22:27,596
some names and some phone numbers and

18075
11:22:26,240 --> 11:22:29,276
they disappear because we only store

18076
11:22:27,596 --> 11:22:31,756
them in memory but if you want to store

18077
11:22:29,276 --> 11:22:32,840
data in like a CSV file comma separated

18078
11:22:31,756 --> 11:22:35,040
values which is like a simple

18079
11:22:32,840 --> 11:22:36,799
spreadsheet like Excel and apple numbers

18080
11:22:35,040 --> 11:22:38,276
and Google Sheets can open you can

18081
11:22:36,800 --> 11:22:40,756
actually do this yourself so just as a

18082
11:22:38,276 --> 11:22:42,756
teaser for this week here on line n I'm

18083
11:22:40,756 --> 11:22:45,040
using a new data type not a cs50 thing

18084
11:22:42,756 --> 11:22:46,720
this is a c thing called file but if you

18085
11:22:45,040 --> 11:22:49,276
want to manipulate files you need to use

18086
11:22:46,720 --> 11:22:51,360
addresses that is pointers so here is me

18087
11:22:49,276 --> 11:22:53,436
creating a variable called file that's

18088
11:22:51,360 --> 11:22:55,276
going to point to an actual file on the

18089
11:22:53,436 --> 11:22:57,560
hard drive on the server or your Mac or

18090
11:22:55,276 --> 11:22:59,560
PC fop is going to be a new function

18091
11:22:57,560 --> 11:23:01,680
you'll use that will open open a file

18092
11:22:59,560 --> 11:23:04,000
and it will return effectively a pointer

18093
11:23:01,680 --> 11:23:05,956
there to in memory the file name I want

18094
11:23:04,000 --> 11:23:08,160
to open is phonebook .csv and in this

18095
11:23:05,956 --> 11:23:09,756
example it's going to be uh a pen mode

18096
11:23:08,160 --> 11:23:11,840
it will keep allowing me to add more and

18097
11:23:09,756 --> 11:23:13,360
more names and numbers to this file

18098
11:23:11,840 --> 11:23:14,640
here's some old get string stuff because

18099
11:23:13,360 --> 11:23:16,916
I'm not going to reinvent get string

18100
11:23:14,640 --> 11:23:18,756
with scan F but down here is a slightly

18101
11:23:16,916 --> 11:23:20,479
new function it's not print F but

18102
11:23:18,756 --> 11:23:22,240
fprintf and it turns out it's very easy

18103
11:23:20,480 --> 11:23:24,240
to print things not to the screen but to

18104
11:23:22,240 --> 11:23:26,320
a file with fprintf and it takes an

18105
11:23:24,240 --> 11:23:28,200
additional argument instead of starting

18106
11:23:26,320 --> 11:23:30,360
with the quoted string you'll have to

18107
11:23:28,200 --> 11:23:32,115
like say what file you want to write to

18108
11:23:30,360 --> 11:23:34,840
and fr print F we'll figure out how to

18109
11:23:32,116 --> 11:23:36,840
get the uh the bits into that file

18110
11:23:34,840 --> 11:23:38,956
passing in something like name comma

18111
11:23:36,840 --> 11:23:41,956
number so if I run this somewhat quickly

18112
11:23:38,956 --> 11:23:45,680
here let me do this let me pre-create a

18113
11:23:41,956 --> 11:23:47,479
file called uh phonebook do CSV and in

18114
11:23:45,680 --> 11:23:49,756
phone book. CSV I'm going to create a

18115
11:23:47,480 --> 11:23:51,116
temporary row here name comma number

18116
11:23:49,756 --> 11:23:53,800
just so that there's something in this

18117
11:23:51,116 --> 11:23:56,756
file and now let me go ahead and do this

18118
11:23:53,800 --> 11:23:58,560
and split my screen here if I have

18119
11:23:56,756 --> 11:24:00,680
phonebook.com

18120
11:23:58,560 --> 11:24:03,756
and phone book. C on the left let me

18121
11:24:00,680 --> 11:24:06,160
compile make phonebook which is the C

18122
11:24:03,756 --> 11:24:07,596
version phonebook and now I'm prompted

18123
11:24:06,160 --> 11:24:10,916
for a name and a number so I'll type in

18124
11:24:07,596 --> 11:24:16,560
David and then for instance + one

18125
11:24:10,916 --> 11:24:18,640
949 uh what is it 468 275 o enter oh

18126
11:24:16,560 --> 11:24:20,956
damn it bug uh pretend that didn't

18127
11:24:18,640 --> 11:24:23,436
happen I forgot to hit enter in the file

18128
11:24:20,956 --> 11:24:29,436
so let's do this again if I run the

18129
11:24:23,436 --> 11:24:34,000
program Again David and plus one 94 9

18130
11:24:29,436 --> 11:24:37,916
468 2750 enter it's been saved now to

18131
11:24:34,000 --> 11:24:42,200
the file and if I close this file and I

18132
11:24:37,916 --> 11:24:42,200
reopen code of phonebook.com

18133
11:24:48,756 --> 11:24:53,640
or the like and I've actually created an

18134
11:24:51,640 --> 11:24:54,916
actual CSV file uh if you're smiling

18135
11:24:53,640 --> 11:24:56,276
because I keep repeating my phone number

18136
11:24:54,916 --> 11:24:58,000
out loud I would encourage you to call

18137
11:24:56,276 --> 11:24:59,720
or text that number sometime it might

18138
11:24:58,000 --> 11:25:02,040
very well well be a an Easter egg of

18139
11:24:59,720 --> 11:25:04,596
source but via these functions here do

18140
11:25:02,040 --> 11:25:07,040
we have now the ability to write files

18141
11:25:04,596 --> 11:25:08,799
uh input and output and among the goals

18142
11:25:07,040 --> 11:25:10,436
then for this week as we'll see are to

18143
11:25:08,800 --> 11:25:12,116
actually play with images in the spirit

18144
11:25:10,436 --> 11:25:13,596
of something like Instagram filters or

18145
11:25:12,116 --> 11:25:16,200
the like and we'll introduce you for

18146
11:25:13,596 --> 11:25:17,720
instance to a file format called bmps

18147
11:25:16,200 --> 11:25:20,320
which to come full circle to the start

18148
11:25:17,720 --> 11:25:21,720
of class are just maps of bits but more

18149
11:25:20,320 --> 11:25:23,916
than just single bits for white and

18150
11:25:21,720 --> 11:25:25,560
black but rather colorful patterns as

18151
11:25:23,916 --> 11:25:26,916
well and we'll give you images like this

18152
11:25:25,560 --> 11:25:28,840
of the week's Bridge here across the

18153
11:25:26,916 --> 11:25:30,880
river at Harvard and you've run

18154
11:25:28,840 --> 11:25:33,079
after writing your own code in C and

18155
11:25:30,880 --> 11:25:34,520
understanding how the data stored in the

18156
11:25:33,080 --> 11:25:36,276
computer's memory you'll be able to

18157
11:25:34,520 --> 11:25:38,596
apply your own Instagram like filters to

18158
11:25:36,276 --> 11:25:40,596
make things uh grayscale instead or

18159
11:25:38,596 --> 11:25:41,956
sepia in this case you can even flip the

18160
11:25:40,596 --> 11:25:44,520
bits around so that the thing is a

18161
11:25:41,956 --> 11:25:45,956
mirror image you can blur things further

18162
11:25:44,520 --> 11:25:47,680
or if you really are feeling more

18163
11:25:45,956 --> 11:25:50,159
comfortable you can even write code that

18164
11:25:47,680 --> 11:25:52,276
finds the edges of the image and creates

18165
11:25:50,160 --> 11:25:54,560
works of art like these so all that in

18166
11:25:52,276 --> 11:25:56,840
more in problem set four we will see you

18167
11:25:54,560 --> 11:25:56,840
next

18168
11:25:57,200 --> 11:26:00,200
time

18169
11:26:01,690 --> 11:26:05,599
[Music]

18170
11:26:11,580 --> 11:26:19,910
[Music]

18171
11:26:36,200 --> 11:26:49,168
[Music]

18172
11:26:51,740 --> 11:26:54,839
[Music]

18173
11:26:59,340 --> 11:27:02,409
[Music]

18174
11:27:08,690 --> 11:27:11,800
[Music]

18175
11:27:18,630 --> 11:27:31,988
[Music]

18176
11:27:46,116 --> 11:27:51,720
all right this is cs50 and this is week

18177
11:27:49,200 --> 11:27:54,596
five which is going to be our last week

18178
11:27:51,720 --> 11:27:57,000
in see uh but what that means is that

18179
11:27:54,596 --> 11:27:58,840
we'll have

18180
11:27:57,000 --> 11:28:00,840
okay

18181
11:27:58,840 --> 11:28:02,276
but with this week with last week and

18182
11:28:00,840 --> 11:28:04,320
really all of the weeks prior have you

18183
11:28:02,276 --> 11:28:05,680
been hopefully acquiring if slowly and

18184
11:28:04,320 --> 11:28:07,200
with some challenge like some

18185
11:28:05,680 --> 11:28:08,840
fundamental building blocks that are

18186
11:28:07,200 --> 11:28:10,596
still going to underly everything we

18187
11:28:08,840 --> 11:28:12,799
continue doing in the semester even as

18188
11:28:10,596 --> 11:28:14,115
we transition to so-called higher level

18189
11:28:12,800 --> 11:28:16,200
languages next week indeed we'll

18190
11:28:14,116 --> 11:28:18,200
introduce python a very popular language

18191
11:28:16,200 --> 11:28:20,000
that does not have pointers does not

18192
11:28:18,200 --> 11:28:21,360
have memory management at this very low

18193
11:28:20,000 --> 11:28:23,480
level but that's really just because

18194
11:28:21,360 --> 11:28:24,840
someone else wrote the code that will do

18195
11:28:23,480 --> 11:28:26,596
that for you and it's going to make our

18196
11:28:24,840 --> 11:28:28,596
lives easier because it means when you

18197
11:28:26,596 --> 11:28:30,479
want to solve a problem concept up here

18198
11:28:28,596 --> 11:28:31,840
to just get real work done or build

18199
11:28:30,480 --> 11:28:33,880
something amazing you don't have to

18200
11:28:31,840 --> 11:28:35,755
really get into the same weeds as we

18201
11:28:33,880 --> 11:28:38,276
have been deliberately this week and now

18202
11:28:35,756 --> 11:28:40,116
last but the goal ultimately is that you

18203
11:28:38,276 --> 11:28:42,200
better understand and can better harness

18204
11:28:40,116 --> 11:28:44,320
than all that a computer can do even in

18205
11:28:42,200 --> 11:28:46,039
those higher level languages So today

18206
11:28:44,320 --> 11:28:47,880
we're going to focus particularly on

18207
11:28:46,040 --> 11:28:49,800
data structures how you might structure

18208
11:28:47,880 --> 11:28:52,240
your data in memory which really amounts

18209
11:28:49,800 --> 11:28:54,560
to building things digitally stitching

18210
11:28:52,240 --> 11:28:56,200
together ideas and Concepts in memory

18211
11:28:54,560 --> 11:28:58,000
using this new building block from last

18212
11:28:56,200 --> 11:29:00,360
week which of course are these pointers

18213
11:28:58,000 --> 11:29:02,520
pointers allow you to store addresses in

18214
11:29:00,360 --> 11:29:04,240
memory like in variables but with those

18215
11:29:02,520 --> 11:29:06,200
simple addresses we can sort of leave

18216
11:29:04,240 --> 11:29:08,916
these breadcrumbs we can point from here

18217
11:29:06,200 --> 11:29:10,719
to there and we can conceptually stitch

18218
11:29:08,916 --> 11:29:12,276
pieces of data together but there's

18219
11:29:10,720 --> 11:29:13,800
going to be different ways of doing that

18220
11:29:12,276 --> 11:29:16,159
and today we'll focus first on what's

18221
11:29:13,800 --> 11:29:17,916
generally known as an abstract data type

18222
11:29:16,160 --> 11:29:19,720
and similar to a type in C more

18223
11:29:17,916 --> 11:29:21,200
generally it does actually have some

18224
11:29:19,720 --> 11:29:23,080
properties in it but the underlying

18225
11:29:21,200 --> 11:29:25,560
implementation details of an abstract

18226
11:29:23,080 --> 11:29:27,160
data type are ultimately up to you that

18227
11:29:25,560 --> 11:29:29,640
is to say an abstract data type can

18228
11:29:27,160 --> 11:29:31,956
represent one thing and can do something

18229
11:29:29,640 --> 11:29:34,080
but how you implement it allows you some

18230
11:29:31,956 --> 11:29:35,479
discretion underneath the hood so for

18231
11:29:34,080 --> 11:29:38,840
instance in the world of computer

18232
11:29:35,480 --> 11:29:40,720
science a q is actually a technical term

18233
11:29:38,840 --> 11:29:42,956
this is a type of data structure that we

18234
11:29:40,720 --> 11:29:45,680
could theoretically build in code in C

18235
11:29:42,956 --> 11:29:47,479
or really any other language but a q has

18236
11:29:45,680 --> 11:29:49,360
properties just like cu's in the real

18237
11:29:47,480 --> 11:29:51,596
world for instance if you've ever lined

18238
11:29:49,360 --> 11:29:53,756
up for something to get food in a uh and

18239
11:29:51,596 --> 11:29:55,680
get food in a restaurant or go into a

18240
11:29:53,756 --> 11:29:58,160
store or wait for the airport to clear

18241
11:29:55,680 --> 11:30:00,200
you well you've lined up in a queue Q

18242
11:29:58,160 --> 11:30:02,560
being some sort of line but what's

18243
11:30:00,200 --> 11:30:06,276
noteworthy about Q's are specific

18244
11:30:02,560 --> 11:30:08,399
properties they are first in first out

18245
11:30:06,276 --> 11:30:10,159
data structures either virtually or in

18246
11:30:08,400 --> 11:30:12,160
the human world which is to say the

18247
11:30:10,160 --> 11:30:14,080
first person in the line should ideally

18248
11:30:12,160 --> 11:30:15,320
be served first at the restaurant or the

18249
11:30:14,080 --> 11:30:17,320
first person in the line should get

18250
11:30:15,320 --> 11:30:19,520
through airport security first by

18251
11:30:17,320 --> 11:30:21,436
contrast if it weren't first in first

18252
11:30:19,520 --> 11:30:23,520
out you can imagine how frustrated you

18253
11:30:21,436 --> 11:30:24,916
would be if you have this sort of

18254
11:30:23,520 --> 11:30:26,435
inherent unfairness in fact if you've

18255
11:30:24,916 --> 11:30:28,159
ever been in line at a store a

18256
11:30:26,436 --> 11:30:29,720
supermarket or the like and all of a

18257
11:30:28,160 --> 11:30:31,520
sudden they maybe open a new line and

18258
11:30:29,720 --> 11:30:33,436
now the person behind you gets to kind

18259
11:30:31,520 --> 11:30:35,276
of cut ahead and go forward that's

18260
11:30:33,436 --> 11:30:37,480
because they've broken the concept of

18261
11:30:35,276 --> 11:30:39,200
the cube so it has this inherent

18262
11:30:37,480 --> 11:30:41,800
potential for unfairness unless you

18263
11:30:39,200 --> 11:30:43,560
maintain this first in first out

18264
11:30:41,800 --> 11:30:45,800
property this would be true too for like

18265
11:30:43,560 --> 11:30:47,560
a to-do list just for productivity sake

18266
11:30:45,800 --> 11:30:50,116
if you're in the habit on paper or

18267
11:30:47,560 --> 11:30:51,320
virtually making a to-do list ideally

18268
11:30:50,116 --> 11:30:53,116
you probably want to go through that

18269
11:30:51,320 --> 11:30:55,116
list top to bottom so that you actually

18270
11:30:53,116 --> 11:30:57,000
get the first stuff you thought of done

18271
11:30:55,116 --> 11:30:59,360
first rather than always focusing on

18272
11:30:57,000 --> 11:31:02,116
your most recent thought now within the

18273
11:30:59,360 --> 11:31:04,400
world of Q's there's generally two

18274
11:31:02,116 --> 11:31:06,240
operations two functions if you will

18275
11:31:04,400 --> 11:31:08,800
that any Q would have either in the real

18276
11:31:06,240 --> 11:31:10,436
world or in the virtual NQ is usually

18277
11:31:08,800 --> 11:31:12,436
the technical term to mean adding

18278
11:31:10,436 --> 11:31:14,956
something to a q but specifically it

18279
11:31:12,436 --> 11:31:16,680
means adding it to the end of the que so

18280
11:31:14,956 --> 11:31:18,756
that someone isn't cutting in line for

18281
11:31:16,680 --> 11:31:20,680
instance to go up front and then DQ is

18282
11:31:18,756 --> 11:31:22,520
just the opposite when it's time for the

18283
11:31:20,680 --> 11:31:24,116
first person in line to be served the

18284
11:31:22,520 --> 11:31:26,840
time for the first person in line to go

18285
11:31:24,116 --> 11:31:29,520
through security they are dced so to

18286
11:31:26,840 --> 11:31:31,435
speak so technical concept ultimately as

18287
11:31:29,520 --> 11:31:33,240
it's implemented in code but it's really

18288
11:31:31,436 --> 11:31:35,480
just a real world concept and these are

18289
11:31:33,240 --> 11:31:38,240
in contrast to another abstract data

18290
11:31:35,480 --> 11:31:40,800
type that we might call a stack and a

18291
11:31:38,240 --> 11:31:42,756
stack much like a stack of trays in the

18292
11:31:40,800 --> 11:31:44,560
cafeteria has sort of fundamentally

18293
11:31:42,756 --> 11:31:46,400
different properties you can still add

18294
11:31:44,560 --> 11:31:47,756
and remove things from them but consider

18295
11:31:46,400 --> 11:31:49,720
what happens whenever they clean all the

18296
11:31:47,756 --> 11:31:52,160
trays in the cafeteria or the dining

18297
11:31:49,720 --> 11:31:53,560
hall they put one of the trays down here

18298
11:31:52,160 --> 11:31:55,276
and then the next one on top of it and

18299
11:31:53,560 --> 11:31:57,320
then the next one on top of it it it and

18300
11:31:55,276 --> 11:31:59,240
so forth but of course which tray do you

18301
11:31:57,320 --> 11:32:01,080
presume presumably take as a user of

18302
11:31:59,240 --> 11:32:04,240
that physical

18303
11:32:01,080 --> 11:32:05,320
stack the top one presumably right like

18304
11:32:04,240 --> 11:32:06,840
you're not going to fuss down here and

18305
11:32:05,320 --> 11:32:09,240
try to pull one out and so that would

18306
11:32:06,840 --> 11:32:12,079
seem to have an opposite property lifo

18307
11:32:09,240 --> 11:32:14,200
last in first out is what characterizes

18308
11:32:12,080 --> 11:32:15,596
something like a stack and that just

18309
11:32:14,200 --> 11:32:17,360
makes sense certainly in the physical

18310
11:32:15,596 --> 11:32:18,756
world of stacking all of those cafeteria

18311
11:32:17,360 --> 11:32:21,916
trays because it just makes more sense

18312
11:32:18,756 --> 11:32:24,320
to grab the most recently added one the

18313
11:32:21,916 --> 11:32:26,276
last added one first and at least in

18314
11:32:24,320 --> 11:32:28,276
that context the trays don't necessarily

18315
11:32:26,276 --> 11:32:29,680
care what order they're using used in

18316
11:32:28,276 --> 11:32:31,880
but even then you could imagine that

18317
11:32:29,680 --> 11:32:33,840
maybe there's some old dirty nasty tray

18318
11:32:31,880 --> 11:32:35,360
at the very bottom that like never gets

18319
11:32:33,840 --> 11:32:36,956
used because you're constantly

18320
11:32:35,360 --> 11:32:38,956
replenishing the stack so there might

18321
11:32:36,956 --> 11:32:41,436
very well be side effects of these kinds

18322
11:32:38,956 --> 11:32:43,116
of features um you might be familiar

18323
11:32:41,436 --> 11:32:45,436
with using Gmail for instance or really

18324
11:32:43,116 --> 11:32:48,040
any email program what you're looking at

18325
11:32:45,436 --> 11:32:49,320
in your inbox is technically a stack at

18326
11:32:48,040 --> 11:32:51,436
least if you've left the defaults

18327
11:32:49,320 --> 11:32:54,000
configured why you get a new email where

18328
11:32:51,436 --> 11:32:55,916
does it end up not like five pages of

18329
11:32:54,000 --> 11:32:57,200
emails later presumably right at the top

18330
11:32:55,916 --> 11:32:58,840
and the next one's right at the top

18331
11:32:57,200 --> 11:33:00,240
right at the the top right at the top

18332
11:32:58,840 --> 11:33:01,880
and so if you're like me you're guilty

18333
11:33:00,240 --> 11:33:04,079
of eventually losing track of some

18334
11:33:01,880 --> 11:33:06,040
emails why because you've pushed so many

18335
11:33:04,080 --> 11:33:08,200
more emails onto the stack that you sort

18336
11:33:06,040 --> 11:33:10,200
of lose track of the things you got

18337
11:33:08,200 --> 11:33:11,956
earliest last in first out though is

18338
11:33:10,200 --> 11:33:13,115
maintained the most recent email you get

18339
11:33:11,956 --> 11:33:15,200
might very well be the first one you

18340
11:33:13,116 --> 11:33:17,680
reply to but that's not necessarily good

18341
11:33:15,200 --> 11:33:19,640
for responsiveness to everyone else out

18342
11:33:17,680 --> 11:33:23,240
there uh similarly if you store like all

18343
11:33:19,640 --> 11:33:25,320
of your sweaters in a stack like this uh

18344
11:33:23,240 --> 11:33:27,200
the uh like a pile of black ones below

18345
11:33:25,320 --> 11:33:28,560
which is a red and then a blue stack

18346
11:33:27,200 --> 11:33:30,079
might be perfectly fine for keeping

18347
11:33:28,560 --> 11:33:31,435
things organized it's sort of the sane

18348
11:33:30,080 --> 11:33:33,360
way to do it if you just have a shelf in

18349
11:33:31,436 --> 11:33:35,680
your dorm room or home but what's going

18350
11:33:33,360 --> 11:33:37,916
to be a side effect of using a stack to

18351
11:33:35,680 --> 11:33:42,400
store your sweaters if they're these in

18352
11:33:37,916 --> 11:33:44,680
this way as opposed to a queue

18353
11:33:42,400 --> 11:33:46,560
yeah it's harder to get the red and blue

18354
11:33:44,680 --> 11:33:48,840
one so presumably you're going to much

18355
11:33:46,560 --> 11:33:51,079
more often wear for instance if you will

18356
11:33:48,840 --> 11:33:54,320
black instead there now the operations

18357
11:33:51,080 --> 11:33:56,116
for adding things to a stack are similar

18358
11:33:54,320 --> 11:33:59,200
in spirit but just different vocabulary

18359
11:33:56,116 --> 11:34:00,400
you push something on top of a stack um

18360
11:33:59,200 --> 11:34:02,115
even though it's more like in the tray

18361
11:34:00,400 --> 11:34:03,640
world you sort of place it or rest it

18362
11:34:02,116 --> 11:34:05,840
but pushing means adding something to

18363
11:34:03,640 --> 11:34:08,520
the top of the stack and popping means

18364
11:34:05,840 --> 11:34:10,560
some removing something also from the

18365
11:34:08,520 --> 11:34:13,200
top of the stack so it's not a matter of

18366
11:34:10,560 --> 11:34:15,159
enqing at the end and deqing at the

18367
11:34:13,200 --> 11:34:17,039
beginning with a stack everything's

18368
11:34:15,160 --> 11:34:19,596
happening on top you're pushing onto the

18369
11:34:17,040 --> 11:34:21,320
top and then popping off of the top now

18370
11:34:19,596 --> 11:34:22,880
when it comes to actual code how might

18371
11:34:21,320 --> 11:34:24,756
we Implement something like this well

18372
11:34:22,880 --> 11:34:26,520
let's just focus on really how you might

18373
11:34:24,756 --> 11:34:28,360
implement the data structure itself and

18374
11:34:26,520 --> 11:34:30,039
we won't Implement any functions you

18375
11:34:28,360 --> 11:34:31,880
might implement the notion of a stack

18376
11:34:30,040 --> 11:34:34,276
like this we've seen type def before it

18377
11:34:31,880 --> 11:34:36,596
just means Define a new type of my own

18378
11:34:34,276 --> 11:34:38,916
struct means here comes a structure AKA

18379
11:34:36,596 --> 11:34:41,435
a data structure of one or more

18380
11:34:38,916 --> 11:34:43,276
variables within and let's suppose like

18381
11:34:41,436 --> 11:34:45,800
last time we've had we defined already

18382
11:34:43,276 --> 11:34:47,320
like a person data type using a separate

18383
11:34:45,800 --> 11:34:49,320
type Def and every person has like a

18384
11:34:47,320 --> 11:34:50,956
name and a number or whatever let me

18385
11:34:49,320 --> 11:34:52,840
just stipulate that person exists

18386
11:34:50,956 --> 11:34:56,400
already so here you might have to

18387
11:34:52,840 --> 11:34:58,956
implement a stack an array called people

18388
11:34:56,400 --> 11:35:02,000
of some capacity maybe it's an an array

18389
11:34:58,956 --> 11:35:04,159
of size 10 or 100 or whatever this is a

18390
11:35:02,000 --> 11:35:06,240
constant here in this context capacity

18391
11:35:04,160 --> 11:35:09,560
and every element in that array is a

18392
11:35:06,240 --> 11:35:11,560
person structure and I now have this to

18393
11:35:09,560 --> 11:35:13,799
size now this almost seems like a

18394
11:35:11,560 --> 11:35:16,115
synonym for capacity but maybe

18395
11:35:13,800 --> 11:35:18,520
intuitively anyone want to propose why

18396
11:35:16,116 --> 11:35:21,040
I'm apparently maintaining separately

18397
11:35:18,520 --> 11:35:23,596
the capacity of the stack but also the

18398
11:35:21,040 --> 11:35:25,200
size of the stack why these two

18399
11:35:23,596 --> 11:35:29,320
distinctions

18400
11:35:25,200 --> 11:35:29,320
here yeah

18401
11:35:35,480 --> 11:35:39,520
perfect the capacity is how high the

18402
11:35:37,276 --> 11:35:42,040
stack could be like how much room is

18403
11:35:39,520 --> 11:35:44,039
there for those sweatshirts in my closet

18404
11:35:42,040 --> 11:35:45,880
for instance whereas size is just

18405
11:35:44,040 --> 11:35:47,756
literally at this moment in time how

18406
11:35:45,880 --> 11:35:50,560
many sweatshirts are in the stack it's

18407
11:35:47,756 --> 11:35:52,840
either capacity or fewer presumably in

18408
11:35:50,560 --> 11:35:54,596
total there so what is capacity well we

18409
11:35:52,840 --> 11:35:56,435
could implement this in you know perhaps

18410
11:35:54,596 --> 11:35:58,520
a familiar way I might just Define a

18411
11:35:56,436 --> 11:36:01,080
const somewhere else in my code of type

18412
11:35:58,520 --> 11:36:03,115
int that just defines it to be capacity

18413
11:36:01,080 --> 11:36:06,276
50 but what perhaps is going to be the

18414
11:36:03,116 --> 11:36:10,116
downside of implementing a stack in this

18415
11:36:06,276 --> 11:36:11,756
way of how using an array inside here

18416
11:36:10,116 --> 11:36:14,680
like what's a downside now of

18417
11:36:11,756 --> 11:36:17,320
implementing a stack using an array and

18418
11:36:14,680 --> 11:36:20,480
this size variable

18419
11:36:17,320 --> 11:36:24,200
within what's a caveat here

18420
11:36:20,480 --> 11:36:24,200
perhaps any hands

18421
11:36:24,640 --> 11:36:28,080
yeah okay so it's going to be harder to

18422
11:36:26,596 --> 11:36:30,040
reach elements that aren't the last one

18423
11:36:28,080 --> 11:36:31,520
that is the most recently added one so

18424
11:36:30,040 --> 11:36:33,520
there could be some sweatshirts so to

18425
11:36:31,520 --> 11:36:35,560
speak way down below so we've seen that

18426
11:36:33,520 --> 11:36:37,560
before too but at some point too a

18427
11:36:35,560 --> 11:36:39,200
limitation of this design is is what

18428
11:36:37,560 --> 11:36:41,200
it's going to be finite right I can

18429
11:36:39,200 --> 11:36:43,680
maximally fit in this example 50

18430
11:36:41,200 --> 11:36:45,755
sweatshirts or 50 emails or 50 cafeteria

18431
11:36:43,680 --> 11:36:47,436
Trace which is fine but at least it's

18432
11:36:45,756 --> 11:36:49,400
indeed finite and at least in the

18433
11:36:47,436 --> 11:36:51,800
computer's memory it might be nice to

18434
11:36:49,400 --> 11:36:53,520
use more and more and more maybe as more

18435
11:36:51,800 --> 11:36:55,720
things are getting added to the computer

18436
11:36:53,520 --> 11:36:58,479
so maybe I make this 500 or heck why

18437
11:36:55,720 --> 11:37:00,480
don't I make it 5,000 or 50,000 well

18438
11:36:58,480 --> 11:37:03,360
what's the tradeoff there if I want to

18439
11:37:00,480 --> 11:37:04,880
have enough room to grow seems like I

18440
11:37:03,360 --> 11:37:07,880
should just crank up the value of

18441
11:37:04,880 --> 11:37:11,755
capacity endlessly but why might I not

18442
11:37:07,880 --> 11:37:14,115
want to change the 50 to 500 or 5,000 or

18443
11:37:11,756 --> 11:37:18,040
50,000 what's the trade-off there

18444
11:37:14,116 --> 11:37:18,040
perhaps just intuitively

18445
11:37:19,160 --> 11:37:22,720
yeah okay you don't want to touch memory

18446
11:37:21,080 --> 11:37:24,596
that you're not supposed to be touching

18447
11:37:22,720 --> 11:37:26,320
and in this case it wouldn't be that

18448
11:37:24,596 --> 11:37:28,320
wouldn't be a risk per se unless you

18449
11:37:26,320 --> 11:37:30,596
indeed overflow the stack but there's a

18450
11:37:28,320 --> 11:37:34,360
related issue in asking for that much

18451
11:37:30,596 --> 11:37:34,360
memory what would another downside

18452
11:37:38,756 --> 11:37:43,756
be yeah okay exactly so if you've got a

18453
11:37:41,720 --> 11:37:46,080
capacity of 5,000 but you're only using

18454
11:37:43,756 --> 11:37:47,560
one of those elements it's it's awkward

18455
11:37:46,080 --> 11:37:49,680
to say it non-technically which is just

18456
11:37:47,560 --> 11:37:51,479
to say very very wasteful right that's

18457
11:37:49,680 --> 11:37:53,320
just bad design it's correct it will

18458
11:37:51,480 --> 11:37:54,680
work for up to 5,000 elements but my

18459
11:37:53,320 --> 11:37:57,000
gosh you're wasting

18460
11:37:54,680 --> 11:37:58,756
4,999 extra spots and that's not going

18461
11:37:57,000 --> 11:38:00,480
to end well especially if you're using

18462
11:37:58,756 --> 11:38:02,116
more data structures in memory like your

18463
11:38:00,480 --> 11:38:04,116
Mac your PC your phone is surely going

18464
11:38:02,116 --> 11:38:05,756
to run out of memory if you ask for that

18465
11:38:04,116 --> 11:38:08,520
much so it' be nice if there is a bit

18466
11:38:05,756 --> 11:38:10,240
more dynamism there whether it's a stack

18467
11:38:08,520 --> 11:38:12,435
or a CU both of which might be

18468
11:38:10,240 --> 11:38:15,115
implemented a little similarly in spirit

18469
11:38:12,436 --> 11:38:16,916
but let's conclude this abstraction by

18470
11:38:15,116 --> 11:38:18,480
comparing thanks to a friend of ours

18471
11:38:16,916 --> 11:38:20,320
Professor Shannon Duval of Elon

18472
11:38:18,480 --> 11:38:22,000
University who kindly put together this

18473
11:38:20,320 --> 11:38:23,880
graphical animation that's just under 2

18474
11:38:22,000 --> 11:38:25,436
minutes long that paints a picture of

18475
11:38:23,880 --> 11:38:26,596
these two types of abstract data

18476
11:38:25,436 --> 11:38:29,200
structures and then we'll dive in

18477
11:38:26,596 --> 11:38:30,880
underneath to how we might Implement uh

18478
11:38:29,200 --> 11:38:32,969
problems like these if we could dim the

18479
11:38:30,880 --> 11:38:36,149
lights

18480
11:38:32,970 --> 11:38:36,150
[Music]

18481
11:38:36,320 --> 11:38:41,116
dramatically once upon a time there was

18482
11:38:38,640 --> 11:38:43,840
a guy named Jack when it came to making

18483
11:38:41,116 --> 11:38:45,596
friends Jack did not have the Knack so

18484
11:38:43,840 --> 11:38:48,039
Jack went to talk to the most popular

18485
11:38:45,596 --> 11:38:50,435
guy he knew he went up to Lou and asked

18486
11:38:48,040 --> 11:38:53,200
what do I do Lou saw that his friend was

18487
11:38:50,436 --> 11:38:54,640
really distressed well Lou began just

18488
11:38:53,200 --> 11:38:57,079
look how you're dressed don't you have

18489
11:38:54,640 --> 11:38:59,956
any clothes with a different look yeah

18490
11:38:57,080 --> 11:39:02,000
yes said Jack I sure do come to my house

18491
11:38:59,956 --> 11:39:04,436
and I'll show them to you so they went

18492
11:39:02,000 --> 11:39:06,040
off to Jacks and Jack showed Lou the box

18493
11:39:04,436 --> 11:39:08,560
where he kept all his shirts and his

18494
11:39:06,040 --> 11:39:10,640
pants and his socks L said I see you

18495
11:39:08,560 --> 11:39:12,399
have all your clothes in a pile why

18496
11:39:10,640 --> 11:39:14,916
don't you wear some others once in a

18497
11:39:12,400 --> 11:39:17,400
while Jack said well when I remove

18498
11:39:14,916 --> 11:39:19,799
clothes and socks I wash them and put

18499
11:39:17,400 --> 11:39:22,640
them away in the box then comes the next

18500
11:39:19,800 --> 11:39:25,360
morning and up I hop I go to the box and

18501
11:39:22,640 --> 11:39:27,756
get my clothes off the top Lou quickly

18502
11:39:25,360 --> 11:39:30,596
realized the problem with Jack he kept

18503
11:39:27,756 --> 11:39:32,640
clothes CDs and books in a stack when he

18504
11:39:30,596 --> 11:39:35,520
reached for something to read or to wear

18505
11:39:32,640 --> 11:39:37,080
he chose the top book or underwear then

18506
11:39:35,520 --> 11:39:39,359
when he was done he would put it right

18507
11:39:37,080 --> 11:39:41,480
back back it would go on top of the

18508
11:39:39,360 --> 11:39:43,680
stack I know the solution said a

18509
11:39:41,480 --> 11:39:46,200
triumphant Lou you need to learn to

18510
11:39:43,680 --> 11:39:48,200
start using a queue Lou took Jack's

18511
11:39:46,200 --> 11:39:49,799
clothes and hung them in a closet and

18512
11:39:48,200 --> 11:39:52,399
when he had emptied the box he just

18513
11:39:49,800 --> 11:39:54,360
tossed it then he said now Jack at the

18514
11:39:52,400 --> 11:39:56,360
end of the day put your clothes on the

18515
11:39:54,360 --> 11:39:57,560
left when you put them away then

18516
11:39:56,360 --> 11:39:59,756
tomorrow morning morning when you see

18517
11:39:57,560 --> 11:40:02,040
the sun shine get your clothes from the

18518
11:39:59,756 --> 11:40:04,756
right from the end of the line don't you

18519
11:40:02,040 --> 11:40:06,640
see said Lou it will be so nice you'll

18520
11:40:04,756 --> 11:40:08,916
wear everything once before you wear

18521
11:40:06,640 --> 11:40:11,276
something twice and with everything in

18522
11:40:08,916 --> 11:40:13,399
cues in his closet and shelf Jack

18523
11:40:11,276 --> 11:40:17,596
started to feel quite sure of himself

18524
11:40:13,400 --> 11:40:17,596
all thanks to Lou and his wonderful

18525
11:40:18,240 --> 11:40:25,596
Q all right so sure so that paints a

18526
11:40:24,080 --> 11:40:27,160
picture of these two abstract data

18527
11:40:25,596 --> 11:40:28,320
structures but if we really were to dive

18528
11:40:27,160 --> 11:40:30,040
underneath the hood we could Implement

18529
11:40:28,320 --> 11:40:32,159
them in a number of different ways but

18530
11:40:30,040 --> 11:40:33,880
we really I think need some building

18531
11:40:32,160 --> 11:40:35,480
blocks via which we could solve problems

18532
11:40:33,880 --> 11:40:37,840
like those and we'll see today to some

18533
11:40:35,480 --> 11:40:40,000
others as well so let's rewind back to

18534
11:40:37,840 --> 11:40:41,596
week two where we imple we introduced

18535
11:40:40,000 --> 11:40:43,880
you to your very first data structure

18536
11:40:41,596 --> 11:40:46,320
that is an array and an array of recall

18537
11:40:43,880 --> 11:40:48,916
was just a chunk of memory whereby

18538
11:40:46,320 --> 11:40:51,596
elements were stored by Design back to

18539
11:40:48,916 --> 11:40:54,200
back to back it's an array of contiguous

18540
11:40:51,596 --> 11:40:56,040
memory specifically so with an array we

18541
11:40:54,200 --> 11:40:58,880
could certainly store not just one thing

18542
11:40:56,040 --> 11:41:01,040
but two or three or even more and so for

18543
11:40:58,880 --> 11:41:02,680
instance if we treat uh my computer's

18544
11:41:01,040 --> 11:41:04,436
memory as this sort of abstraction here

18545
11:41:02,680 --> 11:41:06,880
and pictured here are three bytes or

18546
11:41:04,436 --> 11:41:08,360
some uh uh multiplication thereof

18547
11:41:06,880 --> 11:41:10,680
suppose we're storing in the computer's

18548
11:41:08,360 --> 11:41:13,116
memory an array of size three storing

18549
11:41:10,680 --> 11:41:15,840
the digits one two and three well

18550
11:41:13,116 --> 11:41:17,640
remember that if we zoom out per last

18551
11:41:15,840 --> 11:41:19,916
week there's other stuff going on in

18552
11:41:17,640 --> 11:41:21,640
memory so even if we want to add another

18553
11:41:19,916 --> 11:41:23,596
number to this array that we didn't

18554
11:41:21,640 --> 11:41:25,956
think of when we first started the

18555
11:41:23,596 --> 11:41:27,479
program like the number four ideally we

18556
11:41:25,956 --> 11:41:29,436
would put it right here next to it

18557
11:41:27,480 --> 11:41:30,840
otherwise it's no longer an array so by

18558
11:41:29,436 --> 11:41:32,640
definition if we're using an array it's

18559
11:41:30,840 --> 11:41:34,479
got to end up right there after the

18560
11:41:32,640 --> 11:41:36,400
three but what else is going on inside

18561
11:41:34,480 --> 11:41:38,160
of your computer's memory well assuming

18562
11:41:36,400 --> 11:41:40,000
your program is of any length and you've

18563
11:41:38,160 --> 11:41:41,480
got other variables other functions

18564
11:41:40,000 --> 11:41:43,200
you've been running it for a while

18565
11:41:41,480 --> 11:41:45,360
there's a lot going on in your memory is

18566
11:41:43,200 --> 11:41:47,479
being used and reused so for instance

18567
11:41:45,360 --> 11:41:50,480
somewhere in memory might be immediately

18568
11:41:47,480 --> 11:41:52,840
adjacent to this like hello comma world

18569
11:41:50,480 --> 11:41:54,160
back0 the null character just because

18570
11:41:52,840 --> 11:41:56,200
maybe you have another variable

18571
11:41:54,160 --> 11:41:57,840
somewhere in there that is storing that

18572
11:41:56,200 --> 11:41:59,840
particular string alongside your

18573
11:41:57,840 --> 11:42:01,359
existing array of size three and all of

18574
11:41:59,840 --> 11:42:03,240
these Oscar the grouches here really

18575
11:42:01,360 --> 11:42:05,040
just represent what we called last week

18576
11:42:03,240 --> 11:42:06,799
garbage values like there's obviously

18577
11:42:05,040 --> 11:42:08,200
bits there because they don't disappear

18578
11:42:06,800 --> 11:42:10,080
they're always going to be inside of the

18579
11:42:08,200 --> 11:42:11,840
computer somehow implemented but we

18580
11:42:10,080 --> 11:42:13,436
don't really know or care what they are

18581
11:42:11,840 --> 11:42:14,956
they're the remnants of those bytes

18582
11:42:13,436 --> 11:42:17,116
having been used for other older

18583
11:42:14,956 --> 11:42:19,479
variables previous function calls or the

18584
11:42:17,116 --> 11:42:21,840
like but the problem clearly here is

18585
11:42:19,480 --> 11:42:23,480
that okay 1 two 3 is there but the H is

18586
11:42:21,840 --> 11:42:25,916
here and unless I want to start uh

18587
11:42:23,480 --> 11:42:28,840
taking a bite out of my string by

18588
11:42:25,916 --> 11:42:30,840
overriding the H with a four like we

18589
11:42:28,840 --> 11:42:32,320
just can't fit it right there and yet

18590
11:42:30,840 --> 11:42:33,719
even though there's Oscars all over the

18591
11:42:32,320 --> 11:42:35,956
place those are indeed garbage values

18592
11:42:33,720 --> 11:42:37,640
and therefore we could use that space

18593
11:42:35,956 --> 11:42:39,436
because it's technically unused we just

18594
11:42:37,640 --> 11:42:42,479
don't know or care what the values are

18595
11:42:39,436 --> 11:42:44,400
so where could I put 1 2 3 4 well my

18596
11:42:42,480 --> 11:42:46,436
gosh like I have all this memory down

18597
11:42:44,400 --> 11:42:49,360
here that's unused I could certainly

18598
11:42:46,436 --> 11:42:53,560
change those garbage values to be 1 2 3

18599
11:42:49,360 --> 11:42:55,596
4 but to do that I might need to do a

18600
11:42:53,560 --> 11:42:57,756
bit of work here right it's not just a

18601
11:42:55,596 --> 11:43:00,320
matter of just saying boom and it

18602
11:42:57,756 --> 11:43:01,320
happens now with c and with code I'd

18603
11:43:00,320 --> 11:43:02,956
have to do this a little more

18604
11:43:01,320 --> 11:43:04,840
methodically so let me abstract away

18605
11:43:02,956 --> 11:43:06,560
everything else that's a distraction let

18606
11:43:04,840 --> 11:43:08,679
me assume that there is indeed at least

18607
11:43:06,560 --> 11:43:09,956
four bytes available for four numbers

18608
11:43:08,680 --> 11:43:11,720
just down here though we could have put

18609
11:43:09,956 --> 11:43:14,840
them in a bunch of different spots

18610
11:43:11,720 --> 11:43:17,480
what's involved now in moving the one

18611
11:43:14,840 --> 11:43:19,479
two three to this new chunk of memory so

18612
11:43:17,480 --> 11:43:21,040
we can add the four well I think

18613
11:43:19,480 --> 11:43:23,720
conceptually we're going to have to copy

18614
11:43:21,040 --> 11:43:25,800
the one from old to new copy the two

18615
11:43:23,720 --> 11:43:28,080
from old to new copy the three from old

18616
11:43:25,800 --> 11:43:29,800
to new and then ultimately we can get

18617
11:43:28,080 --> 11:43:31,800
rid of the old memory those three

18618
11:43:29,800 --> 11:43:33,680
original bites could now look like Oscar

18619
11:43:31,800 --> 11:43:35,680
the Grouch and just be garbage values

18620
11:43:33,680 --> 11:43:38,080
for all intents and purposes but now I

18621
11:43:35,680 --> 11:43:41,720
have room for a fourth bite wherein I

18622
11:43:38,080 --> 11:43:44,720
can put the number four so this is nice

18623
11:43:41,720 --> 11:43:47,160
but what's a downside of this

18624
11:43:44,720 --> 11:43:48,276
approach what's a downside of solving

18625
11:43:47,160 --> 11:43:50,680
the problem in this way where the

18626
11:43:48,276 --> 11:43:53,436
problem at hand is just to grow the

18627
11:43:50,680 --> 11:43:55,560
array so to speak to increase its size

18628
11:43:53,436 --> 11:43:58,680
to fit one or more

18629
11:43:55,560 --> 11:44:02,040
numbers seems pretty

18630
11:43:58,680 --> 11:44:02,040
straightforward but

18631
11:44:04,320 --> 11:44:08,116
yeah okay maybe it's out of order but I

18632
11:44:06,680 --> 11:44:09,720
think that's okay because the order is

18633
11:44:08,116 --> 11:44:11,756
just matters that it's relative so so

18634
11:44:09,720 --> 11:44:12,916
long it's it's still contiguous back to

18635
11:44:11,756 --> 11:44:14,640
back to back in a different chunk of

18636
11:44:12,916 --> 11:44:17,435
memory I think we're okay there it's not

18637
11:44:14,640 --> 11:44:20,240
like I changed it for 4 3 2 one but a

18638
11:44:17,436 --> 11:44:20,240
reasonable hunch

18639
11:44:21,480 --> 11:44:25,640
yeah yeah like I don't really plan ahead

18640
11:44:24,276 --> 11:44:27,840
here like if I have to add another

18641
11:44:25,640 --> 11:44:29,116
number like five or anything else well I

18642
11:44:27,840 --> 11:44:30,435
might have to jump through these hoops

18643
11:44:29,116 --> 11:44:32,360
again maybe I get lucky and maybe

18644
11:44:30,436 --> 11:44:33,800
there's space there but not if I have

18645
11:44:32,360 --> 11:44:36,640
other variables and other things going

18646
11:44:33,800 --> 11:44:39,916
on that too might be used at some point

18647
11:44:36,640 --> 11:44:43,200
other thoughts yeah slow efficiency slow

18648
11:44:39,916 --> 11:44:45,956
effic in slow efficiency why have

18649
11:44:43,200 --> 11:44:48,755
to again yeah I mean it's just in it's

18650
11:44:45,956 --> 11:44:51,840
just inefficient it's sort of bad design

18651
11:44:48,756 --> 11:44:53,880
arguably why because I had to copy all

18652
11:44:51,840 --> 11:44:55,640
of my original work down here and as you

18653
11:44:53,880 --> 11:44:57,360
note if I want to add a fifth number I'm

18654
11:44:55,640 --> 11:45:00,159
going to have to copy it again and again

18655
11:44:57,360 --> 11:45:02,720
and again and do things end times again

18656
11:45:00,160 --> 11:45:04,956
and again now maybe that's necessary

18657
11:45:02,720 --> 11:45:06,160
we'll soon see for sure but it feels

18658
11:45:04,956 --> 11:45:07,520
like this is not going to end well

18659
11:45:06,160 --> 11:45:10,240
especially if the array isn't of size

18660
11:45:07,520 --> 11:45:12,560
three or four but 300 400 your computer

18661
11:45:10,240 --> 11:45:14,276
ends up spending so much time just

18662
11:45:12,560 --> 11:45:16,159
spinning its Wheels I mean honestly

18663
11:45:14,276 --> 11:45:18,640
better might be this like if this is my

18664
11:45:16,160 --> 11:45:20,880
same array physically incarnated Now 1

18665
11:45:18,640 --> 11:45:23,040
two 3 it's literally on the edge of the

18666
11:45:20,880 --> 11:45:25,360
shelf so there's no room for the number

18667
11:45:23,040 --> 11:45:27,520
four you know maybe where we could take

18668
11:45:25,360 --> 11:45:29,200
this story is well let's just find room

18669
11:45:27,520 --> 11:45:31,880
for the four like let's just put the

18670
11:45:29,200 --> 11:45:33,916
four for instance over here replacing

18671
11:45:31,880 --> 11:45:36,435
some available garbage value some spare

18672
11:45:33,916 --> 11:45:38,956
bite over here but now wait a minute

18673
11:45:36,436 --> 11:45:40,360
I've broken the definition of an array

18674
11:45:38,956 --> 11:45:42,956
right it's I can't have one two three

18675
11:45:40,360 --> 11:45:44,880
and then four over here so maybe there

18676
11:45:42,956 --> 11:45:46,159
maybe there could be a mechanism if I

18677
11:45:44,880 --> 11:45:48,276
put this thing on again where when you

18678
11:45:46,160 --> 11:45:51,160
get to the end of the existing elements

18679
11:45:48,276 --> 11:45:53,040
maybe I just somehow digitally point to

18680
11:45:51,160 --> 11:45:54,596
the fourth array and maybe we can kind

18681
11:45:53,040 --> 11:45:56,436
of stitch together all of these

18682
11:45:54,596 --> 11:45:58,880
different values in memory so that if

18683
11:45:56,436 --> 11:46:01,240
you follow the arrows so to speak we can

18684
11:45:58,880 --> 11:46:03,276
reconstruct exactly what the order is

18685
11:46:01,240 --> 11:46:05,320
even without having to find or make room

18686
11:46:03,276 --> 11:46:07,479
here or pick up all of these numbers and

18687
11:46:05,320 --> 11:46:09,240
move all of them over there so that's

18688
11:46:07,480 --> 11:46:12,720
perhaps the direction in which we'll go

18689
11:46:09,240 --> 11:46:15,079
here so let's see how we might get to

18690
11:46:12,720 --> 11:46:17,596
that spot as follows let me go ahead and

18691
11:46:15,080 --> 11:46:21,360
open up say VSS code here let me open up

18692
11:46:17,596 --> 11:46:23,115
a program called list. C in my terminal

18693
11:46:21,360 --> 11:46:25,200
and let me go ahead and whip up a

18694
11:46:23,116 --> 11:46:27,000
relatively simple program that just

18695
11:46:25,200 --> 11:46:29,560
demonstrates what we did back in week

18696
11:46:27,000 --> 11:46:32,680
two when we introduced arrays as follows

18697
11:46:29,560 --> 11:46:35,680
let me include uh standard io. so we can

18698
11:46:32,680 --> 11:46:37,880
print stuff out let me do int main void

18699
11:46:35,680 --> 11:46:42,360
no command line Arguments for now let me

18700
11:46:37,880 --> 11:46:44,435
give myself a an array uh called list of

18701
11:46:42,360 --> 11:46:46,240
size three and I'll just hardcode it to

18702
11:46:44,436 --> 11:46:48,080
keep it simple for lecture sake Each of

18703
11:46:46,240 --> 11:46:49,720
which is going to be an integer and now

18704
11:46:48,080 --> 11:46:51,916
just so we have some specifics to talk

18705
11:46:49,720 --> 11:46:53,956
about let me put it list bracket zero

18706
11:46:51,916 --> 11:46:55,719
the number one list bracket one the

18707
11:46:53,956 --> 11:46:57,756
number two and list bracket two the

18708
11:46:55,720 --> 11:46:59,840
number three so I'm just translating

18709
11:46:57,756 --> 11:47:01,276
into codee what we just had uh

18710
11:46:59,840 --> 11:47:03,276
pictorially on the screen and also

18711
11:47:01,276 --> 11:47:05,200
physically here with these numbers on

18712
11:47:03,276 --> 11:47:07,360
the desk now let's just do something

18713
11:47:05,200 --> 11:47:10,880
mildly useful for this how about we do

18714
11:47:07,360 --> 11:47:13,240
four in I gets zero I is less than three

18715
11:47:10,880 --> 11:47:14,880
I ++ let's just print each of these

18716
11:47:13,240 --> 11:47:16,436
numbers out just to make sure they're

18717
11:47:14,880 --> 11:47:19,755
indeed in memory as I intended so

18718
11:47:16,436 --> 11:47:21,840
percent I back sln comma I and then a

18719
11:47:19,756 --> 11:47:24,080
semicolon and I think that's it for now

18720
11:47:21,840 --> 11:47:25,916
so nothing interesting no problem solved

18721
11:47:24,080 --> 11:47:27,840
just yet just a proof of concept so that

18722
11:47:25,916 --> 11:47:28,840
now when I clear my terminal and run

18723
11:47:27,840 --> 11:47:32,240
make

18724
11:47:28,840 --> 11:47:34,399
list no apparent errors at the terminal

18725
11:47:32,240 --> 11:47:37,596
and so when I now do do/ list I should

18726
11:47:34,400 --> 11:47:39,596
see hopefully from left to right 1 two 3

18727
11:47:37,596 --> 11:47:42,159
but of course if I want to add a fourth

18728
11:47:39,596 --> 11:47:44,159
number now there's no mechanism for such

18729
11:47:42,160 --> 11:47:46,276
certainly in the code that I just wrote

18730
11:47:44,160 --> 11:47:48,720
I could go back in here and change this

18731
11:47:46,276 --> 11:47:51,200
to a four I could go down here and

18732
11:47:48,720 --> 11:47:53,756
change lists bracket 3 equals 4 I could

18733
11:47:51,200 --> 11:47:55,320
just manually change the code recompile

18734
11:47:53,756 --> 11:47:56,956
the code but of course that doesn't give

18735
11:47:55,320 --> 11:47:59,560
me any additional run way for the fifth

18736
11:47:56,956 --> 11:48:00,880
or sixth number so let me try to take a

18737
11:47:59,560 --> 11:48:04,276
different approach drawing some

18738
11:48:00,880 --> 11:48:06,956
inspiration from last week if I want to

18739
11:48:04,276 --> 11:48:08,520
allocate memory dynamically maybe

18740
11:48:06,956 --> 11:48:10,799
because I don't know when I wrote the

18741
11:48:08,520 --> 11:48:12,560
program how many bytes I want we have

18742
11:48:10,800 --> 11:48:14,000
another function as of last week that

18743
11:48:12,560 --> 11:48:16,040
does not require that you commit in

18744
11:48:14,000 --> 11:48:17,320
advance to a certain number of bytes via

18745
11:48:16,040 --> 11:48:20,040
what function can you just ask the

18746
11:48:17,320 --> 11:48:22,596
operating system for a chunk of memory

18747
11:48:20,040 --> 11:48:24,880
okay so Malo to allocate memory now an

18748
11:48:22,596 --> 11:48:26,799
array is just a chunk of memory and even

18749
11:48:24,880 --> 11:48:29,079
though since week two 've been using

18750
11:48:26,800 --> 11:48:31,160
this syntactic sugar this convenience of

18751
11:48:29,080 --> 11:48:33,560
just using square brackets and indexing

18752
11:48:31,160 --> 11:48:35,320
into it it's just making it easier to

18753
11:48:33,560 --> 11:48:37,560
manipulate a chunk of memory that's

18754
11:48:35,320 --> 11:48:39,800
contiguous all together back to back to

18755
11:48:37,560 --> 11:48:41,240
back so today just like last week we can

18756
11:48:39,800 --> 11:48:43,200
take those sort of training wheels off

18757
11:48:41,240 --> 11:48:45,520
and maybe be a little more deliberate in

18758
11:48:43,200 --> 11:48:48,799
how we allocate memory let me go for

18759
11:48:45,520 --> 11:48:51,039
instance and do this let me delete my

18760
11:48:48,800 --> 11:48:53,756
contents of my main function here go

18761
11:48:51,040 --> 11:48:57,160
back into Main and let me propose now

18762
11:48:53,756 --> 11:48:59,320
that I declare for instance how about my

18763
11:48:57,160 --> 11:49:02,276
list no longer as an array but as a

18764
11:48:59,320 --> 11:49:05,756
pointer so int star list and I'm going

18765
11:49:02,276 --> 11:49:07,756
to go ahead and initialize this to be

18766
11:49:05,756 --> 11:49:09,240
how about a chunk of three integers for

18767
11:49:07,756 --> 11:49:10,880
now so I'm still going to hardcode it

18768
11:49:09,240 --> 11:49:13,240
but I'm taking a step toward more

18769
11:49:10,880 --> 11:49:15,956
dynamism for now so let me allocate

18770
11:49:13,240 --> 11:49:17,400
three times whatever the size is of an

18771
11:49:15,956 --> 11:49:19,116
INT but it's usually going to be four

18772
11:49:17,400 --> 11:49:21,840
bytes as we know so this is really going

18773
11:49:19,116 --> 11:49:24,756
to be 3 * 4al 12 but it's a little more

18774
11:49:21,840 --> 11:49:26,560
Dynamic and now what can I do down here

18775
11:49:24,756 --> 11:49:30,720
well this is just a chunk of memory

18776
11:49:26,560 --> 11:49:35,360
so I can do literally list bracket 0 uh

18777
11:49:30,720 --> 11:49:39,560
equal 1 list bracket 1 = 2 list bracket

18778
11:49:35,360 --> 11:49:41,800
2 equals 3 and voila achieve the exact

18779
11:49:39,560 --> 11:49:43,520
same effect because again an array is

18780
11:49:41,800 --> 11:49:46,200
just a chunk of contiguous memory but

18781
11:49:43,520 --> 11:49:48,000
malok gives you any old chunk of

18782
11:49:46,200 --> 11:49:50,560
contiguous memory so you can rather

18783
11:49:48,000 --> 11:49:52,116
treat one like the other here now if you

18784
11:49:50,560 --> 11:49:54,115
really want to be cool you could do

18785
11:49:52,116 --> 11:49:57,116
something like this instead you could

18786
11:49:54,116 --> 11:49:58,916
dreference the address in list and go

18787
11:49:57,116 --> 11:50:02,436
there you could go down here and

18788
11:49:58,916 --> 11:50:04,276
dreference list + one and go there but

18789
11:50:02,436 --> 11:50:06,000
honestly no one really writes code like

18790
11:50:04,276 --> 11:50:07,720
this it's just too cryptic it's a little

18791
11:50:06,000 --> 11:50:09,916
too far over the line at least for most

18792
11:50:07,720 --> 11:50:11,520
people and so I think the syntactic

18793
11:50:09,916 --> 11:50:13,040
sugar as I keep describing it just the

18794
11:50:11,520 --> 11:50:14,840
more user friendly square bracket

18795
11:50:13,040 --> 11:50:16,436
notation does the exact same thing

18796
11:50:14,840 --> 11:50:18,880
figures out the pointer arithmetic and

18797
11:50:16,436 --> 11:50:21,596
puts each of these integers in the right

18798
11:50:18,880 --> 11:50:23,479
chunks therein now just to be super

18799
11:50:21,596 --> 11:50:26,720
pedantic let me make sure if something

18800
11:50:23,480 --> 11:50:28,116
went wrong so if list equals equals n

18801
11:50:26,720 --> 11:50:29,880
that means that something went wrong

18802
11:50:28,116 --> 11:50:31,916
like my computer is out of memory which

18803
11:50:29,880 --> 11:50:34,520
we should check for typically so let me

18804
11:50:31,916 --> 11:50:36,079
just immediately return one signaling

18805
11:50:34,520 --> 11:50:37,880
anything other than zero which means

18806
11:50:36,080 --> 11:50:39,800
success typically just to get out of

18807
11:50:37,880 --> 11:50:42,799
this program because something's wrong

18808
11:50:39,800 --> 11:50:45,916
but now let me propose that I've had a

18809
11:50:42,800 --> 11:50:48,756
uh well let's do this for in I gets zero

18810
11:50:45,916 --> 11:50:50,596
I less than three i++ though a better

18811
11:50:48,756 --> 11:50:52,240
design would always be to use a con but

18812
11:50:50,596 --> 11:50:54,079
I'm just doing this for demonstration

18813
11:50:52,240 --> 11:50:55,680
sake let's print out each of these ins

18814
11:50:54,080 --> 11:50:58,000
too and just make sure I didn't mess

18815
11:50:55,680 --> 11:51:01,240
anything up and let me open my terminal

18816
11:50:58,000 --> 11:51:04,720
window again let me do make list

18817
11:51:01,240 --> 11:51:07,115
again okay huh implicitly declaring

18818
11:51:04,720 --> 11:51:10,320
Library function Malo with type void

18819
11:51:07,116 --> 11:51:12,916
star something something implicitly de

18820
11:51:10,320 --> 11:51:16,276
declaring is the operative words there

18821
11:51:12,916 --> 11:51:18,596
what did I mess up

18822
11:51:16,276 --> 11:51:21,320
yeah yeah I forgot the header file in

18823
11:51:18,596 --> 11:51:23,560
which malok is declared I remember now

18824
11:51:21,320 --> 11:51:25,116
okay that's in standard li. and it's

18825
11:51:23,560 --> 11:51:28,435
fine to look stuff like that up if you

18826
11:51:25,116 --> 11:51:30,680
forget so let me include standard libh

18827
11:51:28,436 --> 11:51:34,480
now let me clear my terminal run make

18828
11:51:30,680 --> 11:51:38,750
list again okay now we're good /list and

18829
11:51:34,480 --> 11:51:40,000
now what did I do

18830
11:51:38,750 --> 11:51:43,640
[Music]

18831
11:51:40,000 --> 11:51:47,520
wrong oh okay not intended but teachable

18832
11:51:43,640 --> 11:51:49,880
moment what did I do wrong

18833
11:51:47,520 --> 11:51:52,680
yeah yeah I'm printing the values of i

18834
11:51:49,880 --> 11:51:54,956
instead of what is at location I in the

18835
11:51:52,680 --> 11:51:56,756
array so what I actually meant to do was

18836
11:51:54,956 --> 11:51:58,479
print this out thank you you so now let

18837
11:51:56,756 --> 11:52:00,880
me recompile make

18838
11:51:58,480 --> 11:52:02,680
listlist and now okay those are the

18839
11:52:00,880 --> 11:52:05,276
three values I was expecting not the

18840
11:52:02,680 --> 11:52:07,000
indices thereof now let me propose that

18841
11:52:05,276 --> 11:52:09,799
for the sake of discussion that I I

18842
11:52:07,000 --> 11:52:12,520
regret having only allocated space for

18843
11:52:09,800 --> 11:52:14,680
three integers and maybe I really should

18844
11:52:12,520 --> 11:52:15,880
have allocated enough space for four now

18845
11:52:14,680 --> 11:52:17,400
this is not how you would do this in

18846
11:52:15,880 --> 11:52:19,040
practice because presumably if you have

18847
11:52:17,400 --> 11:52:21,276
a change of thought just go back in and

18848
11:52:19,040 --> 11:52:23,080
correct the code but let me propose that

18849
11:52:21,276 --> 11:52:25,200
somewhere in here is a more complicated

18850
11:52:23,080 --> 11:52:26,880
program and time passes dot dot dot

18851
11:52:25,200 --> 11:52:29,276
there's a lot of other interesting code

18852
11:52:26,880 --> 11:52:31,520
there but at some point I might want to

18853
11:52:29,276 --> 11:52:33,240
give myself more memory so how can I do

18854
11:52:31,520 --> 11:52:35,560
this well let me just ask the operating

18855
11:52:33,240 --> 11:52:37,000
system now for four new bytes of memory

18856
11:52:35,560 --> 11:52:38,840
so that we can at least in version one

18857
11:52:37,000 --> 11:52:41,080
implement the ID on the board where I

18858
11:52:38,840 --> 11:52:43,596
just copied the three bytes into the new

18859
11:52:41,080 --> 11:52:45,360
four bytes and then added a fourth value

18860
11:52:43,596 --> 11:52:47,320
so I'm going to use malok again and I'm

18861
11:52:45,360 --> 11:52:49,560
going to say here's a new pointer I'll

18862
11:52:47,320 --> 11:52:51,200
call it temp TMP for short which is

18863
11:52:49,560 --> 11:52:53,360
quite common when you just need it

18864
11:52:51,200 --> 11:52:55,799
briefly I'm going to then call malok

18865
11:52:53,360 --> 11:52:58,840
again I'm going to say give me four

18866
11:52:55,800 --> 11:53:02,520
integers using size of let me again make

18867
11:52:58,840 --> 11:53:03,956
sure so if temp equals equals null

18868
11:53:02,520 --> 11:53:06,159
something went wrong so let me just

18869
11:53:03,956 --> 11:53:09,159
immediately return one and for good

18870
11:53:06,160 --> 11:53:11,720
measure before I return one one let me

18871
11:53:09,160 --> 11:53:13,596
free the original list so that I don't

18872
11:53:11,720 --> 11:53:15,680
leak memory so I'm not just immediately

18873
11:53:13,596 --> 11:53:18,840
returning one I'm being a good citizen

18874
11:53:15,680 --> 11:53:21,560
and remembering well if this Malo call

18875
11:53:18,840 --> 11:53:25,039
did succeed and indeed I got as far as

18876
11:53:21,560 --> 11:53:27,756
line 18 but then line 18 failed I should

18877
11:53:25,040 --> 11:53:29,160
free the memory that I previously macked

18878
11:53:27,756 --> 11:53:30,880
so again that's the rule of thumb if you

18879
11:53:29,160 --> 11:53:33,240
allocate it you should be the one to

18880
11:53:30,880 --> 11:53:34,755
free it even before you're about to quit

18881
11:53:33,240 --> 11:53:36,799
now once I've done that I think I need

18882
11:53:34,756 --> 11:53:38,916
to do what we did pictorially on the

18883
11:53:36,800 --> 11:53:41,320
screen where I need to copy the One the

18884
11:53:38,916 --> 11:53:43,435
two the three from the old array into

18885
11:53:41,320 --> 11:53:46,480
the new so how might I do this well let

18886
11:53:43,436 --> 11:53:49,000
me give myself a loop so for in I gets

18887
11:53:46,480 --> 11:53:51,720
zero I less than three i++ because the

18888
11:53:49,000 --> 11:53:53,956
size of the original is still the same

18889
11:53:51,720 --> 11:53:57,116
let me go ahead and treat the new chunk

18890
11:53:53,956 --> 11:53:59,080
of memory called 10 temp as an array

18891
11:53:57,116 --> 11:54:00,400
itself and so I can absolutely use these

18892
11:53:59,080 --> 11:54:02,160
square brackets just like before it's

18893
11:54:00,400 --> 11:54:04,596
just a chunk of memory I'm treating it

18894
11:54:02,160 --> 11:54:06,956
like an array and let me add to that

18895
11:54:04,596 --> 11:54:09,560
value whatever is at the original list

18896
11:54:06,956 --> 11:54:12,320
at location I as well so this again is

18897
11:54:09,560 --> 11:54:15,680
just this exercise of copying from right

18898
11:54:12,320 --> 11:54:18,159
uh from old to new step by step the one

18899
11:54:15,680 --> 11:54:20,720
the two and the three but I still need

18900
11:54:18,160 --> 11:54:23,680
one additional step if my goal at hand

18901
11:54:20,720 --> 11:54:25,200
now is to have ultimately a fourth value

18902
11:54:23,680 --> 11:54:26,916
here well I'm just going to hard coose

18903
11:54:25,200 --> 11:54:29,000
this for demonstration sake and I'm

18904
11:54:26,916 --> 11:54:32,240
going to go to the very last location of

18905
11:54:29,000 --> 11:54:35,840
temp which is of size four which means

18906
11:54:32,240 --> 11:54:38,840
the last element in temp is temp

18907
11:54:35,840 --> 11:54:40,840
bracket three because it's zero indexed

18908
11:54:38,840 --> 11:54:42,240
but there's four total spaces there and

18909
11:54:40,840 --> 11:54:43,916
I'm just going to arbitrarily for the

18910
11:54:42,240 --> 11:54:47,276
sake of discussion put the number four

18911
11:54:43,916 --> 11:54:50,115
there and that is what happened when we

18912
11:54:47,276 --> 11:54:52,640
proposed uh changing the final garbage

18913
11:54:50,116 --> 11:54:54,400
value there to that four but now I need

18914
11:54:52,640 --> 11:54:56,320
to do what the slide did for us sort of

18915
11:54:54,400 --> 11:54:58,520
magically on the screen I should now do

18916
11:54:56,320 --> 11:55:00,320
a couple of final things I should free

18917
11:54:58,520 --> 11:55:02,640
the original list which I've not done

18918
11:55:00,320 --> 11:55:04,640
yet CU I only called free earlier in

18919
11:55:02,640 --> 11:55:08,159
cases of error and that was just to be

18920
11:55:04,640 --> 11:55:10,956
safe I can now free the list and now if

18921
11:55:08,160 --> 11:55:14,360
I want to inform the computer that I

18922
11:55:10,956 --> 11:55:16,560
want list quote unquote my variable

18923
11:55:14,360 --> 11:55:18,596
called list to point at not the old

18924
11:55:16,560 --> 11:55:21,320
chunk like it originally did but the new

18925
11:55:18,596 --> 11:55:22,680
chunk I think I can just do this list

18926
11:55:21,320 --> 11:55:25,080
equals

18927
11:55:22,680 --> 11:55:27,116
TMP and again that's just saying that if

18928
11:55:25,080 --> 11:55:29,436
list is a pointer which it was cuz look

18929
11:55:27,116 --> 11:55:33,240
at the very top line here on line eight

18930
11:55:29,436 --> 11:55:36,480
on line six I declared list to be a

18931
11:55:33,240 --> 11:55:38,479
pointer uh to a chunk of memory temp

18932
11:55:36,480 --> 11:55:41,480
meanwhile is a separate pointer to a

18933
11:55:38,480 --> 11:55:44,080
chunk of memory so down here this line

18934
11:55:41,480 --> 11:55:45,560
33 is just a matter of my saying okay

18935
11:55:44,080 --> 11:55:47,756
now henceforth because I've already

18936
11:55:45,560 --> 11:55:49,680
freed the old chunk of memory my list

18937
11:55:47,756 --> 11:55:52,000
variable should Point not at this chunk

18938
11:55:49,680 --> 11:55:55,840
of three bytes but this chunk of four

18939
11:55:52,000 --> 11:55:58,720
bytes or really 12 in total now uh or

18940
11:55:55,840 --> 11:56:02,596
rather 16 now because we have four such

18941
11:55:58,720 --> 11:56:05,436
bytes questions now on this code the

18942
11:56:02,596 --> 11:56:06,916
point of which was quite simply to

18943
11:56:05,436 --> 11:56:09,880
demonstrate how we could Implement and

18944
11:56:06,916 --> 11:56:12,360
code this idea of Fairly correctly but

18945
11:56:09,880 --> 11:56:14,755
inefficiently allocating a new array of

18946
11:56:12,360 --> 11:56:16,916
sufficient size and then populating it

18947
11:56:14,756 --> 11:56:21,240
with a new fourth

18948
11:56:16,916 --> 11:56:24,399
value questions on what we've just done

18949
11:56:21,240 --> 11:56:27,400
here no

18950
11:56:24,400 --> 11:56:27,400
yeah

18951
11:56:30,070 --> 11:56:35,360
[Music]

18952
11:56:33,240 --> 11:56:38,520
good question at this point in the story

18953
11:56:35,360 --> 11:56:40,160
with line 33 do I not have two different

18954
11:56:38,520 --> 11:56:42,320
variables pointing at the same chunk of

18955
11:56:40,160 --> 11:56:44,040
memory short answer yes but here's where

18956
11:56:42,320 --> 11:56:46,080
the semantics are perhaps compelling

18957
11:56:44,040 --> 11:56:47,880
list is the variable that I intend to

18958
11:56:46,080 --> 11:56:49,640
use longer term and keep around in

18959
11:56:47,880 --> 11:56:51,200
memory and again assume that there's

18960
11:56:49,640 --> 11:56:52,640
even more code going on here that we

18961
11:56:51,200 --> 11:56:54,880
just didn't write yet so it's useful to

18962
11:56:52,640 --> 11:56:58,200
have that that variable temp was just

18963
11:56:54,880 --> 11:57:00,115
kind of a necessary evil because up here

18964
11:56:58,200 --> 11:57:02,276
it would not have been correct to do

18965
11:57:00,116 --> 11:57:05,480
this it would not have been correct to

18966
11:57:02,276 --> 11:57:07,115
say list on line 18 equals the new chunk

18967
11:57:05,480 --> 11:57:10,800
of memory because this would have

18968
11:57:07,116 --> 11:57:13,640
represented a memory leak if I pre uh

18969
11:57:10,800 --> 11:57:15,720
prematurely change temp to point not at

18970
11:57:13,640 --> 11:57:17,560
the old chunk but the new chunk at that

18971
11:57:15,720 --> 11:57:19,916
point no one's pointing at the old chunk

18972
11:57:17,560 --> 11:57:21,399
and so I've lost those three bites vren

18973
11:57:19,916 --> 11:57:24,640
for instance would yell at you for

18974
11:57:21,400 --> 11:57:27,116
having lost as many btes in memory so in

18975
11:57:24,640 --> 11:57:29,040
this case here I do leave this as temp

18976
11:57:27,116 --> 11:57:30,720
yes it's duplicative at this point but

18977
11:57:29,040 --> 11:57:32,276
it's it's not a huge deal if it was just

18978
11:57:30,720 --> 11:57:35,640
meant semantically to be a temporary

18979
11:57:32,276 --> 11:57:38,680
value but down here at the risk of one

18980
11:57:35,640 --> 11:57:40,640
more line of code I still want to to be

18981
11:57:38,680 --> 11:57:43,040
a good citizen free list and maybe just

18982
11:57:40,640 --> 11:57:46,596
for good measure return zero explicitly

18983
11:57:43,040 --> 11:57:50,596
but notice it's not doing it twice per

18984
11:57:46,596 --> 11:57:53,799
se on line 31 what am I freeing the

18985
11:57:50,596 --> 11:57:56,479
original address of list the three

18986
11:57:53,800 --> 11:57:57,956
integer version then I change what list

18987
11:57:56,480 --> 11:57:59,320
points at so it's pointing at a

18988
11:57:57,956 --> 11:58:01,436
completely different chunk of memory

18989
11:57:59,320 --> 11:58:03,360
this one of size four So eventually when

18990
11:58:01,436 --> 11:58:05,560
I'm all done using this memory for this

18991
11:58:03,360 --> 11:58:07,480
demonstration I still need to free list

18992
11:58:05,560 --> 11:58:09,360
but at this point in the story line 40

18993
11:58:07,480 --> 11:58:11,680
it's pointing at the new chunk of memory

18994
11:58:09,360 --> 11:58:15,720
which I similarly need to hand back to

18995
11:58:11,680 --> 11:58:15,720
the operating system by free

18996
11:58:16,840 --> 11:58:22,200
yeah when would temp equal null so let

18997
11:58:19,880 --> 11:58:24,079
me scroll back up slightly this is being

18998
11:58:22,200 --> 11:58:27,596
a good citizen and a good programmer

18999
11:58:24,080 --> 11:58:30,480
whenever it comes to using malok malok

19000
11:58:27,596 --> 11:58:32,200
can return null if the computer's out of

19001
11:58:30,480 --> 11:58:33,756
memory so this is maybe a much bigger

19002
11:58:32,200 --> 11:58:35,755
program you've got other things going on

19003
11:58:33,756 --> 11:58:38,200
in it and so you just don't have enough

19004
11:58:35,756 --> 11:58:39,680
memory available to be handed malok

19005
11:58:38,200 --> 11:58:42,399
needs to signal to you that there's some

19006
11:58:39,680 --> 11:58:44,720
error and so it will by convention per

19007
11:58:42,400 --> 11:58:46,916
the documentation per the manual pages

19008
11:58:44,720 --> 11:58:48,640
return null so this is just me being a

19009
11:58:46,916 --> 11:58:50,240
good citizen otherwise here's another

19010
11:58:48,640 --> 11:58:52,360
error that might cause your program to

19011
11:58:50,240 --> 11:58:54,276
crash with a segmentation fault if you

19012
11:58:52,360 --> 11:58:57,956
get back null but you assume that it's

19013
11:58:54,276 --> 11:59:00,276
good memory uh going to address zero AKA

19014
11:58:57,956 --> 11:59:02,100
null will crash your program

19015
11:59:00,276 --> 11:59:06,400
intentionally

19016
11:59:02,100 --> 11:59:06,400
[Music]

19017
11:59:08,436 --> 11:59:15,400
yeah correct if I were to change my

19018
11:59:10,880 --> 11:59:18,276
final line 40 here to be free temp this

19019
11:59:15,400 --> 11:59:20,520
would also work as well and here this is

19020
11:59:18,276 --> 11:59:22,240
really a matter of design it's a very

19021
11:59:20,520 --> 11:59:24,479
nitpicky thing we could probably debate

19022
11:59:22,240 --> 11:59:27,276
it but because at this point in the

19023
11:59:24,480 --> 11:59:29,276
story my main variable for remembering

19024
11:59:27,276 --> 11:59:31,000
where the list is is called list this is

19025
11:59:29,276 --> 11:59:32,916
sort of the more responsible way to do

19026
11:59:31,000 --> 11:59:35,320
it freeing the list just so that my

19027
11:59:32,916 --> 11:59:37,200
colleagues my ta doesn't sort of wonder

19028
11:59:35,320 --> 11:59:38,956
why are you freeing temporary ver memory

19029
11:59:37,200 --> 11:59:40,435
that you already freed like it just is a

19030
11:59:38,956 --> 11:59:42,956
semantic thing at this point but good

19031
11:59:40,436 --> 11:59:45,436
Instinct it would also work correct

19032
11:59:42,956 --> 11:59:46,756
maybe just not good design all right so

19033
11:59:45,436 --> 11:59:48,520
it turns out that this gets annoying

19034
11:59:46,756 --> 11:59:50,596
quickly as it did in the picture of

19035
11:59:48,520 --> 11:59:52,276
doing all of this duplication and even

19036
11:59:50,596 --> 11:59:54,240
though technically it's necessary to

19037
11:59:52,276 --> 11:59:55,680
copy those values if you need a newer

19038
11:59:54,240 --> 11:59:58,276
bigger chunk of memory

19039
11:59:55,680 --> 12:00:00,756
there is at least a function in C that

19040
11:59:58,276 --> 12:00:03,000
simplifies a lot of this for us and in

19041
12:00:00,756 --> 12:00:06,276
fact let me go ahead and do this instead

19042
12:00:03,000 --> 12:00:09,080
of using malok this second time on line

19043
12:00:06,276 --> 12:00:11,520
18 in addition to the first time I used

19044
12:00:09,080 --> 12:00:13,276
it on line six I'm actually going to try

19045
12:00:11,520 --> 12:00:15,680
and introduce another function called

19046
12:00:13,276 --> 12:00:18,200
realloc which as the name suggests tries

19047
12:00:15,680 --> 12:00:20,276
to reallocate memory for you and it

19048
12:00:18,200 --> 12:00:23,000
works a little differently from malok

19049
12:00:20,276 --> 12:00:25,159
realloc expects two arguments the first

19050
12:00:23,000 --> 12:00:27,640
one is what is the chunk of memory that

19051
12:00:25,160 --> 12:00:30,436
you want to try to grow or Shrink that

19052
12:00:27,640 --> 12:00:32,400
is reallocate to be a different size and

19053
12:00:30,436 --> 12:00:35,160
then you specify what size you would

19054
12:00:32,400 --> 12:00:39,116
want and indeed in this case I want four

19055
12:00:35,160 --> 12:00:42,720
times size of int and that will now give

19056
12:00:39,116 --> 12:00:45,640
me hopefully a new address of a chunk of

19057
12:00:42,720 --> 12:00:48,240
memory that's big enough to fit all four

19058
12:00:45,640 --> 12:00:51,756
numbers but what's wonderful about

19059
12:00:48,240 --> 12:00:53,956
realloc is that it will handle all of

19060
12:00:51,756 --> 12:00:56,160
the copying for me so in fact I'm going

19061
12:00:53,956 --> 12:00:59,436
to go down here I'm going to get rid of

19062
12:00:56,160 --> 12:01:02,200
all of this this extra for Loop and what

19063
12:00:59,436 --> 12:01:03,640
I'm simply going to do instead is this

19064
12:01:02,200 --> 12:01:07,680
once I can

19065
12:01:03,640 --> 12:01:09,720
trust after lines 18 through 23 that

19066
12:01:07,680 --> 12:01:11,840
rioc worked and it didn't return null

19067
12:01:09,720 --> 12:01:13,880
because I'm out of memory I can just say

19068
12:01:11,840 --> 12:01:16,240
okay just immediately remember that the

19069
12:01:13,880 --> 12:01:18,916
new list points at this new chunk of

19070
12:01:16,240 --> 12:01:20,680
memory instead and then I can still now

19071
12:01:18,916 --> 12:01:22,719
do this line but I can tweak the

19072
12:01:20,680 --> 12:01:28,680
semantics here and just say list bracket

19073
12:01:22,720 --> 12:01:31,436
3 the new Final a in uh um the new list

19074
12:01:28,680 --> 12:01:33,756
is for I don't need to free this here I

19075
12:01:31,436 --> 12:01:35,800
don't need to do this all I need now at

19076
12:01:33,756 --> 12:01:37,840
the bottom is the final for Loop to just

19077
12:01:35,800 --> 12:01:39,756
print out these values so in short even

19078
12:01:37,840 --> 12:01:43,039
though that was somewhat quick using

19079
12:01:39,756 --> 12:01:44,916
realloc just moves the entire copying

19080
12:01:43,040 --> 12:01:46,800
process that I implemented myself a

19081
12:01:44,916 --> 12:01:48,755
moment ago using a for Loop it just

19082
12:01:46,800 --> 12:01:50,160
moves it to realloc and lets it deal

19083
12:01:48,756 --> 12:01:52,000
with the copying for me it's no more

19084
12:01:50,160 --> 12:01:53,596
efficient but at least means uh I'm

19085
12:01:52,000 --> 12:01:55,360
writing less code which is more pleasant

19086
12:01:53,596 --> 12:01:57,360
and hopefully the people who wrote aloc

19087
12:01:55,360 --> 12:01:59,360
or realloc are smarter than me and they

19088
12:01:57,360 --> 12:02:00,880
just will introduce bugs with lower

19089
12:01:59,360 --> 12:02:04,120
probability

19090
12:02:00,880 --> 12:02:07,168
too all right that was a lot any

19091
12:02:04,120 --> 12:02:07,169
[Music]

19092
12:02:07,480 --> 12:02:12,560
questions good question why do you still

19093
12:02:09,800 --> 12:02:17,560
need to make list equal temp as I did on

19094
12:02:12,560 --> 12:02:21,159
line 24 so ideally I would do this

19095
12:02:17,560 --> 12:02:23,756
ideally I would just change this line 18

19096
12:02:21,160 --> 12:02:25,596
to be list that is to say call re or

19097
12:02:23,756 --> 12:02:27,680
actually even better ideally I would

19098
12:02:25,596 --> 12:02:29,916
just say realloc this list to be of this

19099
12:02:27,680 --> 12:02:31,916
new size but again things can go wrong

19100
12:02:29,916 --> 12:02:33,596
when allocating memory you need to check

19101
12:02:31,916 --> 12:02:36,159
a return value to see if it was

19102
12:02:33,596 --> 12:02:37,916
successful or not and so we need to use

19103
12:02:36,160 --> 12:02:40,640
a return value okay so let's not

19104
12:02:37,916 --> 12:02:42,840
introduce temp let's just use list but

19105
12:02:40,640 --> 12:02:46,116
here's where a memory leak might happen

19106
12:02:42,840 --> 12:02:48,000
in the off chance realloc fails and

19107
12:02:46,116 --> 12:02:50,560
doesn't have enough memory for your four

19108
12:02:48,000 --> 12:02:53,480
bytes therefore it returns by definition

19109
12:02:50,560 --> 12:02:55,479
null you can't overwrite the original

19110
12:02:53,480 --> 12:02:58,000
value of list with null

19111
12:02:55,480 --> 12:02:59,956
to then check it why because now who

19112
12:02:58,000 --> 12:03:02,360
remembers where the original Three byes

19113
12:02:59,956 --> 12:03:04,840
were if you prematurely change the value

19114
12:03:02,360 --> 12:03:06,880
of list you've lost you've uh leaked

19115
12:03:04,840 --> 12:03:09,079
memory in that sense and so that's why

19116
12:03:06,880 --> 12:03:12,000
let me undo this change I declare a

19117
12:03:09,080 --> 12:03:13,840
temporary pointer for the sole purpose

19118
12:03:12,000 --> 12:03:16,116
of making sure I can check the return

19119
12:03:13,840 --> 12:03:18,320
value and then once it's good now I'll

19120
12:03:16,116 --> 12:03:20,756
update the value of list so it's sort of

19121
12:03:18,320 --> 12:03:23,000
doing a Switcheroo by making sure first

19122
12:03:20,756 --> 12:03:26,080
that you have a new value to swap with

19123
12:03:23,000 --> 12:03:28,956
the old other question

19124
12:03:26,080 --> 12:03:28,956
on this code

19125
12:03:32,596 --> 12:03:37,200
yeah indeed realloc automatically frees

19126
12:03:35,480 --> 12:03:39,276
the previous memory for you and better

19127
12:03:37,200 --> 12:03:42,079
yet it's even smarter than that if you

19128
12:03:39,276 --> 12:03:43,720
get lucky and they happens to be space

19129
12:03:42,080 --> 12:03:46,160
right after your existing chunk of

19130
12:03:43,720 --> 12:03:48,560
memory so one two three garbage value

19131
12:03:46,160 --> 12:03:51,080
instead of one two three hello world

19132
12:03:48,560 --> 12:03:53,560
realloc won't even bother copying things

19133
12:03:51,080 --> 12:03:55,400
from old to new it will just say okay

19134
12:03:53,560 --> 12:03:57,479
I'm going to now reserve for you more

19135
12:03:55,400 --> 12:03:59,200
bites than you originally asked for so

19136
12:03:57,480 --> 12:04:00,640
it doesn't have to waste time doing that

19137
12:03:59,200 --> 12:04:02,479
copying and so in that sense this

19138
12:04:00,640 --> 12:04:04,320
version is now not only still correct

19139
12:04:02,480 --> 12:04:06,160
it's even better designed because we're

19140
12:04:04,320 --> 12:04:07,800
not wasting time with that for Loop we

19141
12:04:06,160 --> 12:04:09,480
might have to resort to it if there is

19142
12:04:07,800 --> 12:04:11,520
in fact hello world or something else in

19143
12:04:09,480 --> 12:04:14,436
the way but hopefully we'll get lucky

19144
12:04:11,520 --> 12:04:18,880
and save those steps other questions on

19145
12:04:14,436 --> 12:04:22,240
this this manipulation of code

19146
12:04:18,880 --> 12:04:22,240
here yeah in the

19147
12:04:23,680 --> 12:04:27,840
middle

19148
12:04:26,520 --> 12:04:30,479
what if you want to resize a

19149
12:04:27,840 --> 12:04:33,159
two-dimensional array so very similar in

19150
12:04:30,480 --> 12:04:35,160
Spirit uh whereby you can use the same

19151
12:04:33,160 --> 12:04:37,480
trickery let me wave my hand at that for

19152
12:04:35,160 --> 12:04:38,916
now just because I think that's going to

19153
12:04:37,480 --> 12:04:40,520
sort of significantly increase the

19154
12:04:38,916 --> 12:04:42,560
complexity but very same Primitives

19155
12:04:40,520 --> 12:04:45,079
ultimately a two-dimensional array is

19156
12:04:42,560 --> 12:04:47,680
essentially just a doubly long or

19157
12:04:45,080 --> 12:04:49,640
quadratically longer list of memory that

19158
12:04:47,680 --> 12:04:51,720
using square bracket notation is doing

19159
12:04:49,640 --> 12:04:53,560
some of that mental math for you but

19160
12:04:51,720 --> 12:04:55,560
it's fundamentally no different of

19161
12:04:53,560 --> 12:04:59,276
what's going on underneath the

19162
12:04:55,560 --> 12:05:01,079
hood all right so with that said and

19163
12:04:59,276 --> 12:05:02,640
that code under our belt even though

19164
12:05:01,080 --> 12:05:04,916
that's not going to be something you'll

19165
12:05:02,640 --> 12:05:07,400
frequently need to code yourself let's

19166
12:05:04,916 --> 12:05:09,320
propose now how we might go about

19167
12:05:07,400 --> 12:05:12,116
building some actual data structures

19168
12:05:09,320 --> 12:05:15,400
ourselves the new ingredient here being

19169
12:05:12,116 --> 12:05:17,360
this reality that if you want to resize

19170
12:05:15,400 --> 12:05:19,520
a chunk of memory so is to make room for

19171
12:05:17,360 --> 12:05:21,436
things we now have that ability memory

19172
12:05:19,520 --> 12:05:23,240
addresses and pointers just give us the

19173
12:05:21,436 --> 12:05:25,200
ability to like Point around at things

19174
12:05:23,240 --> 12:05:27,320
and move things around in memory but now

19175
12:05:25,200 --> 12:05:29,240
that we have malok and even realloc you

19176
12:05:27,320 --> 12:05:32,240
can imagine maybe rewinding and you

19177
12:05:29,240 --> 12:05:34,115
could Implement that stack that Q using

19178
12:05:32,240 --> 12:05:36,200
not an array per se because you have to

19179
12:05:34,116 --> 12:05:38,276
commit to an array size in advance but

19180
12:05:36,200 --> 12:05:40,880
if you implement your stack or your que

19181
12:05:38,276 --> 12:05:42,680
using a pointer and then malok and

19182
12:05:40,880 --> 12:05:44,560
realloc and maybe someone else writes

19183
12:05:42,680 --> 12:05:47,200
all that code for you perhaps now you

19184
12:05:44,560 --> 12:05:50,040
can imagine that okay now the stack can

19185
12:05:47,200 --> 12:05:52,079
grow or Shrink by using realloc

19186
12:05:50,040 --> 12:05:54,640
accordingly you don't have to preact pre

19187
12:05:52,080 --> 12:05:57,240
um preemptively say give me five bytes

19188
12:05:54,640 --> 12:05:59,116
or 50 or 500 or 5,000 you can say just

19189
12:05:57,240 --> 12:06:01,436
give me one initially and if I need more

19190
12:05:59,116 --> 12:06:03,200
I'll realloc realloc reloc and if you

19191
12:06:01,436 --> 12:06:05,160
keep popping things off the stack you

19192
12:06:03,200 --> 12:06:07,200
can realloc in the other direction and

19193
12:06:05,160 --> 12:06:08,840
ask for fewer and fewer bytes and the

19194
12:06:07,200 --> 12:06:10,560
operating system can take that memory

19195
12:06:08,840 --> 12:06:12,359
back as well so we now have this

19196
12:06:10,560 --> 12:06:14,360
building block let's see what we can do

19197
12:06:12,360 --> 12:06:16,160
with it so we've had a few pieces of

19198
12:06:14,360 --> 12:06:17,756
syntax in recent weeks all of which

19199
12:06:16,160 --> 12:06:20,480
we're going to combine now in just a

19200
12:06:17,756 --> 12:06:22,000
slightly more clever way so struct is

19201
12:06:20,480 --> 12:06:23,360
this keyword in C that lets us build our

19202
12:06:22,000 --> 12:06:25,116
own structure in memory like a

19203
12:06:23,360 --> 12:06:27,116
collection of two or three or more

19204
12:06:25,116 --> 12:06:31,000
variables like a person that we've seen

19205
12:06:27,116 --> 12:06:33,880
before the dot operator recall we've

19206
12:06:31,000 --> 12:06:36,116
used when you do have a struct like a a

19207
12:06:33,880 --> 12:06:39,880
person and you want to go inside of it

19208
12:06:36,116 --> 12:06:42,200
so like uh person. name or person.

19209
12:06:39,880 --> 12:06:43,799
number we did this a few weeks ago now

19210
12:06:42,200 --> 12:06:45,719
but the dot Operator just allows you to

19211
12:06:43,800 --> 12:06:47,880
go inside of a structure and get the

19212
12:06:45,720 --> 12:06:50,040
individual variables within and then the

19213
12:06:47,880 --> 12:06:52,276
star operator unfortunately has a lot of

19214
12:06:50,040 --> 12:06:54,640
uses now one was multiplication like my

19215
12:06:52,276 --> 12:06:57,240
God that was easy back in the day now

19216
12:06:54,640 --> 12:06:59,596
it's used to declare pointers it's also

19217
12:06:57,240 --> 12:07:02,680
used to dreference pointers so to make

19218
12:06:59,596 --> 12:07:04,479
one exist and then go to that address

19219
12:07:02,680 --> 12:07:06,640
unfortunately it's the same symbol for

19220
12:07:04,480 --> 12:07:08,640
all of those but it's all related but

19221
12:07:06,640 --> 12:07:10,040
with these three symbols it turns out

19222
12:07:08,640 --> 12:07:12,680
you're going to get one last one today

19223
12:07:10,040 --> 12:07:15,000
and my God it finally looks like the

19224
12:07:12,680 --> 12:07:17,116
concept it turns out there's a clever

19225
12:07:15,000 --> 12:07:19,116
way anytime you want to use the dot and

19226
12:07:17,116 --> 12:07:21,520
the star together that is to go

19227
12:07:19,116 --> 12:07:23,480
somewhere and go to an address and then

19228
12:07:21,520 --> 12:07:25,916
look inside of a structure you can

19229
12:07:23,480 --> 12:07:27,240
actually literally use an arrow symbol

19230
12:07:25,916 --> 12:07:30,000
on your keyboard it's not a single

19231
12:07:27,240 --> 12:07:32,079
keystroke it's a hyphen and then an open

19232
12:07:30,000 --> 12:07:33,840
angle bracket but at least it looks like

19233
12:07:32,080 --> 12:07:35,276
an arrow and we'll see indeed in code

19234
12:07:33,840 --> 12:07:36,880
today the things I was drawing

19235
12:07:35,276 --> 12:07:38,799
pictorially on the screen last time with

19236
12:07:36,880 --> 12:07:41,719
yellow arrows you can actually now

19237
12:07:38,800 --> 12:07:44,240
Express as well in code and so here we

19238
12:07:41,720 --> 12:07:46,200
have our next data structure called a

19239
12:07:44,240 --> 12:07:48,956
linked list and this is one of the most

19240
12:07:46,200 --> 12:07:50,240
useful powerful Concepts in C it's the

19241
12:07:48,956 --> 12:07:52,240
kind of thing that you can take for

19242
12:07:50,240 --> 12:07:54,436
granted in Java and Python and higher

19243
12:07:52,240 --> 12:07:56,520
level languages but today we'll see how

19244
12:07:54,436 --> 12:07:59,080
we or others can actually build these

19245
12:07:56,520 --> 12:08:01,399
things just using these same Primitives

19246
12:07:59,080 --> 12:08:04,360
so a linked list is going to allow us to

19247
12:08:01,400 --> 12:08:06,240
actually do what we you know used a foam

19248
12:08:04,360 --> 12:08:07,916
finger for last week allow us to link

19249
12:08:06,240 --> 12:08:09,680
together for instance these three values

19250
12:08:07,916 --> 12:08:11,079
maybe with that fourth value over there

19251
12:08:09,680 --> 12:08:13,080
and then if there's a fifth you know

19252
12:08:11,080 --> 12:08:15,200
maybe this other foam finger points even

19253
12:08:13,080 --> 12:08:17,680
farther overway to that fifth value the

19254
12:08:15,200 --> 12:08:19,755
key being that you can stitch together

19255
12:08:17,680 --> 12:08:21,720
fancier data structures without having

19256
12:08:19,756 --> 12:08:23,680
to like pick all of these up and find

19257
12:08:21,720 --> 12:08:25,480
new space you just have to at least

19258
12:08:23,680 --> 12:08:27,880
connect the dots somehow we just need to

19259
12:08:25,480 --> 12:08:29,400
somehow point from one to the other and

19260
12:08:27,880 --> 12:08:31,799
that's going to make things much more

19261
12:08:29,400 --> 12:08:33,360
efficient it would seem so how do we get

19262
12:08:31,800 --> 12:08:35,276
there so here's my computer's memory as

19263
12:08:33,360 --> 12:08:37,360
always suppose that I'm storing the

19264
12:08:35,276 --> 12:08:40,079
value one somewhere in there and it's at

19265
12:08:37,360 --> 12:08:41,956
ox123 address whatever and I'm storing

19266
12:08:40,080 --> 12:08:45,840
the number two somewhere else in memory

19267
12:08:41,956 --> 12:08:49,956
Ox 456 and number three at address Ox

19268
12:08:45,840 --> 12:08:51,840
789 this is not an array by definition

19269
12:08:49,956 --> 12:08:53,436
why even though it's the only three

19270
12:08:51,840 --> 12:08:56,200
things on the screen what makes this not

19271
12:08:53,436 --> 12:08:58,880
an array it's not contiguous so this

19272
12:08:56,200 --> 12:09:00,360
violates the definition of an array but

19273
12:08:58,880 --> 12:09:02,276
you know especially since they're

19274
12:09:00,360 --> 12:09:04,520
sequential it kind of looks to a human

19275
12:09:02,276 --> 12:09:06,640
like a list so it would be nice if there

19276
12:09:04,520 --> 12:09:09,359
were a data type called list and there

19277
12:09:06,640 --> 12:09:11,320
isn't in C there will be in Python but

19278
12:09:09,360 --> 12:09:13,520
you know what if I could somehow like

19279
12:09:11,320 --> 12:09:15,596
Stitch together these three values so I

19280
12:09:13,520 --> 12:09:17,435
can get from one to the next to the next

19281
12:09:15,596 --> 12:09:19,560
then I think we could achieve the idea

19282
12:09:17,436 --> 12:09:21,400
the concept of a list without this

19283
12:09:19,560 --> 12:09:24,880
really annoying constraint that they all

19284
12:09:21,400 --> 12:09:26,320
be contiguous as in an array so how do I

19285
12:09:24,880 --> 12:09:29,115
do that well at the end of the day I

19286
12:09:26,320 --> 12:09:31,320
only have memory at my disposal right

19287
12:09:29,116 --> 12:09:33,116
there's no more training wheels to take

19288
12:09:31,320 --> 12:09:35,680
off here this is what we've got

19289
12:09:33,116 --> 12:09:37,360
underneath the hood of a computer so if

19290
12:09:35,680 --> 12:09:39,520
all I have is memory I think the

19291
12:09:37,360 --> 12:09:42,680
solution to this problem of stitching

19292
12:09:39,520 --> 12:09:44,520
together those values in a list must be

19293
12:09:42,680 --> 12:09:46,276
to spend a bit more memory that's

19294
12:09:44,520 --> 12:09:48,276
literally the only resource we have

19295
12:09:46,276 --> 12:09:50,320
right now so let me propose that if we

19296
12:09:48,276 --> 12:09:52,520
want to create a list conceptually out

19297
12:09:50,320 --> 12:09:55,116
of three values that are in random

19298
12:09:52,520 --> 12:09:57,435
although pictorially pretty positions in

19299
12:09:55,116 --> 12:09:59,116
memory let me just add a little bit more

19300
12:09:57,436 --> 12:10:00,880
memory to the picture so in addition to

19301
12:09:59,116 --> 12:10:02,680
storing the one I'm going to leave my

19302
12:10:00,880 --> 12:10:04,520
space myself some room a little scratch

19303
12:10:02,680 --> 12:10:06,680
pad if you will to use some other bits

19304
12:10:04,520 --> 12:10:09,159
as well same for the two same for the

19305
12:10:06,680 --> 12:10:12,560
three and you can perhaps see where this

19306
12:10:09,160 --> 12:10:17,720
is going based on last week if I want to

19307
12:10:12,560 --> 12:10:20,276
somehow connect the one to the two any

19308
12:10:17,720 --> 12:10:22,240
instincts as to what I should write in

19309
12:10:20,276 --> 12:10:25,840
this box here that would lead me

19310
12:10:22,240 --> 12:10:28,720
effectively from one to the two

19311
12:10:25,840 --> 12:10:28,719
what could go here

19312
12:10:30,116 --> 12:10:33,360
yeah we could store the address of Two

19313
12:10:32,200 --> 12:10:35,799
And so specifically what would you have

19314
12:10:33,360 --> 12:10:35,800
me write

19315
12:10:37,956 --> 12:10:43,040
here perfect ideally I would just put in

19316
12:10:40,720 --> 12:10:45,040
this box another integer one that

19317
12:10:43,040 --> 12:10:46,560
happens to be represented in heximal but

19318
12:10:45,040 --> 12:10:48,756
that's just a base system it's just a

19319
12:10:46,560 --> 12:10:51,799
human thing for us to look at I'm going

19320
12:10:48,756 --> 12:10:54,360
to put the value Ox 456 here so let me

19321
12:10:51,800 --> 12:10:55,956
go ahead and reveal that Ox 456 goes

19322
12:10:54,360 --> 12:10:57,240
there you can perhaps see further where

19323
12:10:55,956 --> 12:10:59,436
this is going well if I want to get from

19324
12:10:57,240 --> 12:11:01,320
the two to the three I think I need to

19325
12:10:59,436 --> 12:11:04,756
put below the two the address of the

19326
12:11:01,320 --> 12:11:06,800
three which gives me Ox 789 now if three

19327
12:11:04,756 --> 12:11:08,720
is the end of the list I don't want to

19328
12:11:06,800 --> 12:11:10,436
let it be some garbage value because

19329
12:11:08,720 --> 12:11:12,276
that would imply that it who knows where

19330
12:11:10,436 --> 12:11:13,720
it's pointing I need some definitive

19331
12:11:12,276 --> 12:11:16,479
value and just what would your instincts

19332
12:11:13,720 --> 12:11:18,720
be if I want to make clear with some

19333
12:11:16,480 --> 12:11:21,116
special Sentinel value that the buck

19334
12:11:18,720 --> 12:11:24,680
stops here what do I put what my my

19335
12:11:21,116 --> 12:11:27,680
options be yeah so null not n per se but

19336
12:11:24,680 --> 12:11:29,520
n l which was the new keyword we

19337
12:11:27,680 --> 12:11:32,200
introduced last week which just

19338
12:11:29,520 --> 12:11:35,200
represents an empty pointer if you will

19339
12:11:32,200 --> 12:11:37,276
technically the address o x0 so

19340
12:11:35,200 --> 12:11:39,000
literally the zero address and what

19341
12:11:37,276 --> 12:11:41,276
humans did years ago they just decided

19342
12:11:39,000 --> 12:11:43,240
you know what nothing should ever live

19343
12:11:41,276 --> 12:11:45,520
at address zero in memory we're just

19344
12:11:43,240 --> 12:11:47,840
going to reserve that one special bite

19345
12:11:45,520 --> 12:11:50,039
to be a special signal a sentinel value

19346
12:11:47,840 --> 12:11:52,079
such that if you ever see a zero address

19347
12:11:50,040 --> 12:11:54,360
in a pointer it just means it's it's

19348
12:11:52,080 --> 12:11:55,596
invalid it does not exist now now we

19349
12:11:54,360 --> 12:11:58,276
write that though a little more

19350
12:11:55,596 --> 12:12:00,200
pleasantly for the eyes as just n l in

19351
12:11:58,276 --> 12:12:01,916
all caps and that's a key word in C as

19352
12:12:00,200 --> 12:12:03,840
well but of course last week I claimed

19353
12:12:01,916 --> 12:12:05,560
that who cares where things are in

19354
12:12:03,840 --> 12:12:07,359
memory and honestly like this quickly

19355
12:12:05,560 --> 12:12:09,399
gets tedious even worrying about these

19356
12:12:07,360 --> 12:12:11,680
values so let me abstract this away and

19357
12:12:09,400 --> 12:12:14,040
propose that if we want to remember

19358
12:12:11,680 --> 12:12:16,040
where all of these numbers are in memory

19359
12:12:14,040 --> 12:12:19,160
let's give oursel one final piece of

19360
12:12:16,040 --> 12:12:21,436
memory that just allows us to start the

19361
12:12:19,160 --> 12:12:23,520
whole process let me allocate on the

19362
12:12:21,436 --> 12:12:26,240
left hand side here not room for a

19363
12:12:23,520 --> 12:12:28,435
number like 1 two 3 just room for a

19364
12:12:26,240 --> 12:12:31,596
pointer that henceforth I think I'll

19365
12:12:28,436 --> 12:12:34,680
call list by convention and then store

19366
12:12:31,596 --> 12:12:36,520
in that one additional pointer a value

19367
12:12:34,680 --> 12:12:38,160
that just kickstarts the whole process

19368
12:12:36,520 --> 12:12:40,320
this is the sort of treasure map if you

19369
12:12:38,160 --> 12:12:43,360
will that you get handed and this has

19370
12:12:40,320 --> 12:12:46,000
the address of the very first actual

19371
12:12:43,360 --> 12:12:47,436
node in memory now technically we could

19372
12:12:46,000 --> 12:12:49,200
just start with this but it turns out

19373
12:12:47,436 --> 12:12:52,000
we'll see it's just a little cleaner to

19374
12:12:49,200 --> 12:12:53,755
use a simple single pointer that leads

19375
12:12:52,000 --> 12:12:55,640
to the things you care about as opposed

19376
12:12:53,756 --> 12:12:57,276
to just starting with the first element

19377
12:12:55,640 --> 12:12:59,276
why well if you ever want to get rid of

19378
12:12:57,276 --> 12:13:00,756
this element it'd be nice if you could

19379
12:12:59,276 --> 12:13:02,720
at least still hang on to an empty sheet

19380
12:13:00,756 --> 12:13:05,000
of paper that indicates that the list is

19381
12:13:02,720 --> 12:13:06,640
empty would be one argument for that so

19382
12:13:05,000 --> 12:13:09,040
again who cares about these addresses

19383
12:13:06,640 --> 12:13:11,240
now now with the wave of the hand let's

19384
12:13:09,040 --> 12:13:13,800
just abstract it away and there are our

19385
12:13:11,240 --> 12:13:16,000
pointers each of those addresses in the

19386
12:13:13,800 --> 12:13:18,916
rec uh the squares at the bottom are

19387
12:13:16,000 --> 12:13:21,080
simply pointing to the next element in

19388
12:13:18,916 --> 12:13:22,520
the list the jargon to introduce here

19389
12:13:21,080 --> 12:13:25,116
would be that now that we have these

19390
12:13:22,520 --> 12:13:27,359
integers 1 2 3 but they're in these like

19391
12:13:25,116 --> 12:13:29,840
wrappers if you will these structures

19392
12:13:27,360 --> 12:13:32,520
that have metadata that is additional

19393
12:13:29,840 --> 12:13:34,399
data that is related to but not the data

19394
12:13:32,520 --> 12:13:36,479
you actually care about this is data

19395
12:13:34,400 --> 12:13:39,520
this is metadata this thing here

19396
12:13:36,480 --> 12:13:40,956
rectangularly we'll call a node n o and

19397
12:13:39,520 --> 12:13:43,596
it's just a term of art that means it's

19398
12:13:40,956 --> 12:13:44,560
like a container in code for storing

19399
12:13:43,596 --> 12:13:47,680
some

19400
12:13:44,560 --> 12:13:50,360
values this then is a linked list and

19401
12:13:47,680 --> 12:13:52,756
this then is the sort of graphical

19402
12:13:50,360 --> 12:13:54,520
incarnation of like one node pointing to

19403
12:13:52,756 --> 12:13:56,480
the other in this case case they happen

19404
12:13:54,520 --> 12:13:59,359
to be by chance and by design of this

19405
12:13:56,480 --> 12:14:00,916
desk contiguous initially but there's no

19406
12:13:59,360 --> 12:14:02,240
requirement that they be such the one

19407
12:14:00,916 --> 12:14:03,479
could be over there the two over there

19408
12:14:02,240 --> 12:14:05,880
the three over there I would just need

19409
12:14:03,480 --> 12:14:08,840
more foam fingers to point at one to the

19410
12:14:05,880 --> 12:14:10,399
next questions on this concept of a

19411
12:14:08,840 --> 12:14:13,799
linked

19412
12:14:10,400 --> 12:14:13,800
list yeah and

19413
12:14:14,270 --> 12:14:20,435
[Music]

19414
12:14:16,916 --> 12:14:20,435
back can you say that

19415
12:14:22,800 --> 12:14:27,360
again a good question do traditional

19416
12:14:25,720 --> 12:14:29,720
arrays start with a pointer that's

19417
12:14:27,360 --> 12:14:32,400
outside of the structure short answer no

19418
12:14:29,720 --> 12:14:34,840
arrays are special in C and certain

19419
12:14:32,400 --> 12:14:37,756
other languages and the name of an array

19420
12:14:34,840 --> 12:14:40,359
is technically a symbol if you will that

19421
12:14:37,756 --> 12:14:42,360
the computer the program knows maps to a

19422
12:14:40,360 --> 12:14:45,956
specific location in memory it's just a

19423
12:14:42,360 --> 12:14:48,276
label a synonym for a memory address it

19424
12:14:45,956 --> 12:14:50,436
does not take up space so to be clear

19425
12:14:48,276 --> 12:14:52,880
the name of an array does not take up

19426
12:14:50,436 --> 12:14:54,480
space like that extra Square on the left

19427
12:14:52,880 --> 12:14:56,115
but you do need that extra Square on the

19428
12:14:54,480 --> 12:14:58,520
left when implementing a link list so

19429
12:14:56,116 --> 12:15:00,240
that you can determine if the list is of

19430
12:14:58,520 --> 12:15:03,115
size zero there's nothing being pointed

19431
12:15:00,240 --> 12:15:05,276
at or size three in this case we're sort

19432
12:15:03,116 --> 12:15:08,276
of taking on more responsibility

19433
12:15:05,276 --> 12:15:08,276
ourselves

19434
12:15:12,040 --> 12:15:16,700
yeah how do you point to the next

19435
12:15:14,360 --> 12:15:19,820
element can you

19436
12:15:16,700 --> 12:15:19,820
[Music]

19437
12:15:20,040 --> 12:15:23,560
elaborate ah good question if each of

19438
12:15:22,160 --> 12:15:25,956
these elements is pointing to the next

19439
12:15:23,560 --> 12:15:27,720
how is three point to the others short

19440
12:15:25,956 --> 12:15:29,276
answer it doesn't at least in this

19441
12:15:27,720 --> 12:15:32,080
design we have more technically what's

19442
12:15:29,276 --> 12:15:34,040
called a singly linked list and as the

19443
12:15:32,080 --> 12:15:36,320
arrows imply it only goes in One

19444
12:15:34,040 --> 12:15:38,320
Direction so if you somehow find incode

19445
12:15:36,320 --> 12:15:40,840
maybe a for Loop maybe a while loop

19446
12:15:38,320 --> 12:15:43,956
somehow you're sort of encode over here

19447
12:15:40,840 --> 12:15:45,916
you have no way in code to go backwards

19448
12:15:43,956 --> 12:15:49,080
unless we changed this to a doubly link

19449
12:15:45,916 --> 12:15:51,240
list where I add another box that lets

19450
12:15:49,080 --> 12:15:53,840
me have arrows in both directions or

19451
12:15:51,240 --> 12:15:56,360
maybe I just kind of make it uh uh

19452
12:15:53,840 --> 12:15:58,359
circular and I connect the three back to

19453
12:15:56,360 --> 12:16:00,240
the one which you can totally do but

19454
12:15:58,360 --> 12:16:01,520
that tends to you know make life harder

19455
12:16:00,240 --> 12:16:02,880
because now you have to figure out when

19456
12:16:01,520 --> 12:16:04,880
you're stuck in a loop in your data

19457
12:16:02,880 --> 12:16:08,000
structure but it's doable as well but as

19458
12:16:04,880 --> 12:16:11,640
is it's a dead end by Design other

19459
12:16:08,000 --> 12:16:11,640
questions on this design

19460
12:16:12,080 --> 12:16:15,756
here all right well how might we

19461
12:16:14,080 --> 12:16:17,116
implement this structure in code well

19462
12:16:15,756 --> 12:16:19,360
let me just connect the dots to

19463
12:16:17,116 --> 12:16:21,000
something like we've seen before here

19464
12:16:19,360 --> 12:16:23,956
like this is how a couple of weeks ago

19465
12:16:21,000 --> 12:16:25,400
we introduced the notion of a a person

19466
12:16:23,956 --> 12:16:27,436
and we claimed a person might have a

19467
12:16:25,400 --> 12:16:28,680
name and a number last week of course we

19468
12:16:27,436 --> 12:16:30,160
took off some of these training wheels

19469
12:16:28,680 --> 12:16:32,720
and a string is really technically a

19470
12:16:30,160 --> 12:16:34,520
Char star in both cases but really

19471
12:16:32,720 --> 12:16:37,680
there's no conceptual difference beyond

19472
12:16:34,520 --> 12:16:40,479
that but let's use this same Paradigm to

19473
12:16:37,680 --> 12:16:42,040
implement a node as I described it in

19474
12:16:40,480 --> 12:16:43,116
that picture so let me get rid of the

19475
12:16:42,040 --> 12:16:45,080
name and the number because that's

19476
12:16:43,116 --> 12:16:47,480
related only to a person and let me

19477
12:16:45,080 --> 12:16:49,756
rename this structure for discussion

19478
12:16:47,480 --> 12:16:52,200
sake to node that then invites the

19479
12:16:49,756 --> 12:16:55,400
question well what needs to go inside of

19480
12:16:52,200 --> 12:16:58,596
a node well minimally an

19481
12:16:55,400 --> 12:17:00,640
integer but this is now where we need to

19482
12:16:58,596 --> 12:17:02,115
think a little harder just conceptually

19483
12:17:00,640 --> 12:17:04,479
even if you have no idea how to type it

19484
12:17:02,116 --> 12:17:06,160
at the keyboard what else needs to be

19485
12:17:04,480 --> 12:17:08,756
part of a node based on these

19486
12:17:06,160 --> 12:17:12,596
rectangular pictures that we've

19487
12:17:08,756 --> 12:17:15,320
drawn what more do we need

19488
12:17:12,596 --> 12:17:17,680
yeah yeah we need a pointer to another

19489
12:17:15,320 --> 12:17:20,400
node so if I don't know how to implement

19490
12:17:17,680 --> 12:17:22,160
this yet you know it could be something

19491
12:17:20,400 --> 12:17:23,956
like you know pointer to another node

19492
12:17:22,160 --> 12:17:26,640
how do I do that well you know what but

19493
12:17:23,956 --> 12:17:30,436
it turns out you would ideally say this

19494
12:17:26,640 --> 12:17:33,000
if you know that the next node is itself

19495
12:17:30,436 --> 12:17:34,916
a node by definition well anytime we've

19496
12:17:33,000 --> 12:17:36,520
needed a pointer we just use the data

19497
12:17:34,916 --> 12:17:38,479
type and a star and I'm going to

19498
12:17:36,520 --> 12:17:41,079
arbitrarily but I think reasonably call

19499
12:17:38,480 --> 12:17:44,040
this second square at the bottom of

19500
12:17:41,080 --> 12:17:46,840
those rectangles next as the name of my

19501
12:17:44,040 --> 12:17:49,360
attribute here but node star just

19502
12:17:46,840 --> 12:17:51,679
connotes that the next variable is going

19503
12:17:49,360 --> 12:17:53,640
to be not a node per se but the address

19504
12:17:51,680 --> 12:17:57,560
of a node and that's exactly what we did

19505
12:17:53,640 --> 12:17:59,596
you had me put Ox 456 Ox 789 in that box

19506
12:17:57,560 --> 12:18:01,200
which is the address of another node so

19507
12:17:59,596 --> 12:18:04,435
the way we would Express this in code

19508
12:18:01,200 --> 12:18:07,159
would be node star next but we could

19509
12:18:04,436 --> 12:18:09,480
call the variable anything we want now

19510
12:18:07,160 --> 12:18:11,116
this is a bit of a white lie but we'll

19511
12:18:09,480 --> 12:18:13,756
fix this right now this code won't

19512
12:18:11,116 --> 12:18:16,200
actually compile C takes you pretty

19513
12:18:13,756 --> 12:18:18,680
literally recall and if you use some

19514
12:18:16,200 --> 12:18:20,640
term at the top of your file that you

19515
12:18:18,680 --> 12:18:22,040
don't Define until later in your file

19516
12:18:20,640 --> 12:18:23,116
you're going to see some error message

19517
12:18:22,040 --> 12:18:25,040
right we've seen this when I've messed

19518
12:18:23,116 --> 12:18:27,080
up and forgot to include the function

19519
12:18:25,040 --> 12:18:29,480
prototypes at the top of my code this is

19520
12:18:27,080 --> 12:18:31,720
related in spirit I seem here on my 1

19521
12:18:29,480 --> 12:18:33,840
two 3 fourth line of code I'm trying to

19522
12:18:31,720 --> 12:18:35,680
use this new term of art that I invented

19523
12:18:33,840 --> 12:18:39,039
here in my code called node even though

19524
12:18:35,680 --> 12:18:40,880
it's a CS term as well but nowhere Above

19525
12:18:39,040 --> 12:18:42,596
This it would seem did I even Define

19526
12:18:40,880 --> 12:18:44,240
what a node is it's not a data type and

19527
12:18:42,596 --> 12:18:45,840
C every computer scientist know what a

19528
12:18:44,240 --> 12:18:48,720
node is but it doesn't come for free

19529
12:18:45,840 --> 12:18:50,479
with the language so I need to do

19530
12:18:48,720 --> 12:18:53,160
something else like I need this word

19531
12:18:50,480 --> 12:18:54,640
here to come first so that I can use it

19532
12:18:53,160 --> 12:18:58,200
here and so we have this sort of Catch

19533
12:18:54,640 --> 12:19:00,080
22 like how can a structure be

19534
12:18:58,200 --> 12:19:02,719
self-referential that is point to

19535
12:19:00,080 --> 12:19:04,596
another version of itself if the word

19536
12:19:02,720 --> 12:19:06,840
doesn't yet exist so the solution to

19537
12:19:04,596 --> 12:19:09,115
this in C which we didn't need for a

19538
12:19:06,840 --> 12:19:11,755
person because there was no notion of

19539
12:19:09,116 --> 12:19:13,880
listing connecting as a list we need one

19540
12:19:11,756 --> 12:19:16,160
more keyword here that we didn't need

19541
12:19:13,880 --> 12:19:18,880
for a person and we reuse that keyword

19542
12:19:16,160 --> 12:19:21,596
here so kind of an annoying detail but

19543
12:19:18,880 --> 12:19:24,840
if we preemptively call this whole thing

19544
12:19:21,596 --> 12:19:26,840
struct node you can now refer to the

19545
12:19:24,840 --> 12:19:29,079
thing on the inside as a struct node

19546
12:19:26,840 --> 12:19:32,200
star but then you can shorten the name

19547
12:19:29,080 --> 12:19:34,276
of the whole thing from struct node to

19548
12:19:32,200 --> 12:19:35,880
just node sort of an annoying sequence

19549
12:19:34,276 --> 12:19:38,360
of steps but in short anytime you're

19550
12:19:35,880 --> 12:19:40,115
building a node a linked list in memory

19551
12:19:38,360 --> 12:19:41,800
this is just the Paradigm you use type

19552
12:19:40,116 --> 12:19:44,116
def struct the name of the thing you

19553
12:19:41,800 --> 12:19:46,116
want to Define like node you use that

19554
12:19:44,116 --> 12:19:47,800
name on the inside if you want to point

19555
12:19:46,116 --> 12:19:51,116
from one to another and then you can

19556
12:19:47,800 --> 12:19:55,916
shorten it down here to just be called

19557
12:19:51,116 --> 12:20:00,040
node questions then on this code

19558
12:19:55,916 --> 12:20:03,079
here questions on what we just did well

19559
12:20:00,040 --> 12:20:05,520
if I rewind just a moment to that final

19560
12:20:03,080 --> 12:20:06,880
picture what would be the upside to be

19561
12:20:05,520 --> 12:20:10,115
clear of having jumped through these

19562
12:20:06,880 --> 12:20:12,200
hoops and added this complexity if you

19563
12:20:10,116 --> 12:20:14,680
will what problem did we just solve by

19564
12:20:12,200 --> 12:20:15,600
linking together these three values to

19565
12:20:14,680 --> 12:20:17,116
be clear

19566
12:20:15,600 --> 12:20:20,799
[Music]

19567
12:20:17,116 --> 12:20:23,320
yeah making lists that

19568
12:20:20,800 --> 12:20:25,320
are that are not contiguous if you will

19569
12:20:23,320 --> 12:20:27,640
so making lists that are not contiguous

19570
12:20:25,320 --> 12:20:29,200
in memory the upside of which is that if

19571
12:20:27,640 --> 12:20:31,200
I want to add the number four to this

19572
12:20:29,200 --> 12:20:33,159
list it looks like I could choose from

19573
12:20:31,200 --> 12:20:35,560
any chunks of available memory on the

19574
12:20:33,160 --> 12:20:38,276
screen I just need to sort of point from

19575
12:20:35,560 --> 12:20:39,916
the end of the current list to wherever

19576
12:20:38,276 --> 12:20:42,400
that other one is in memory what I don't

19577
12:20:39,916 --> 12:20:44,159
need to do to be clear is copy the One

19578
12:20:42,400 --> 12:20:47,040
the two or the three everything can just

19579
12:20:44,160 --> 12:20:48,756
stay put which means TimeWise I can do

19580
12:20:47,040 --> 12:20:50,400
this much more quickly it would seem

19581
12:20:48,756 --> 12:20:52,800
without copying things again and again

19582
12:20:50,400 --> 12:20:54,956
and even without using realloc to let it

19583
12:20:52,800 --> 12:20:56,680
do all of the copying potentially for me

19584
12:20:54,956 --> 12:20:58,436
all right but as we'll start seeing even

19585
12:20:56,680 --> 12:21:00,916
more in the coming weeks every time we

19586
12:20:58,436 --> 12:21:03,680
benefit and solve some problem we pay a

19587
12:21:00,916 --> 12:21:05,840
price there's a tradeoff what is a

19588
12:21:03,680 --> 12:21:09,436
downside as you might perceive now of

19589
12:21:05,840 --> 12:21:12,000
using a linked list instead of an array

19590
12:21:09,436 --> 12:21:13,596
yeah as much memory yeah I mean we use

19591
12:21:12,000 --> 12:21:15,160
twice as much memory because now in

19592
12:21:13,596 --> 12:21:17,560
addition to storing the integers one two

19593
12:21:15,160 --> 12:21:19,200
three I also need to store a pointer for

19594
12:21:17,560 --> 12:21:21,840
each of those and honestly even this

19595
12:21:19,200 --> 12:21:23,680
picture is a bit of uh simplification

19596
12:21:21,840 --> 12:21:25,719
technically in most systems today each

19597
12:21:23,680 --> 12:21:27,360
int would be four bytes technically

19598
12:21:25,720 --> 12:21:28,956
today most pointers though would be

19599
12:21:27,360 --> 12:21:30,520
eight bytes I just didn't want to draw

19600
12:21:28,956 --> 12:21:31,956
this weird shape on the board where the

19601
12:21:30,520 --> 12:21:34,000
bottom square is even bigger than the

19602
12:21:31,956 --> 12:21:36,040
top square but technically we're using

19603
12:21:34,000 --> 12:21:37,720
even more than twice as much space for

19604
12:21:36,040 --> 12:21:39,720
these pointers so there's that trade-off

19605
12:21:37,720 --> 12:21:41,680
now thankfully decades after SE was

19606
12:21:39,720 --> 12:21:43,800
invented memory is generally much

19607
12:21:41,680 --> 12:21:45,596
cheaper nowadays and so it's okay to

19608
12:21:43,800 --> 12:21:46,640
sort of spend more of it if you need to

19609
12:21:45,596 --> 12:21:48,596
and it depends on what you want to

19610
12:21:46,640 --> 12:21:50,840
optimize for but that's absolutely here

19611
12:21:48,596 --> 12:21:55,159
a downside what's another downside of

19612
12:21:50,840 --> 12:21:55,159
having transitioned to in a uh link list

19613
12:21:55,320 --> 12:22:00,240
you can't index into it now I haven't

19614
12:21:58,040 --> 12:22:03,320
even tried in code but when you have a

19615
12:22:00,240 --> 12:22:06,436
linked list you can no longer use square

19616
12:22:03,320 --> 12:22:08,116
bracket notation because why well square

19617
12:22:06,436 --> 12:22:10,436
bracket notation just assumes the

19618
12:22:08,116 --> 12:22:12,756
contiguousness of memory location zero

19619
12:22:10,436 --> 12:22:14,436
is here location one is literally one to

19620
12:22:12,756 --> 12:22:16,160
the right location two is literally one

19621
12:22:14,436 --> 12:22:17,640
to the right one to the right these

19622
12:22:16,160 --> 12:22:19,956
things even though I've drawn it from

19623
12:22:17,640 --> 12:22:22,240
right to left to just keep things pretty

19624
12:22:19,956 --> 12:22:23,720
there are gaps here and this is just my

19625
12:22:22,240 --> 12:22:25,520
interpretation of this these gaps could

19626
12:22:23,720 --> 12:22:27,360
be big they could be narrow they could

19627
12:22:25,520 --> 12:22:29,359
be down here up here they could be

19628
12:22:27,360 --> 12:22:31,800
anywhere so long as we're linking things

19629
12:22:29,360 --> 12:22:33,596
together in this list the computer can't

19630
12:22:31,800 --> 12:22:35,400
just use bracket zero bracket 1 bracket

19631
12:22:33,596 --> 12:22:37,880
two anymore because it can't do simple

19632
12:22:35,400 --> 12:22:39,560
arithmetic and jump to like the middle

19633
12:22:37,880 --> 12:22:41,399
and now here's perhaps the worst price

19634
12:22:39,560 --> 12:22:43,320
we've paid if you don't have square

19635
12:22:41,400 --> 12:22:44,160
bracket notation or really you don't

19636
12:22:43,320 --> 12:22:46,240
have

19637
12:22:44,160 --> 12:22:48,640
contiguousness what algorithm did we

19638
12:22:46,240 --> 12:22:52,079
just sacrifice for this

19639
12:22:48,640 --> 12:22:56,040
dynamism if you rewind even back to week

19640
12:22:52,080 --> 12:22:58,880
zero and we gave it a name in week

19641
12:22:56,040 --> 12:23:00,520
three what algorithm can we not use now

19642
12:22:58,880 --> 12:23:02,640
if we can't assume that the memory is

19643
12:23:00,520 --> 12:23:06,755
back to back to back to

19644
12:23:02,640 --> 12:23:08,560
back binary search why because binary

19645
12:23:06,756 --> 12:23:10,916
search just like the phone book back in

19646
12:23:08,560 --> 12:23:12,956
the first week requires being able to

19647
12:23:10,916 --> 12:23:14,596
arithmetically jump right to the middle

19648
12:23:12,956 --> 12:23:16,080
right take the total length of it divide

19649
12:23:14,596 --> 12:23:18,159
by two and boom you're right there in

19650
12:23:16,080 --> 12:23:20,916
the Middle with some simple arithmetic

19651
12:23:18,160 --> 12:23:23,240
here they might be laid out again with

19652
12:23:20,916 --> 12:23:24,799
these big or small gaps there's no

19653
12:23:23,240 --> 12:23:26,400
simple math I can do to just jump

19654
12:23:24,800 --> 12:23:28,400
immediately to the one in the middle and

19655
12:23:26,400 --> 12:23:29,956
in fact again if this TV were bigger the

19656
12:23:28,400 --> 12:23:32,520
two could technically be in memory be

19657
12:23:29,956 --> 12:23:33,916
way down here or even way over here the

19658
12:23:32,520 --> 12:23:35,320
foam finger could be pointing in any

19659
12:23:33,916 --> 12:23:37,435
number of directions depending on where

19660
12:23:35,320 --> 12:23:39,756
malok put the thing there's just no way

19661
12:23:37,436 --> 12:23:41,596
to do binary search and so it would seem

19662
12:23:39,756 --> 12:23:43,800
that we've paid another price indeed in

19663
12:23:41,596 --> 12:23:46,520
terms of it performance we're now

19664
12:23:43,800 --> 12:23:48,520
talking about linear time again so

19665
12:23:46,520 --> 12:23:50,479
that's a regression now that's also a

19666
12:23:48,520 --> 12:23:51,799
lot things like feels like a good time

19667
12:23:50,480 --> 12:23:53,400
for some muffins and fruit out in the

19668
12:23:51,800 --> 12:23:55,116
lobby and when we come back we'll try to

19669
12:23:53,400 --> 12:23:58,040
solve the problem we just created so see

19670
12:23:55,116 --> 12:23:59,596
you in 10 so we are back and let's see

19671
12:23:58,040 --> 12:24:01,480
if we can't now take some of these

19672
12:23:59,596 --> 12:24:03,159
higher level concepts of like stitching

19673
12:24:01,480 --> 12:24:05,436
together these nodes in memory and

19674
12:24:03,160 --> 12:24:07,040
translate it to some actual code but

19675
12:24:05,436 --> 12:24:08,596
we'll do it step by step first before I

19676
12:24:07,040 --> 12:24:09,800
actually start writing it in vs code so

19677
12:24:08,596 --> 12:24:12,000
if Carter you wouldn't mind helping me

19678
12:24:09,800 --> 12:24:14,160
step through with some visuals let me

19679
12:24:12,000 --> 12:24:15,436
propose that line by line we solve some

19680
12:24:14,160 --> 12:24:17,360
of the problems that we've just created

19681
12:24:15,436 --> 12:24:20,520
for ourselves in building this thing in

19682
12:24:17,360 --> 12:24:23,000
memory so let's go ahead and first

19683
12:24:20,520 --> 12:24:25,399
consider how we could build a length

19684
12:24:23,000 --> 12:24:27,276
list containing the numbers indeed one

19685
12:24:25,400 --> 12:24:28,480
then two then three and let's translate

19686
12:24:27,276 --> 12:24:29,799
each of those steps to code and then

19687
12:24:28,480 --> 12:24:31,640
we'll put it all together into something

19688
12:24:29,800 --> 12:24:34,000
that actually runs so how about first

19689
12:24:31,640 --> 12:24:37,040
step here will just be this to declare a

19690
12:24:34,000 --> 12:24:38,596
pointer called list that's initially has

19691
12:24:37,040 --> 12:24:40,840
no value at least at this point in the

19692
12:24:38,596 --> 12:24:42,756
story list is the name of the variable

19693
12:24:40,840 --> 12:24:44,240
node star just means that this is

19694
12:24:42,756 --> 12:24:46,756
essentially going to be our little

19695
12:24:44,240 --> 12:24:48,880
square over here that points to the

19696
12:24:46,756 --> 12:24:50,956
beginning of the list of course it's

19697
12:24:48,880 --> 12:24:53,435
ideal If It ultimately has a value

19698
12:24:50,956 --> 12:24:55,756
because when we initially I'll call this

19699
12:24:53,436 --> 12:24:57,400
line of code it just gives us indeed

19700
12:24:55,756 --> 12:24:58,680
that square over here on the left but

19701
12:24:57,400 --> 12:25:01,276
it's got a garbage value because there's

19702
12:24:58,680 --> 12:25:02,956
no equal sign on the other side there so

19703
12:25:01,276 --> 12:25:05,880
let's propose that we do one more step

19704
12:25:02,956 --> 12:25:08,276
here and actually initialize it to null

19705
12:25:05,880 --> 12:25:10,680
so that if only we know that it's not

19706
12:25:08,276 --> 12:25:12,240
garbage it at least has some known value

19707
12:25:10,680 --> 12:25:13,640
and null is a good way of signifying

19708
12:25:12,240 --> 12:25:16,400
that at this point in the story The List

19709
12:25:13,640 --> 12:25:18,479
is empty indeed null indicates there's

19710
12:25:16,400 --> 12:25:20,200
no nodes in the list so that picture

19711
12:25:18,480 --> 12:25:21,480
would now look like this whereby let's

19712
12:25:20,200 --> 12:25:22,840
just draw instead of writing null

19713
12:25:21,480 --> 12:25:24,520
everywhere I'll just leave the squares

19714
12:25:22,840 --> 12:25:27,479
blank when it's not a garbage value per

19715
12:25:24,520 --> 12:25:29,560
se it's literally Ox Z or null all right

19716
12:25:27,480 --> 12:25:32,400
so that's it for building a link list of

19717
12:25:29,560 --> 12:25:33,840
size zero like we're sort of done then

19718
12:25:32,400 --> 12:25:35,800
but we want to now add a one and then a

19719
12:25:33,840 --> 12:25:38,039
two then a three so next step here might

19720
12:25:35,800 --> 12:25:41,276
be this if I want to allocate the first

19721
12:25:38,040 --> 12:25:42,956
of my rectangles on our previous picture

19722
12:25:41,276 --> 12:25:45,240
I'm going to call malok and I'm going to

19723
12:25:42,956 --> 12:25:47,080
ask for enough memory to fit a whole

19724
12:25:45,240 --> 12:25:48,799
node now technically I think that's

19725
12:25:47,080 --> 12:25:50,400
going to be like four bytes for the int

19726
12:25:48,800 --> 12:25:52,276
and eight bytes for the pointer even

19727
12:25:50,400 --> 12:25:54,240
though I did not draw it to scale on the

19728
12:25:52,276 --> 12:25:56,640
board so that's technically going to be

19729
12:25:54,240 --> 12:25:58,360
what 12 bytes but again size of node

19730
12:25:56,640 --> 12:26:00,000
just figures out how many bytes I

19731
12:25:58,360 --> 12:26:02,080
actually need dynamically that's going

19732
12:26:00,000 --> 12:26:03,880
to return to me the address of that

19733
12:26:02,080 --> 12:26:05,880
chunk of memory which apparently I'm

19734
12:26:03,880 --> 12:26:08,479
going to store inside of a temporary

19735
12:26:05,880 --> 12:26:10,640
variable called n for short for node but

19736
12:26:08,480 --> 12:26:12,400
let's see what this does pictorially so

19737
12:26:10,640 --> 12:26:15,276
when this line of code is executed I

19738
12:26:12,400 --> 12:26:17,320
first get on the left that variable n

19739
12:26:15,276 --> 12:26:19,000
it's got a garbage value by default

19740
12:26:17,320 --> 12:26:20,956
because I haven't executed the whole

19741
12:26:19,000 --> 12:26:22,436
thing from right to left meanwhile on

19742
12:26:20,956 --> 12:26:24,479
the right hand side of the expression

19743
12:26:22,436 --> 12:26:25,956
I've got now a node somewhere in memory

19744
12:26:24,480 --> 12:26:27,916
it happened to be free here this is

19745
12:26:25,956 --> 12:26:29,479
where malok put it for me but it does

19746
12:26:27,916 --> 12:26:32,079
have two garbage values initially but

19747
12:26:29,480 --> 12:26:34,436
because it's a node per my type def

19748
12:26:32,080 --> 12:26:37,400
earlier every node I proposed is going

19749
12:26:34,436 --> 12:26:39,080
to have a number and a next pointer so

19750
12:26:37,400 --> 12:26:40,880
we can see those labeled here but

19751
12:26:39,080 --> 12:26:42,756
they've got two garbage values initially

19752
12:26:40,880 --> 12:26:46,115
but all I care about initially is that

19753
12:26:42,756 --> 12:26:47,880
ultimately n is pointing at that chunk

19754
12:26:46,116 --> 12:26:48,956
of code so initially if we could back up

19755
12:26:47,880 --> 12:26:53,115
two

19756
12:26:48,956 --> 12:26:55,116
steps we have two steps so we have initi

19757
12:26:53,116 --> 12:26:58,080
one step forward we have this line of

19758
12:26:55,116 --> 12:27:00,320
code gives us this variable here which

19759
12:26:58,080 --> 12:27:02,116
has garbage when this side of the

19760
12:27:00,320 --> 12:27:04,400
expression is executed that allocates

19761
12:27:02,116 --> 12:27:06,400
the memory and then when we copy from

19762
12:27:04,400 --> 12:27:08,080
right to left the address of that chunk

19763
12:27:06,400 --> 12:27:10,040
of memory that's what gives us

19764
12:27:08,080 --> 12:27:11,840
conceptually this arrow and the garbage

19765
12:27:10,040 --> 12:27:13,480
goes away because it's a valid pointer

19766
12:27:11,840 --> 12:27:14,916
now of course there's still two garbage

19767
12:27:13,480 --> 12:27:16,800
values there because we haven't set this

19768
12:27:14,916 --> 12:27:18,200
node to store a number like the number

19769
12:27:16,800 --> 12:27:20,596
one so let's go ahead and execute one

19770
12:27:18,200 --> 12:27:22,360
other line of code like this which while

19771
12:27:20,596 --> 12:27:24,520
cryptic looking is just an application

19772
12:27:22,360 --> 12:27:27,560
of ideas we've seen in week four and

19773
12:27:24,520 --> 12:27:30,276
prior star N means to start at this

19774
12:27:27,560 --> 12:27:32,159
variable and go there Follow the arrow

19775
12:27:30,276 --> 12:27:34,276
is what the star or the D reference

19776
12:27:32,160 --> 12:27:36,200
operator does for us and then the dot

19777
12:27:34,276 --> 12:27:38,720
operator recall when we first introduce

19778
12:27:36,200 --> 12:27:40,916
structs like for a person struct allows

19779
12:27:38,720 --> 12:27:43,520
us to go at the number field or the next

19780
12:27:40,916 --> 12:27:44,840
field so if I do star n and then in

19781
12:27:43,520 --> 12:27:47,159
parentheses to make sure order of

19782
12:27:44,840 --> 12:27:49,200
operations is preserved do number and

19783
12:27:47,160 --> 12:27:50,800
then assign it the actual number one

19784
12:27:49,200 --> 12:27:53,115
which puts the one in the top of that

19785
12:27:50,800 --> 12:27:54,640
rectangle now admittedly this syntax is

19786
12:27:53,116 --> 12:27:56,276
not very user friendly it's annoying to

19787
12:27:54,640 --> 12:27:58,400
remember you have to the parentheses so

19788
12:27:56,276 --> 12:28:00,200
there's another Syntax for this whenever

19789
12:27:58,400 --> 12:28:03,160
you're doing two things like this in

19790
12:28:00,200 --> 12:28:05,399
code dereferencing a pointer that is

19791
12:28:03,160 --> 12:28:07,520
going to an address and then further

19792
12:28:05,400 --> 12:28:09,640
using the dot notation to go inside of

19793
12:28:07,520 --> 12:28:12,359
the structure you find that wonderfully

19794
12:28:09,640 --> 12:28:14,680
C gives us this syntax whereby you can

19795
12:28:12,360 --> 12:28:16,720
just change the star and the parentheses

19796
12:28:14,680 --> 12:28:18,160
and the dot to just be an arrow and

19797
12:28:16,720 --> 12:28:19,720
again it's not a single character on

19798
12:28:18,160 --> 12:28:21,680
your keyboard it's a hyphen and then an

19799
12:28:19,720 --> 12:28:23,480
open angle bracket but I kind of like

19800
12:28:21,680 --> 12:28:26,240
the semantics of this because this code

19801
12:28:23,480 --> 12:28:28,436
now pretty much matches the picture n

19802
12:28:26,240 --> 12:28:30,560
arrow leads you to the value that you

19803
12:28:28,436 --> 12:28:32,640
want to access or ultimately change in

19804
12:28:30,560 --> 12:28:34,399
this way there's one step though we've

19805
12:28:32,640 --> 12:28:36,436
forgotten of course which is that we

19806
12:28:34,400 --> 12:28:38,276
can't leave this garbage value here

19807
12:28:36,436 --> 12:28:40,360
because the garbage value is some

19808
12:28:38,276 --> 12:28:42,000
unknown value that effectively is

19809
12:28:40,360 --> 12:28:43,880
pointing who knows where and we don't

19810
12:28:42,000 --> 12:28:45,880
want to accidentally misinterpret that

19811
12:28:43,880 --> 12:28:49,000
garbage value as being a valid address

19812
12:28:45,880 --> 12:28:51,360
and risk going there so of course what

19813
12:28:49,000 --> 12:28:53,596
value should we put here instead our old

19814
12:28:51,360 --> 12:28:55,200
friend null just to signify that this is

19815
12:28:53,596 --> 12:28:56,916
indeed the end of the list and we could

19816
12:28:55,200 --> 12:28:58,596
do that with a line of code like this

19817
12:28:56,916 --> 12:29:01,240
and again we'll canote as much by just

19818
12:28:58,596 --> 12:29:03,159
leaving that empty box blank so now we

19819
12:29:01,240 --> 12:29:05,079
have a list of size one let's go ahead

19820
12:29:03,160 --> 12:29:08,800
and add the second number to it as with

19821
12:29:05,080 --> 12:29:11,560
these lines here list equals n allows us

19822
12:29:08,800 --> 12:29:13,560
to remember that indeed we have this

19823
12:29:11,560 --> 12:29:15,240
list here so if we can step one step

19824
12:29:13,560 --> 12:29:17,596
forward here's what the picture now

19825
12:29:15,240 --> 12:29:20,000
looks like and technically let's go one

19826
12:29:17,596 --> 12:29:21,799
step further here this is now really

19827
12:29:20,000 --> 12:29:25,360
what's going on in memory once my list

19828
12:29:21,800 --> 12:29:27,956
of size exists my main variable called

19829
12:29:25,360 --> 12:29:29,596
list is pointing at exactly that first

19830
12:29:27,956 --> 12:29:31,640
node at this point in the story I don't

19831
12:29:29,596 --> 12:29:33,399
need to know or care about the temporary

19832
12:29:31,640 --> 12:29:35,000
variable that I called n even though it

19833
12:29:33,400 --> 12:29:36,720
might very well still be there but

19834
12:29:35,000 --> 12:29:39,200
indeed this now represents that link

19835
12:29:36,720 --> 12:29:41,080
list let's now indeed add the number two

19836
12:29:39,200 --> 12:29:43,200
so with the same line of code as before

19837
12:29:41,080 --> 12:29:45,200
I'm going to allocate another node size

19838
12:29:43,200 --> 12:29:46,799
of node ideally I would be checking for

19839
12:29:45,200 --> 12:29:48,840
null here but we're doing the juicy

19840
12:29:46,800 --> 12:29:50,480
Parts only on the slides let's now go

19841
12:29:48,840 --> 12:29:53,755
ahead and depict that so what happens

19842
12:29:50,480 --> 12:29:54,720
with this this brings back our n pointer

19843
12:29:53,756 --> 12:29:56,400
which might have been there the whole

19844
12:29:54,720 --> 12:29:57,800
time but we're doing this step by step

19845
12:29:56,400 --> 12:29:59,436
it's a garbage value though because we

19846
12:29:57,800 --> 12:30:01,116
haven't yet copied from right to left

19847
12:29:59,436 --> 12:30:03,436
Malo of course gives us a second chunk

19848
12:30:01,116 --> 12:30:05,160
of memory which maybe ends up there with

19849
12:30:03,436 --> 12:30:06,720
two garbage values by default I've

19850
12:30:05,160 --> 12:30:08,520
omitted the labels now just because

19851
12:30:06,720 --> 12:30:11,080
they're still going to be number and

19852
12:30:08,520 --> 12:30:12,916
next respectively once we copy from

19853
12:30:11,080 --> 12:30:15,436
right to left the garbage value indeed

19854
12:30:12,916 --> 12:30:17,360
becomes an arrow Oscar disappears

19855
12:30:15,436 --> 12:30:19,520
because it's now indeed a valid pointer

19856
12:30:17,360 --> 12:30:21,880
pointing here now the values themselves

19857
12:30:19,520 --> 12:30:24,520
number and next are invalid garbage

19858
12:30:21,880 --> 12:30:26,200
values so here is where we can now start

19859
12:30:24,520 --> 12:30:28,115
using our new syntax like the arrow

19860
12:30:26,200 --> 12:30:31,115
notation or the star and the dot if you

19861
12:30:28,116 --> 12:30:33,480
prefer and we can change the value of n

19862
12:30:31,116 --> 12:30:35,916
Follow the arrow to number and that

19863
12:30:33,480 --> 12:30:39,800
becomes two similarly we can do this

19864
12:30:35,916 --> 12:30:42,115
again and set n arrow next so start at n

19865
12:30:39,800 --> 12:30:44,596
Follow the arrow access the next field

19866
12:30:42,116 --> 12:30:46,240
and set that equal to null now we're not

19867
12:30:44,596 --> 12:30:48,200
quite done yet because we haven't

19868
12:30:46,240 --> 12:30:50,000
actually linked things together so

19869
12:30:48,200 --> 12:30:52,399
here's now where things get interesting

19870
12:30:50,000 --> 12:30:54,200
how do I combine these two well let me

19871
12:30:52,400 --> 12:30:56,756
me propose this let me propose on our

19872
12:30:54,200 --> 12:31:00,360
next line here we actually update for

19873
12:30:56,756 --> 12:31:02,160
Now list equal to n that is to say

19874
12:31:00,360 --> 12:31:04,720
whatever address this is whatever it's

19875
12:31:02,160 --> 12:31:06,436
pointing at change list to be the same

19876
12:31:04,720 --> 12:31:08,880
address that is point at the same thing

19877
12:31:06,436 --> 12:31:11,080
so if n is pointing here let's change

19878
12:31:08,880 --> 12:31:13,840
list to point here and go ahead and do

19879
12:31:11,080 --> 12:31:16,680
that Carter if you could I don't like

19880
12:31:13,840 --> 12:31:19,840
this can you go one further step this is

19881
12:31:16,680 --> 12:31:22,040
bad what is wrong about my sequence of

19882
12:31:19,840 --> 12:31:23,799
operations here where I updated list to

19883
12:31:22,040 --> 12:31:25,916
point my new

19884
12:31:23,800 --> 12:31:28,560
node

19885
12:31:25,916 --> 12:31:30,520
yeah yeah we lost the pointer to the

19886
12:31:28,560 --> 12:31:33,680
other node so I don't even care about

19887
12:31:30,520 --> 12:31:36,079
the ordering 21 or one two the bigger

19888
12:31:33,680 --> 12:31:37,916
problem now as the lack of arrows over

19889
12:31:36,080 --> 12:31:40,916
there suggests is that I have a memory

19890
12:31:37,916 --> 12:31:42,880
leak I have orphaned my original node in

19891
12:31:40,916 --> 12:31:45,040
the sense that nothing is pointing at it

19892
12:31:42,880 --> 12:31:46,520
anymore now absolutely I could fix this

19893
12:31:45,040 --> 12:31:47,560
by adding some temporary variables I

19894
12:31:46,520 --> 12:31:49,479
could add it to the mix but at this

19895
12:31:47,560 --> 12:31:51,916
point in the story I have not done any

19896
12:31:49,480 --> 12:31:53,520
such uh recollection thereof so let me

19897
12:31:51,916 --> 12:31:55,040
back this up and let's go forward in the

19898
12:31:53,520 --> 12:31:57,435
slides this is where we left off a

19899
12:31:55,040 --> 12:31:59,596
moment ago I think I need to take into

19900
12:31:57,436 --> 12:32:00,800
account order of operations and I'm

19901
12:31:59,596 --> 12:32:02,640
going to keep this simple I'm not going

19902
12:32:00,800 --> 12:32:05,436
to care about the order of the numbers

19903
12:32:02,640 --> 12:32:08,320
for now I'm fine with a list that is two

19904
12:32:05,436 --> 12:32:11,040
and then one so with that said let me go

19905
12:32:08,320 --> 12:32:13,200
ahead and update I think this box here

19906
12:32:11,040 --> 12:32:16,000
to point at my original node so let's

19907
12:32:13,200 --> 12:32:21,159
see how we can do this in code okay n

19908
12:32:16,000 --> 12:32:22,916
arrow next so n arrow next should equal

19909
12:32:21,160 --> 12:32:25,276
the current list and this is a little

19910
12:32:22,916 --> 12:32:27,200
weird again but recall what list is list

19911
12:32:25,276 --> 12:32:30,040
is this pointer here that just contains

19912
12:32:27,200 --> 12:32:32,916
the address of the original address of

19913
12:32:30,040 --> 12:32:34,916
the list or equivalently it contains

19914
12:32:32,916 --> 12:32:37,000
this Arrow whatever it's pointing at so

19915
12:32:34,916 --> 12:32:39,276
what this means in this line of code n

19916
12:32:37,000 --> 12:32:41,720
bracket next means start at n Follow the

19917
12:32:39,276 --> 12:32:44,756
arrow access the next pointer and set it

19918
12:32:41,720 --> 12:32:48,160
equal to whatever list equals so if list

19919
12:32:44,756 --> 12:32:50,840
is pointing here then next should point

19920
12:32:48,160 --> 12:32:52,400
there as well this I think is safe

19921
12:32:50,840 --> 12:32:54,039
because now we have redundancy now we've

19922
12:32:52,400 --> 12:32:56,200
got two pointers pointing at the

19923
12:32:54,040 --> 12:32:59,276
original list and now I think we can do

19924
12:32:56,200 --> 12:33:01,360
another step whereby we update list to

19925
12:32:59,276 --> 12:33:02,840
equal n same line of code before that

19926
12:33:01,360 --> 12:33:04,800
got us into trouble but I'm doing it

19927
12:33:02,840 --> 12:33:08,479
second now instead of first when I

19928
12:33:04,800 --> 12:33:10,916
execute list equals n this now sets list

19929
12:33:08,480 --> 12:33:13,880
equal to the same thing that n equals

19930
12:33:10,916 --> 12:33:17,596
and so now I have successfully inserted

19931
12:33:13,880 --> 12:33:19,360
my new node containing two into the list

19932
12:33:17,596 --> 12:33:20,956
and in fact if we advance one more we

19933
12:33:19,360 --> 12:33:22,596
can just clear up the Clutter assume

19934
12:33:20,956 --> 12:33:24,680
that the temporary variable is gone from

19935
12:33:22,596 --> 12:33:26,435
the story now we have a linked list

19936
12:33:24,680 --> 12:33:28,160
where admittedly ordering is wrong it's

19937
12:33:26,436 --> 12:33:30,756
21 instead of one two but at least it's

19938
12:33:28,160 --> 12:33:32,956
linked correctly and I didn't orphan or

19939
12:33:30,756 --> 12:33:35,720
leak any

19940
12:33:32,956 --> 12:33:36,756
memory questions on this sequence of

19941
12:33:35,720 --> 12:33:38,370
steps

19942
12:33:36,756 --> 12:33:41,419
here yeah in

19943
12:33:38,370 --> 12:33:41,419
[Music]

19944
12:33:44,800 --> 12:33:49,800
back yeah spot on so this would fall

19945
12:33:47,276 --> 12:33:51,520
under that category of a stack if you

19946
12:33:49,800 --> 12:33:53,756
will although I've not called it that by

19947
12:33:51,520 --> 12:33:56,039
name because I just pushed the number

19948
12:33:53,756 --> 12:33:57,880
two onto this data structure if you will

19949
12:33:56,040 --> 12:34:00,040
and indeed it ended up at the beginning

19950
12:33:57,880 --> 12:34:01,200
of the list instead of the end and so

19951
12:34:00,040 --> 12:34:02,880
here's where we see a distinction

19952
12:34:01,200 --> 12:34:04,755
between an abstract data structure which

19953
12:34:02,880 --> 12:34:06,520
is where we began a stack is a thing

19954
12:34:04,756 --> 12:34:09,560
like the pile of sweaters that just has

19955
12:34:06,520 --> 12:34:12,956
push and pop properties and lifo access

19956
12:34:09,560 --> 12:34:14,560
like uh last in first out how do you

19957
12:34:12,956 --> 12:34:16,040
implement something like that in memory

19958
12:34:14,560 --> 12:34:18,596
well it would seem that you could

19959
12:34:16,040 --> 12:34:20,680
implement the notion of a stack here not

19960
12:34:18,596 --> 12:34:23,159
for sweaters but for numbers using a

19961
12:34:20,680 --> 12:34:26,840
linked list so long as you implement

19962
12:34:23,160 --> 12:34:29,116
insertion AKA pushing by prepending new

19963
12:34:26,840 --> 12:34:30,276
values to the list by prepending again

19964
12:34:29,116 --> 12:34:32,080
and again and if Carter you don't mind

19965
12:34:30,276 --> 12:34:34,115
hitting the keyboard one more time if I

19966
12:34:32,080 --> 12:34:36,480
wanted to add the number three now you

19967
12:34:34,116 --> 12:34:38,756
would could imagine prepending it to the

19968
12:34:36,480 --> 12:34:41,080
list why well honestly especially as

19969
12:34:38,756 --> 12:34:43,520
this list gets longer and longer I kind

19970
12:34:41,080 --> 12:34:45,596
of like the appeal of prepending these

19971
12:34:43,520 --> 12:34:48,520
elements why because even if this list

19972
12:34:45,596 --> 12:34:50,479
gets crazy long and way way out here you

19973
12:34:48,520 --> 12:34:52,560
didn't notice me following all of the

19974
12:34:50,480 --> 12:34:54,400
arrows earlier to do the insert if I

19975
12:34:52,560 --> 12:34:56,756
want to insert a fourth number a fifth

19976
12:34:54,400 --> 12:34:58,956
number a sixth number all I have to do

19977
12:34:56,756 --> 12:35:01,840
is like insert it here if you will point

19978
12:34:58,956 --> 12:35:03,560
it at the original uh start of the list

19979
12:35:01,840 --> 12:35:05,596
then update this pointer and done and I

19980
12:35:03,560 --> 12:35:07,956
would say that's like two steps give or

19981
12:35:05,596 --> 12:35:10,360
take it's not going to be end steps as

19982
12:35:07,956 --> 12:35:12,596
it would be if I had to upend the new

19983
12:35:10,360 --> 12:35:14,436
nodes to the end of the list now of

19984
12:35:12,596 --> 12:35:15,840
course we've sacrificed ordering of

19985
12:35:14,436 --> 12:35:17,320
these numbers they're literally in the

19986
12:35:15,840 --> 12:35:19,039
opposite order or whatever order they

19987
12:35:17,320 --> 12:35:21,240
were inserted in but that might very

19988
12:35:19,040 --> 12:35:23,040
well be okay depending on the goal at

19989
12:35:21,240 --> 12:35:24,640
hand all right thank you to Carter for

19990
12:35:23,040 --> 12:35:28,800
stepping through this what if now we

19991
12:35:24,640 --> 12:35:28,800
wanted to translate this oh sure thank

19992
12:35:29,080 --> 12:35:34,560
you it's all for you none for me in this

19993
12:35:31,880 --> 12:35:36,560
example so here we have perhaps a way of

19994
12:35:34,560 --> 12:35:38,040
translating this now to some actual code

19995
12:35:36,560 --> 12:35:40,079
and this will be the last of like the

19996
12:35:38,040 --> 12:35:41,756
sort of intense code here just to give

19997
12:35:40,080 --> 12:35:44,916
you a sense of how we can translate this

19998
12:35:41,756 --> 12:35:47,040
idea now to actual step so this is list.

19999
12:35:44,916 --> 12:35:49,040
C and VSS code here let me go ahead and

20000
12:35:47,040 --> 12:35:52,640
make a couple of changes up top let me

20001
12:35:49,040 --> 12:35:56,160
go ahead and how about uh declaring a

20002
12:35:52,640 --> 12:35:58,720
node using typ def uh struct node using

20003
12:35:56,160 --> 12:36:00,916
our new framing as before I'm going to

20004
12:35:58,720 --> 12:36:03,720
give every node a number as I proposed

20005
12:36:00,916 --> 12:36:06,159
and every node a pointer to the next

20006
12:36:03,720 --> 12:36:07,880
element which is going to be implemented

20007
12:36:06,160 --> 12:36:10,160
just as before and I'm going to simplify

20008
12:36:07,880 --> 12:36:12,040
the whole name as just node so all of

20009
12:36:10,160 --> 12:36:14,436
that is is the exact same type depth

20010
12:36:12,040 --> 12:36:16,840
that we proposed earlier now let me go

20011
12:36:14,436 --> 12:36:18,756
ahead and get rid of all of this code

20012
12:36:16,840 --> 12:36:20,276
which we wrote earlier and recall that

20013
12:36:18,756 --> 12:36:22,276
this was the most recent version that

20014
12:36:20,276 --> 12:36:24,360
was not a linked list this was just in

20015
12:36:22,276 --> 12:36:26,320
Array that we allocated and then

20016
12:36:24,360 --> 12:36:28,160
reallocated so this is sort of the old

20017
12:36:26,320 --> 12:36:30,000
way of doing things but it was

20018
12:36:28,160 --> 12:36:32,680
inefficient because we might have to

20019
12:36:30,000 --> 12:36:34,560
lean on a for Loop or lean on realloc to

20020
12:36:32,680 --> 12:36:36,840
copy everything around we're now going

20021
12:36:34,560 --> 12:36:41,115
to reimplement the notion of a list as

20022
12:36:36,840 --> 12:36:42,956
an actual linked list not as an array so

20023
12:36:41,116 --> 12:36:44,320
my main function now might do something

20024
12:36:42,956 --> 12:36:46,116
like this and I'm going to really just

20025
12:36:44,320 --> 12:36:47,880
copy the lines of code that we just

20026
12:36:46,116 --> 12:36:50,400
stepped through on the board so let me

20027
12:36:47,880 --> 12:36:52,159
give myself a uh special variable called

20028
12:36:50,400 --> 12:36:53,880
list that's going to be initialized to

20029
12:36:52,160 --> 12:36:55,160
null and this is just my pointer the

20030
12:36:53,880 --> 12:36:57,200
square on the left hand side of the

20031
12:36:55,160 --> 12:36:58,680
screen that represents the start of the

20032
12:36:57,200 --> 12:37:01,360
list and if it's null it means the list

20033
12:36:58,680 --> 12:37:04,596
is empty so done I'm done implementing a

20034
12:37:01,360 --> 12:37:06,200
linked list of size zero well now how do

20035
12:37:04,596 --> 12:37:07,756
I want to run this code well let me

20036
12:37:06,200 --> 12:37:09,640
propose for the sake of discussion that

20037
12:37:07,756 --> 12:37:11,436
this version of the program will take

20038
12:37:09,640 --> 12:37:12,880
command line arguments so I want to be

20039
12:37:11,436 --> 12:37:15,436
able to do something like this I want to

20040
12:37:12,880 --> 12:37:17,240
run this program ultimately and type in

20041
12:37:15,436 --> 12:37:20,160
three command line arguments like this 1

20042
12:37:17,240 --> 12:37:22,956
2 3 and I want my program in a couple

20043
12:37:20,160 --> 12:37:25,360
minutes to allocate one two three nodes

20044
12:37:22,956 --> 12:37:27,640
and Stitch them together just like the

20045
12:37:25,360 --> 12:37:29,400
visualization on the board uh I could

20046
12:37:27,640 --> 12:37:31,116
use get int but it's just going to be

20047
12:37:29,400 --> 12:37:32,436
faster if we use command line arguments

20048
12:37:31,116 --> 12:37:34,320
so again I'm just borrowing some

20049
12:37:32,436 --> 12:37:36,000
Concepts from week two but none of

20050
12:37:34,320 --> 12:37:39,720
that's possible yet until I change my

20051
12:37:36,000 --> 12:37:43,596
code here so let's do this in argc uh

20052
12:37:39,720 --> 12:37:45,360
string uh argv but you know what we know

20053
12:37:43,596 --> 12:37:47,680
that strings are not actually a thing

20054
12:37:45,360 --> 12:37:49,400
anymore so I can change my command line

20055
12:37:47,680 --> 12:37:52,116
argument definition to be what it really

20056
12:37:49,400 --> 12:37:54,200
is it's really charar but it's the exact

20057
12:37:52,116 --> 12:37:56,040
same thing as in week two just strings

20058
12:37:54,200 --> 12:37:58,159
are no more at least without the

20059
12:37:56,040 --> 12:38:01,480
training wheels on anymore like last

20060
12:37:58,160 --> 12:38:06,720
week and now let me do this uh for in I

20061
12:38:01,480 --> 12:38:08,080
equal 1 uh I is less than ARG C i++ so

20062
12:38:06,720 --> 12:38:09,400
what I'm doing with this Loop is I just

20063
12:38:08,080 --> 12:38:11,680
want to iterate over the command line

20064
12:38:09,400 --> 12:38:14,160
argument so I have one number at a time

20065
12:38:11,680 --> 12:38:18,520
from The Prompt um what else do I want

20066
12:38:14,160 --> 12:38:22,276
to do here uh well let's go ahead and

20067
12:38:18,520 --> 12:38:26,399
how about do this um let's get

20068
12:38:22,276 --> 12:38:28,479
a number so in number equals arv braet I

20069
12:38:26,400 --> 12:38:31,040
so a couple of notes Here one I'm

20070
12:38:28,480 --> 12:38:33,560
starting my for loop at one instead of

20071
12:38:31,040 --> 12:38:35,240
zero but I'm going up to RC RC is

20072
12:38:33,560 --> 12:38:37,200
argument count how many words are at the

20073
12:38:35,240 --> 12:38:40,200
prompt why am I starting at one instead

20074
12:38:37,200 --> 12:38:44,560
of zero though given my

20075
12:38:40,200 --> 12:38:44,560
goal why am I starting at one

20076
12:38:48,720 --> 12:38:53,276
yeah yeah so the first value in RV is is

20077
12:38:51,756 --> 12:38:54,916
actually the name of the program that's

20078
12:38:53,276 --> 12:38:56,520
obviously not a number so I want the

20079
12:38:54,916 --> 12:38:57,755
second value so I'm going to start

20080
12:38:56,520 --> 12:38:59,799
iterating over those command line

20081
12:38:57,756 --> 12:39:01,520
arguments at I equals 1 so that's all I

20082
12:38:59,800 --> 12:39:04,200
just want to get the actual numbers at

20083
12:39:01,520 --> 12:39:08,000
the prompt um unfortunately argv bracket

20084
12:39:04,200 --> 12:39:09,799
I is a string AKA Char star that is not

20085
12:39:08,000 --> 12:39:11,916
an INT so this line of code won't work

20086
12:39:09,800 --> 12:39:14,276
but can anyone think back to like week

20087
12:39:11,916 --> 12:39:15,916
two where we had a function for

20088
12:39:14,276 --> 12:39:19,640
converting strings to

20089
12:39:15,916 --> 12:39:21,276
integers anyone yeah so a to I is a

20090
12:39:19,640 --> 12:39:23,276
function that converts asky to an

20091
12:39:21,276 --> 12:39:25,040
integer assuming what you give it as an

20092
12:39:23,276 --> 12:39:27,000
argument looks like a number like one or

20093
12:39:25,040 --> 12:39:28,956
two or three so let me fix this let me

20094
12:39:27,000 --> 12:39:30,956
actually do the conversion if I were

20095
12:39:28,956 --> 12:39:32,560
really being careful I would error check

20096
12:39:30,956 --> 12:39:34,040
this make sure that there's no digits

20097
12:39:32,560 --> 12:39:35,756
just like you might have in problem set

20098
12:39:34,040 --> 12:39:37,436
two but for today's purposes I'm just

20099
12:39:35,756 --> 12:39:39,756
going to assume the honor System that

20100
12:39:37,436 --> 12:39:42,000
the user me is going to run the program

20101
12:39:39,756 --> 12:39:43,800
correctly all right so now that I have a

20102
12:39:42,000 --> 12:39:45,640
variable containing the number from the

20103
12:39:43,800 --> 12:39:48,520
command line let's just allocate a node

20104
12:39:45,640 --> 12:39:50,360
for it so let me do node star n just

20105
12:39:48,520 --> 12:39:53,435
like we did in the visualization and

20106
12:39:50,360 --> 12:39:56,436
let's malok enough space for the size of

20107
12:39:53,436 --> 12:40:00,640
one such node here I now need to just be

20108
12:39:56,436 --> 12:40:02,480
super safe so if n equals equals null

20109
12:40:00,640 --> 12:40:04,200
like if I'm out of memory you know what

20110
12:40:02,480 --> 12:40:07,680
let me go ahead and just immediately

20111
12:40:04,200 --> 12:40:11,276
return one here otherwise if that's not

20112
12:40:07,680 --> 12:40:14,160
the case let me go ahead and update the

20113
12:40:11,276 --> 12:40:16,560
number field of this new node which it

20114
12:40:14,160 --> 12:40:18,880
line 24 does exist because it did not

20115
12:40:16,560 --> 12:40:20,916
return null so I did not exit early with

20116
12:40:18,880 --> 12:40:23,200
return and let me just store whatever

20117
12:40:20,916 --> 12:40:26,360
number that human typed in first so the

20118
12:40:23,200 --> 12:40:28,956
return value of a to I which per line 17

20119
12:40:26,360 --> 12:40:33,756
is in my variable called number and then

20120
12:40:28,956 --> 12:40:38,520
let me go ahead and just prepend this to

20121
12:40:33,756 --> 12:40:41,400
the list let me go ahead and say that um

20122
12:40:38,520 --> 12:40:43,000
this next field first has a known value

20123
12:40:41,400 --> 12:40:45,080
null just so that we get rid of that

20124
12:40:43,000 --> 12:40:47,436
second garbage value and let me go ahead

20125
12:40:45,080 --> 12:40:49,436
and now prepend it to the list so if I

20126
12:40:47,436 --> 12:40:52,360
want to prepend it that means this new

20127
12:40:49,436 --> 12:40:56,200
node must have a next field field that

20128
12:40:52,360 --> 12:40:59,000
points to the current beginning of the

20129
12:40:56,200 --> 12:41:01,000
list and again the goal here is to preen

20130
12:40:59,000 --> 12:41:03,400
Preen Preen so whatever the current list

20131
12:41:01,000 --> 12:41:07,680
is let's change it so that this new node

20132
12:41:03,400 --> 12:41:10,160
points to that existing list and now

20133
12:41:07,680 --> 12:41:13,040
step two as before was to update the

20134
12:41:10,160 --> 12:41:14,916
actual list to point at this node so

20135
12:41:13,040 --> 12:41:16,720
recall in red on the screen before I

20136
12:41:14,916 --> 12:41:18,755
screwed up originally and I only did

20137
12:41:16,720 --> 12:41:21,080
this line by moving the pointer too

20138
12:41:18,756 --> 12:41:22,956
early if you will but I fixed that once

20139
12:41:21,080 --> 12:41:25,360
Carter helped me rewind and we got rid

20140
12:41:22,956 --> 12:41:28,840
of the red line which indicated error

20141
12:41:25,360 --> 12:41:30,596
and I just do n arrow next to change the

20142
12:41:28,840 --> 12:41:32,399
next field of this new node to point to

20143
12:41:30,596 --> 12:41:34,840
the existing list so I'm not orphaning

20144
12:41:32,400 --> 12:41:38,560
anything all right at this point in the

20145
12:41:34,840 --> 12:41:40,799
story I think my code is

20146
12:41:38,560 --> 12:41:42,320
correct not batting very well though

20147
12:41:40,800 --> 12:41:43,720
today but I think my code is correct but

20148
12:41:42,320 --> 12:41:45,360
the program doesn't do anything

20149
12:41:43,720 --> 12:41:47,360
interesting so it would be nice to kind

20150
12:41:45,360 --> 12:41:49,436
of now iterate over this link list in

20151
12:41:47,360 --> 12:41:51,480
memory whatever its order is and print

20152
12:41:49,436 --> 12:41:53,240
things out well how do we do that well

20153
12:41:51,480 --> 12:41:55,680
it turns out if you want to iterate over

20154
12:41:53,240 --> 12:41:57,320
a linked List the general Paradigm is to

20155
12:41:55,680 --> 12:41:59,116
do something like this to define a

20156
12:41:57,320 --> 12:42:00,520
temporary variable I could call it temp

20157
12:41:59,116 --> 12:42:03,400
but another convention that you might as

20158
12:42:00,520 --> 12:42:05,039
well see is called pointer PTR for short

20159
12:42:03,400 --> 12:42:06,400
but you can call it anything you want

20160
12:42:05,040 --> 12:42:08,436
and you can have a temporary variable

20161
12:42:06,400 --> 12:42:10,276
first point at the first node in the

20162
12:42:08,436 --> 12:42:12,160
list and then in some kind of loop like

20163
12:42:10,276 --> 12:42:13,680
a while loop you point it at the second

20164
12:42:12,160 --> 12:42:15,200
node in the list and then you keep

20165
12:42:13,680 --> 12:42:16,400
iterating you point it at the last node

20166
12:42:15,200 --> 12:42:18,755
in the list and then eventually you

20167
12:42:16,400 --> 12:42:20,880
iterate too far effectively pointing at

20168
12:42:18,756 --> 12:42:22,720
null at which point your while loop can

20169
12:42:20,880 --> 12:42:24,435
presumably terminate so how do I

20170
12:42:22,720 --> 12:42:26,756
Implement that idea of allocating a

20171
12:42:24,436 --> 12:42:28,480
temporary pointer that just points at

20172
12:42:26,756 --> 12:42:30,276
each node in the list and lets me print

20173
12:42:28,480 --> 12:42:32,480
out ultimately each of those numbers

20174
12:42:30,276 --> 12:42:35,159
well let's go back to my code here and

20175
12:42:32,480 --> 12:42:37,840
let me do this let me go ahead and

20176
12:42:35,160 --> 12:42:39,520
declare this temporary pointer which is

20177
12:42:37,840 --> 12:42:41,240
going to be a node star also why because

20178
12:42:39,520 --> 12:42:42,755
it's the address of a node the first the

20179
12:42:41,240 --> 12:42:44,159
second the third and I'm going to set

20180
12:42:42,756 --> 12:42:46,360
that equal to whatever the beginning of

20181
12:42:44,160 --> 12:42:48,080
the list is so that is going to be

20182
12:42:46,360 --> 12:42:49,756
equivalent to this version of the

20183
12:42:48,080 --> 12:42:52,160
picture here where pointer is just

20184
12:42:49,756 --> 12:42:53,720
temporarily pointing at the first node

20185
12:42:52,160 --> 12:42:55,840
in the list it's not pointing at list

20186
12:42:53,720 --> 12:42:57,880
per se it's pointing at the first node

20187
12:42:55,840 --> 12:43:00,276
in the list which list is also pointing

20188
12:42:57,880 --> 12:43:01,799
at itself all right once I've done this

20189
12:43:00,276 --> 12:43:03,799
I think I can translate this to code

20190
12:43:01,800 --> 12:43:06,916
that's a little new but it's

20191
12:43:03,800 --> 12:43:10,360
conceptually familiar perhaps now while

20192
12:43:06,916 --> 12:43:12,719
that pointer does not equal null so

20193
12:43:10,360 --> 12:43:14,800
while I have a valid pointer like my

20194
12:43:12,720 --> 12:43:16,680
finger or that arrow is pointing at an

20195
12:43:14,800 --> 12:43:18,276
actual node in memory well let me go

20196
12:43:16,680 --> 12:43:21,360
ahead and print it out so let me print

20197
12:43:18,276 --> 12:43:25,640
out with percent I back sln whatever is

20198
12:43:21,360 --> 12:43:27,640
in the current node at the number field

20199
12:43:25,640 --> 12:43:29,400
within and again this is going to have

20200
12:43:27,640 --> 12:43:32,479
the effect hopefully of first printing

20201
12:43:29,400 --> 12:43:35,116
the three and I think I just need to Now

20202
12:43:32,480 --> 12:43:36,756
update the pointer so that on the next

20203
12:43:35,116 --> 12:43:39,400
iteration it's pointing at the next

20204
12:43:36,756 --> 12:43:42,000
value so if this is where the story is

20205
12:43:39,400 --> 12:43:43,880
how do I update pointer to point at the

20206
12:43:42,000 --> 12:43:45,840
second element of the list well I want

20207
12:43:43,880 --> 12:43:48,159
pointer to point at the two and I want

20208
12:43:45,840 --> 12:43:49,719
pointer to eventually point at the three

20209
12:43:48,160 --> 12:43:51,680
well how do I do that well the way in

20210
12:43:49,720 --> 12:43:54,000
code I can follow these arrows is as

20211
12:43:51,680 --> 12:43:56,116
follows if I currently have pointer

20212
12:43:54,000 --> 12:43:59,320
pointing at this node but I want to

20213
12:43:56,116 --> 12:44:01,640
point it at the next node I can borrow

20214
12:43:59,320 --> 12:44:04,240
this pointer here so whatever this

20215
12:44:01,640 --> 12:44:07,080
address is in the first node aka the

20216
12:44:04,240 --> 12:44:09,000
next field I can copy that into pointer

20217
12:44:07,080 --> 12:44:10,720
because then pointer will point at

20218
12:44:09,000 --> 12:44:13,116
whatever this is pointing at by just

20219
12:44:10,720 --> 12:44:16,000
setting one equal to the other so once

20220
12:44:13,116 --> 12:44:19,080
I've done that the picture will

20221
12:44:16,000 --> 12:44:21,916
become this and how do I translate that

20222
12:44:19,080 --> 12:44:24,080
to code it while new syntax is

20223
12:44:21,916 --> 12:44:26,880
surprisingly straightforward all I need

20224
12:44:24,080 --> 12:44:30,320
do is say pointer after printing it

20225
12:44:26,880 --> 12:44:32,520
equals whatever pointer currently is but

20226
12:44:30,320 --> 12:44:34,840
grab its next field

20227
12:44:32,520 --> 12:44:37,159
instead and this is a very common

20228
12:44:34,840 --> 12:44:38,799
Paradigm when iterating over a link list

20229
12:44:37,160 --> 12:44:41,560
and you're using some temporary variable

20230
12:44:38,800 --> 12:44:43,320
like pointer you can simply set pointer

20231
12:44:41,560 --> 12:44:46,560
equal to pointer next and what that

20232
12:44:43,320 --> 12:44:50,000
means here is as follows if this is

20233
12:44:46,560 --> 12:44:52,360
pointer pointing from here down to here

20234
12:44:50,000 --> 12:44:54,560
pointer next is Follow the arrow grab

20235
12:44:52,360 --> 12:44:56,520
the next field so if you set pointer

20236
12:44:54,560 --> 12:44:59,916
equal to this thing that's the same

20237
12:44:56,520 --> 12:45:02,916
thing as pointing this at this same box

20238
12:44:59,916 --> 12:45:04,276
and indeed if I advance to the next

20239
12:45:02,916 --> 12:45:05,560
slide even though the arrows are

20240
12:45:04,276 --> 12:45:06,799
technically pointing at different parts

20241
12:45:05,560 --> 12:45:09,115
of the rectangles that's just for

20242
12:45:06,800 --> 12:45:10,680
graphic sake pointer is now pointing at

20243
12:45:09,116 --> 12:45:12,880
the second node and when I do this again

20244
12:45:10,680 --> 12:45:15,116
on my next iteration it points at this

20245
12:45:12,880 --> 12:45:18,435
and then this last step notice when I

20246
12:45:15,116 --> 12:45:20,800
keep doing pointer equals pointer next

20247
12:45:18,436 --> 12:45:23,880
this will become eventually this value

20248
12:45:20,800 --> 12:45:26,480
but what's this value in this link list

20249
12:45:23,880 --> 12:45:28,840
it's null technically so this Arrow will

20250
12:45:26,480 --> 12:45:31,240
eventually take on this value when I set

20251
12:45:28,840 --> 12:45:34,755
pointer equal to pointer next and at

20252
12:45:31,240 --> 12:45:36,560
that point PTR my temporary pointer is

20253
12:45:34,756 --> 12:45:38,720
going to be null so it might as well

20254
12:45:36,560 --> 12:45:42,000
look like this pictorially and what does

20255
12:45:38,720 --> 12:45:43,756
that mean for my Loop once pointer is

20256
12:45:42,000 --> 12:45:45,480
null because you've walked off the end

20257
12:45:43,756 --> 12:45:49,520
of the length list what's going to be

20258
12:45:45,480 --> 12:45:53,200
true of this Loop here started in line

20259
12:45:49,520 --> 12:45:55,520
32 any OB observations

20260
12:45:53,200 --> 12:45:57,479
here what's going to be true what will

20261
12:45:55,520 --> 12:45:59,000
happen now as soon as we hit the end of

20262
12:45:57,480 --> 12:46:01,596
the list yeah

20263
12:45:59,000 --> 12:46:03,640
sorry the loop is going to break out why

20264
12:46:01,596 --> 12:46:05,880
because line 32 which is constantly

20265
12:46:03,640 --> 12:46:07,956
asking well pointer does not equal null

20266
12:46:05,880 --> 12:46:10,159
well if pointer finally equals null

20267
12:46:07,956 --> 12:46:12,880
three steps later the four the while

20268
12:46:10,160 --> 12:46:14,080
loop is now done and so what I can do at

20269
12:46:12,880 --> 12:46:15,880
the end of this program once I've

20270
12:46:14,080 --> 12:46:17,116
printed out those values well first

20271
12:46:15,880 --> 12:46:20,115
let's go ahead and open my terminal

20272
12:46:17,116 --> 12:46:22,560
window let's make list okay a compile

20273
12:46:20,116 --> 12:46:25,000
do/ list and let me try the same values

20274
12:46:22,560 --> 12:46:27,159
one and two and three that's going to

20275
12:46:25,000 --> 12:46:28,800
again allocate one node two node three

20276
12:46:27,160 --> 12:46:30,840
nodes by prepending prepending

20277
12:46:28,800 --> 12:46:32,320
prepending each of those values and it's

20278
12:46:30,840 --> 12:46:34,640
then going to iterate over them from

20279
12:46:32,320 --> 12:46:36,640
left to right and so when I hit enter

20280
12:46:34,640 --> 12:46:39,240
now what should I see on the screen if

20281
12:46:36,640 --> 12:46:39,240
my code is

20282
12:46:39,360 --> 12:46:43,800
correct what will I see feel fre to just

20283
12:46:41,680 --> 12:46:47,080
call it

20284
12:46:43,800 --> 12:46:49,720
out 321 because I've prepended

20285
12:46:47,080 --> 12:46:52,160
presumably and here we go I indeed see

20286
12:46:49,720 --> 12:46:53,560
321 so the list is is backwards but all

20287
12:46:52,160 --> 12:46:55,400
of the elements are there now

20288
12:46:53,560 --> 12:46:56,880
technically if I ran valgrind on this

20289
12:46:55,400 --> 12:46:59,080
valgren would not be happy because I

20290
12:46:56,880 --> 12:47:00,916
have never freed any of my memory so I

20291
12:46:59,080 --> 12:47:02,680
should probably now have a second Loop

20292
12:47:00,916 --> 12:47:05,276
here that does something like this let

20293
12:47:02,680 --> 12:47:06,880
me again set pointer equal to list I

20294
12:47:05,276 --> 12:47:09,079
don't need to redeclare it because I've

20295
12:47:06,880 --> 12:47:10,399
already created this thing on line 31 I

20296
12:47:09,080 --> 12:47:12,276
just want to reset it to be the

20297
12:47:10,400 --> 12:47:14,480
beginning of the list again and now I

20298
12:47:12,276 --> 12:47:18,956
can do the same kind of thing while PTR

20299
12:47:14,480 --> 12:47:20,880
not equals null go ahead and do this

20300
12:47:18,956 --> 12:47:25,320
well I don't want to just do free

20301
12:47:20,880 --> 12:47:28,640
pointer and then do pointer gets pointer

20302
12:47:25,320 --> 12:47:30,596
next y my goal is to free all of my